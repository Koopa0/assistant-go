package postgres

import (
	"context"
	"log/slog"
	"testing"
	"time"

	"github.com/koopa0/assistant-go/internal/config"
	"github.com/koopa0/assistant-go/test/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestStorage_Creation(t *testing.T) {
	tests := []struct {
		name    string
		config  config.DatabaseConfig
		wantErr bool
	}{
		{
			name: "valid_config",
			config: config.DatabaseConfig{
				URL:             "postgres://user:pass@localhost:5432/testdb?sslmode=disable",
				MaxConnections:  5,
				ConnMaxLifetime: time.Hour,
			},
			wantErr: false,
		},
		{
			name: "invalid_url",
			config: config.DatabaseConfig{
				URL:             "invalid-url",
				MaxConnections:  5,
				ConnMaxLifetime: time.Hour,
			},
			wantErr: true,
		},
		{
			name: "empty_url",
			config: config.DatabaseConfig{
				URL:             "",
				MaxConnections:  5,
				ConnMaxLifetime: time.Hour,
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			logger := testutil.CreateTestLogger(slog.LevelError)

			storage, err := NewStorage(ctx, tt.config, logger)
			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, storage)
			} else {
				// Note: This will fail for invalid URLs in real tests
				// but demonstrates the test structure
				if err == nil {
					assert.NotNil(t, storage)
					storage.Close(ctx)
				}
			}
		})
	}
}

func TestStorage_ConnectionPool(t *testing.T) {
	// This test requires a real database connection
	// Skip if not in integration mode
	if testing.Short() {
		t.Skip("Skipping storage test in short mode")
	}

	// Setup test database
	dbContainer, cleanup := testutil.SetupTestDatabase(t)
	defer cleanup()

	ctx := context.Background()
	logger := testutil.CreateTestLogger(slog.LevelDebug)

	config := config.DatabaseConfig{
		URL:             dbContainer.URL,
		MaxConnections:  5,
		ConnMaxLifetime: time.Hour,
	}

	storage, err := NewStorage(ctx, config, logger)
	require.NoError(t, err, "Should create storage")
	defer storage.Close(ctx)

	t.Run("health_check", func(t *testing.T) {
		err := storage.Health(ctx)
		assert.NoError(t, err, "Health check should pass")
	})

	t.Run("ping", func(t *testing.T) {
		err := storage.Ping(ctx)
		assert.NoError(t, err, "Ping should succeed")
	})

	t.Run("stats", func(t *testing.T) {
		stats := storage.Stats()
		assert.NotNil(t, stats, "Stats should not be nil")
		// Basic validation of stats structure
		assert.GreaterOrEqual(t, stats.MaxConns, int32(0))
		assert.GreaterOrEqual(t, stats.TotalConns, int32(0))
	})
}

func TestStorage_TransactionManagement(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping storage test in short mode")
	}

	// Setup test database
	dbContainer, cleanup := testutil.SetupTestDatabase(t)
	defer cleanup()

	ctx := context.Background()
	logger := testutil.CreateTestLogger(slog.LevelDebug)

	config := config.DatabaseConfig{
		URL:             dbContainer.URL,
		MaxConnections:  5,
		ConnMaxLifetime: time.Hour,
	}

	storage, err := NewStorage(ctx, config, logger)
	require.NoError(t, err)
	defer storage.Close(ctx)

	factory := testutil.NewTestDataFactory()

	t.Run("begin_commit_transaction", func(t *testing.T) {
		tx, err := storage.BeginTx(ctx)
		require.NoError(t, err, "Should begin transaction")

		// Perform some operation in transaction
		conversationID := factory.GenerateID()
		userID := factory.GenerateUserID()

		_, err = tx.Exec(ctx, `
			INSERT INTO assistant.conversations (id, user_id, title) 
			VALUES ($1, $2, $3)
		`, conversationID, userID, "Test Transaction")
		assert.NoError(t, err, "Should execute in transaction")

		// Commit transaction
		err = tx.Commit(ctx)
		assert.NoError(t, err, "Should commit transaction")

		// Verify data exists
		var count int
		err = storage.QueryRow(ctx, `
			SELECT COUNT(*) FROM assistant.conversations WHERE id = $1
		`, conversationID).Scan(&count)
		assert.NoError(t, err, "Should query after commit")
		assert.Equal(t, 1, count, "Data should exist after commit")
	})

	t.Run("begin_rollback_transaction", func(t *testing.T) {
		tx, err := storage.BeginTx(ctx)
		require.NoError(t, err, "Should begin transaction")

		// Perform some operation in transaction
		conversationID := factory.GenerateID()
		userID := factory.GenerateUserID()

		_, err = tx.Exec(ctx, `
			INSERT INTO assistant.conversations (id, user_id, title) 
			VALUES ($1, $2, $3)
		`, conversationID, userID, "Test Rollback")
		assert.NoError(t, err, "Should execute in transaction")

		// Rollback transaction
		err = tx.Rollback(ctx)
		assert.NoError(t, err, "Should rollback transaction")

		// Verify data doesn't exist
		var count int
		err = storage.QueryRow(ctx, `
			SELECT COUNT(*) FROM assistant.conversations WHERE id = $1
		`, conversationID).Scan(&count)
		assert.NoError(t, err, "Should query after rollback")
		assert.Equal(t, 0, count, "Data should not exist after rollback")
	})

	t.Run("transaction_context_cancellation", func(t *testing.T) {
		// Create context with short timeout
		txCtx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
		defer cancel()

		tx, err := storage.BeginTx(txCtx)
		require.NoError(t, err, "Should begin transaction")

		// Wait for context to be cancelled
		time.Sleep(200 * time.Millisecond)

		// Try to execute - should fail due to cancelled context
		_, err = tx.Exec(txCtx, "SELECT 1")
		assert.Error(t, err, "Should fail with cancelled context")
	})
}

func TestStorage_QueryOperations(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping storage test in short mode")
	}

	// Setup test database
	dbContainer, cleanup := testutil.SetupTestDatabase(t)
	defer cleanup()

	ctx := context.Background()
	logger := testutil.CreateTestLogger(slog.LevelDebug)

	config := config.DatabaseConfig{
		URL:             dbContainer.URL,
		MaxConnections:  5,
		ConnMaxLifetime: time.Hour,
	}

	storage, err := NewStorage(ctx, config, logger)
	require.NoError(t, err)
	defer storage.Close(ctx)

	factory := testutil.NewTestDataFactory()

	t.Run("exec_operation", func(t *testing.T) {
		conversationID := factory.GenerateID()
		userID := factory.GenerateUserID()
		title := "Test Exec"

		result, err := storage.Exec(ctx, `
			INSERT INTO assistant.conversations (id, user_id, title) 
			VALUES ($1, $2, $3)
		`, conversationID, userID, title)
		assert.NoError(t, err, "Should execute insert")

		rowsAffected := result.RowsAffected()
		assert.Equal(t, int64(1), rowsAffected, "Should affect one row")
	})

	t.Run("query_row_operation", func(t *testing.T) {
		// First insert a conversation
		conversationID := factory.GenerateID()
		userID := factory.GenerateUserID()
		title := "Test Query Row"

		_, err := storage.Exec(ctx, `
			INSERT INTO assistant.conversations (id, user_id, title) 
			VALUES ($1, $2, $3)
		`, conversationID, userID, title)
		require.NoError(t, err)

		// Query the conversation
		var retrievedTitle string
		var retrievedUserID string
		err = storage.QueryRow(ctx, `
			SELECT user_id, title FROM assistant.conversations WHERE id = $1
		`, conversationID).Scan(&retrievedUserID, &retrievedTitle)
		assert.NoError(t, err, "Should query row")
		assert.Equal(t, userID, retrievedUserID, "User ID should match")
		assert.Equal(t, title, retrievedTitle, "Title should match")
	})

	t.Run("query_multiple_rows", func(t *testing.T) {
		// Insert multiple conversations
		userID := factory.GenerateUserID()
		conversationIDs := make([]string, 3)

		for i := 0; i < 3; i++ {
			conversationIDs[i] = factory.GenerateID()
			_, err := storage.Exec(ctx, `
				INSERT INTO assistant.conversations (id, user_id, title) 
				VALUES ($1, $2, $3)
			`, conversationIDs[i], userID, factory.GenerateRandomString(10))
			require.NoError(t, err)
		}

		// Query multiple rows
		rows, err := storage.Query(ctx, `
			SELECT id FROM assistant.conversations WHERE user_id = $1 ORDER BY created_at
		`, userID)
		assert.NoError(t, err, "Should query multiple rows")
		defer rows.Close()

		var retrievedIDs []string
		for rows.Next() {
			var id string
			err := rows.Scan(&id)
			assert.NoError(t, err, "Should scan row")
			retrievedIDs = append(retrievedIDs, id)
		}

		assert.Len(t, retrievedIDs, 3, "Should retrieve 3 conversations")
		for _, id := range conversationIDs {
			assert.Contains(t, retrievedIDs, id, "Should contain inserted ID")
		}
	})

	t.Run("query_with_no_results", func(t *testing.T) {
		var title string
		err := storage.QueryRow(ctx, `
			SELECT title FROM assistant.conversations WHERE id = $1
		`, "non-existent-id").Scan(&title)
		assert.Error(t, err, "Should return error for no results")
	})
}

func TestStorage_ConcurrentOperations(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping storage test in short mode")
	}

	// Setup test database
	dbContainer, cleanup := testutil.SetupTestDatabase(t)
	defer cleanup()

	ctx := context.Background()
	logger := testutil.CreateTestLogger(slog.LevelError) // Reduce logging for concurrent tests

	config := config.DatabaseConfig{
		URL:             dbContainer.URL,
		MaxConnections:  10, // Increase for concurrent tests
		ConnMaxLifetime: time.Hour,
	}

	storage, err := NewStorage(ctx, config, logger)
	require.NoError(t, err)
	defer storage.Close(ctx)

	factory := testutil.NewTestDataFactory()

	t.Run("concurrent_inserts", func(t *testing.T) {
		numOperations := 20
		done := make(chan error, numOperations)

		for i := 0; i < numOperations; i++ {
			go func(index int) {
				conversationID := factory.GenerateID()
				userID := factory.GenerateUserID()
				title := factory.GenerateRandomString(20)

				_, err := storage.Exec(ctx, `
					INSERT INTO assistant.conversations (id, user_id, title) 
					VALUES ($1, $2, $3)
				`, conversationID, userID, title)
				done <- err
			}(i)
		}

		// Wait for all operations to complete
		for i := 0; i < numOperations; i++ {
			select {
			case err := <-done:
				assert.NoError(t, err, "Concurrent insert should succeed")
			case <-time.After(10 * time.Second):
				t.Error("Timeout waiting for concurrent operations")
				return
			}
		}
	})

	t.Run("concurrent_reads", func(t *testing.T) {
		// First insert a conversation to read
		conversationID := factory.GenerateID()
		userID := factory.GenerateUserID()
		title := "Concurrent Read Test"

		_, err := storage.Exec(ctx, `
			INSERT INTO assistant.conversations (id, user_id, title) 
			VALUES ($1, $2, $3)
		`, conversationID, userID, title)
		require.NoError(t, err)

		numReads := 20
		done := make(chan error, numReads)

		for i := 0; i < numReads; i++ {
			go func() {
				var retrievedTitle string
				err := storage.QueryRow(ctx, `
					SELECT title FROM assistant.conversations WHERE id = $1
				`, conversationID).Scan(&retrievedTitle)

				if err == nil && retrievedTitle != title {
					err = assert.AnError // Title mismatch
				}
				done <- err
			}()
		}

		// Wait for all reads to complete
		for i := 0; i < numReads; i++ {
			select {
			case err := <-done:
				assert.NoError(t, err, "Concurrent read should succeed")
			case <-time.After(10 * time.Second):
				t.Error("Timeout waiting for concurrent reads")
				return
			}
		}
	})
}

func TestStorage_ErrorHandling(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping storage test in short mode")
	}

	// Setup test database
	dbContainer, cleanup := testutil.SetupTestDatabase(t)
	defer cleanup()

	ctx := context.Background()
	logger := testutil.CreateTestLogger(slog.LevelDebug)

	config := config.DatabaseConfig{
		URL:             dbContainer.URL,
		MaxConnections:  5,
		ConnMaxLifetime: time.Hour,
	}

	storage, err := NewStorage(ctx, config, logger)
	require.NoError(t, err)
	defer storage.Close(ctx)

	t.Run("invalid_sql", func(t *testing.T) {
		_, err := storage.Exec(ctx, "INVALID SQL STATEMENT")
		assert.Error(t, err, "Should return error for invalid SQL")
	})

	t.Run("constraint_violation", func(t *testing.T) {
		factory := testutil.NewTestDataFactory()
		conversationID := factory.GenerateID()
		userID := factory.GenerateUserID()

		// Insert conversation
		_, err := storage.Exec(ctx, `
			INSERT INTO assistant.conversations (id, user_id, title) 
			VALUES ($1, $2, $3)
		`, conversationID, userID, "Test")
		assert.NoError(t, err, "Should insert conversation")

		// Try to insert duplicate
		_, err = storage.Exec(ctx, `
			INSERT INTO assistant.conversations (id, user_id, title) 
			VALUES ($1, $2, $3)
		`, conversationID, userID, "Duplicate")
		assert.Error(t, err, "Should return error for duplicate key")
	})

	t.Run("context_cancellation", func(t *testing.T) {
		// Create context that's already cancelled
		cancelledCtx, cancel := context.WithCancel(ctx)
		cancel()

		_, err := storage.Exec(cancelledCtx, "SELECT 1")
		assert.Error(t, err, "Should return error for cancelled context")
	})

	t.Run("context_timeout", func(t *testing.T) {
		// Create context with very short timeout
		timeoutCtx, cancel := context.WithTimeout(ctx, 1*time.Nanosecond)
		defer cancel()

		// Wait a bit to ensure timeout
		time.Sleep(1 * time.Millisecond)

		_, err := storage.Exec(timeoutCtx, "SELECT 1")
		assert.Error(t, err, "Should return error for timeout")
	})
}
