// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: learning.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const AddSkillLearningPoint = `-- name: AddSkillLearningPoint :one
UPDATE user_skills
SET learning_curve = learning_curve || jsonb_build_object(
    'timestamp', EXTRACT(EPOCH FROM NOW()),
    'proficiency', $2,
    'context', $3
),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, skill_category, skill_name, proficiency_level, experience_points, successful_uses, total_uses, last_used, learning_curve, related_patterns, created_at, updated_at
`

type AddSkillLearningPointParams struct {
	ID                 pgtype.UUID `json:"id"`
	JsonbBuildObject   interface{} `json:"jsonb_build_object"`
	JsonbBuildObject_2 interface{} `json:"jsonb_build_object_2"`
}

func (q *Queries) AddSkillLearningPoint(ctx context.Context, arg AddSkillLearningPointParams) (*UserSkill, error) {
	row := q.db.QueryRow(ctx, AddSkillLearningPoint, arg.ID, arg.JsonbBuildObject, arg.JsonbBuildObject_2)
	var i UserSkill
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillCategory,
		&i.SkillName,
		&i.ProficiencyLevel,
		&i.ExperiencePoints,
		&i.SuccessfulUses,
		&i.TotalUses,
		&i.LastUsed,
		&i.LearningCurve,
		&i.RelatedPatterns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateLearnedPattern = `-- name: CreateLearnedPattern :one

INSERT INTO learned_patterns (
    user_id,
    pattern_type,
    pattern_name,
    pattern_signature,
    pattern_data,
    confidence,
    occurrence_count
) VALUES (
    $1::uuid, $2, $3, $4, $5, $6, $7
) ON CONFLICT (user_id, pattern_type, pattern_signature)
DO UPDATE SET
    occurrence_count = learned_patterns.occurrence_count + 1,
    confidence = ($6 + learned_patterns.confidence) / 2,
    pattern_data = $5,
    last_observed = NOW(),
    updated_at = NOW()
RETURNING id, user_id, pattern_type, pattern_name, pattern_signature, pattern_data, confidence, occurrence_count, positive_outcomes, negative_outcomes, last_observed, is_active, created_at, updated_at
`

type CreateLearnedPatternParams struct {
	Column1          pgtype.UUID `json:"column_1"`
	PatternType      string      `json:"pattern_type"`
	PatternName      string      `json:"pattern_name"`
	PatternSignature []byte      `json:"pattern_signature"`
	PatternData      []byte      `json:"pattern_data"`
	Confidence       float64     `json:"confidence"`
	OccurrenceCount  pgtype.Int4 `json:"occurrence_count"`
}

// =====================================================
// LEARNED PATTERNS QUERIES
// =====================================================
func (q *Queries) CreateLearnedPattern(ctx context.Context, arg CreateLearnedPatternParams) (*LearnedPattern, error) {
	row := q.db.QueryRow(ctx, CreateLearnedPattern,
		arg.Column1,
		arg.PatternType,
		arg.PatternName,
		arg.PatternSignature,
		arg.PatternData,
		arg.Confidence,
		arg.OccurrenceCount,
	)
	var i LearnedPattern
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PatternType,
		&i.PatternName,
		&i.PatternSignature,
		&i.PatternData,
		&i.Confidence,
		&i.OccurrenceCount,
		&i.PositiveOutcomes,
		&i.NegativeOutcomes,
		&i.LastObserved,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateLearningEvent = `-- name: CreateLearningEvent :one


INSERT INTO learning_events (
    user_id,
    event_type,
    context,
    input_data,
    output_data,
    outcome,
    confidence,
    feedback_score,
    learning_metadata,
    duration_ms,
    session_id,
    correlation_id
) VALUES (
    $1::uuid, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, user_id, event_type, context, input_data, output_data, outcome, confidence, feedback_score, learning_metadata, duration_ms, created_at, session_id, correlation_id
`

type CreateLearningEventParams struct {
	Column1          pgtype.UUID   `json:"column_1"`
	EventType        string        `json:"event_type"`
	Context          []byte        `json:"context"`
	InputData        []byte        `json:"input_data"`
	OutputData       []byte        `json:"output_data"`
	Outcome          pgtype.Text   `json:"outcome"`
	Confidence       pgtype.Float8 `json:"confidence"`
	FeedbackScore    pgtype.Int4   `json:"feedback_score"`
	LearningMetadata []byte        `json:"learning_metadata"`
	DurationMs       pgtype.Int4   `json:"duration_ms"`
	SessionID        pgtype.Text   `json:"session_id"`
	CorrelationID    pgtype.UUID   `json:"correlation_id"`
}

// Learning system queries
// =====================================================
// LEARNING EVENTS QUERIES
// =====================================================
func (q *Queries) CreateLearningEvent(ctx context.Context, arg CreateLearningEventParams) (*LearningEvent, error) {
	row := q.db.QueryRow(ctx, CreateLearningEvent,
		arg.Column1,
		arg.EventType,
		arg.Context,
		arg.InputData,
		arg.OutputData,
		arg.Outcome,
		arg.Confidence,
		arg.FeedbackScore,
		arg.LearningMetadata,
		arg.DurationMs,
		arg.SessionID,
		arg.CorrelationID,
	)
	var i LearningEvent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventType,
		&i.Context,
		&i.InputData,
		&i.OutputData,
		&i.Outcome,
		&i.Confidence,
		&i.FeedbackScore,
		&i.LearningMetadata,
		&i.DurationMs,
		&i.CreatedAt,
		&i.SessionID,
		&i.CorrelationID,
	)
	return &i, err
}

const CreateUserSkill = `-- name: CreateUserSkill :one

INSERT INTO user_skills (
    user_id,
    skill_category,
    skill_name,
    proficiency_level,
    experience_points
) VALUES (
    $1::uuid, $2, $3, $4, $5
) ON CONFLICT (user_id, skill_category, skill_name)
DO UPDATE SET
    proficiency_level = $4,
    experience_points = user_skills.experience_points + $5,
    updated_at = NOW()
RETURNING id, user_id, skill_category, skill_name, proficiency_level, experience_points, successful_uses, total_uses, last_used, learning_curve, related_patterns, created_at, updated_at
`

type CreateUserSkillParams struct {
	Column1          pgtype.UUID `json:"column_1"`
	SkillCategory    string      `json:"skill_category"`
	SkillName        string      `json:"skill_name"`
	ProficiencyLevel float64     `json:"proficiency_level"`
	ExperiencePoints pgtype.Int4 `json:"experience_points"`
}

// =====================================================
// USER SKILLS QUERIES
// =====================================================
func (q *Queries) CreateUserSkill(ctx context.Context, arg CreateUserSkillParams) (*UserSkill, error) {
	row := q.db.QueryRow(ctx, CreateUserSkill,
		arg.Column1,
		arg.SkillCategory,
		arg.SkillName,
		arg.ProficiencyLevel,
		arg.ExperiencePoints,
	)
	var i UserSkill
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillCategory,
		&i.SkillName,
		&i.ProficiencyLevel,
		&i.ExperiencePoints,
		&i.SuccessfulUses,
		&i.TotalUses,
		&i.LastUsed,
		&i.LearningCurve,
		&i.RelatedPatterns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeactivatePattern = `-- name: DeactivatePattern :exec
UPDATE learned_patterns
SET is_active = false,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivatePattern(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeactivatePattern, id)
	return err
}

const DeleteOldLearningEvents = `-- name: DeleteOldLearningEvents :exec
DELETE FROM learning_events
WHERE user_id = $1::uuid
  AND created_at < $2
`

type DeleteOldLearningEventsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
}

func (q *Queries) DeleteOldLearningEvents(ctx context.Context, arg DeleteOldLearningEventsParams) error {
	_, err := q.db.Exec(ctx, DeleteOldLearningEvents, arg.Column1, arg.CreatedAt)
	return err
}

const GetLearnedPattern = `-- name: GetLearnedPattern :one
SELECT id, user_id, pattern_type, pattern_name, pattern_signature, pattern_data, confidence, occurrence_count, positive_outcomes, negative_outcomes, last_observed, is_active, created_at, updated_at FROM learned_patterns
WHERE user_id = $1::uuid 
  AND pattern_type = $2 
  AND pattern_signature = $3
`

type GetLearnedPatternParams struct {
	Column1          pgtype.UUID `json:"column_1"`
	PatternType      string      `json:"pattern_type"`
	PatternSignature []byte      `json:"pattern_signature"`
}

func (q *Queries) GetLearnedPattern(ctx context.Context, arg GetLearnedPatternParams) (*LearnedPattern, error) {
	row := q.db.QueryRow(ctx, GetLearnedPattern, arg.Column1, arg.PatternType, arg.PatternSignature)
	var i LearnedPattern
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PatternType,
		&i.PatternName,
		&i.PatternSignature,
		&i.PatternData,
		&i.Confidence,
		&i.OccurrenceCount,
		&i.PositiveOutcomes,
		&i.NegativeOutcomes,
		&i.LastObserved,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetLearnedPatterns = `-- name: GetLearnedPatterns :many
SELECT id, user_id, pattern_type, pattern_name, pattern_signature, pattern_data, confidence, occurrence_count, positive_outcomes, negative_outcomes, last_observed, is_active, created_at, updated_at FROM learned_patterns
WHERE user_id = $1::uuid
  AND (pattern_type = ANY($2::text[]) OR $2 IS NULL)
  AND is_active = true
  AND confidence >= COALESCE($3, 0.0)
ORDER BY confidence DESC, last_observed DESC
LIMIT $4 OFFSET $5
`

type GetLearnedPatternsParams struct {
	Column1    pgtype.UUID `json:"column_1"`
	Column2    []string    `json:"column_2"`
	Confidence float64     `json:"confidence"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) GetLearnedPatterns(ctx context.Context, arg GetLearnedPatternsParams) ([]*LearnedPattern, error) {
	rows, err := q.db.Query(ctx, GetLearnedPatterns,
		arg.Column1,
		arg.Column2,
		arg.Confidence,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LearnedPattern{}
	for rows.Next() {
		var i LearnedPattern
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PatternType,
			&i.PatternName,
			&i.PatternSignature,
			&i.PatternData,
			&i.Confidence,
			&i.OccurrenceCount,
			&i.PositiveOutcomes,
			&i.NegativeOutcomes,
			&i.LastObserved,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLearningEventStats = `-- name: GetLearningEventStats :one
SELECT
    event_type,
    COUNT(*) as event_count,
    AVG(confidence) as avg_confidence,
    AVG(duration_ms) as avg_duration_ms,
    COUNT(*) FILTER (WHERE outcome = 'success') as success_count,
    COUNT(*) FILTER (WHERE outcome = 'failure') as failure_count
FROM learning_events
WHERE user_id = $1::uuid
  AND created_at >= COALESCE($2, NOW() - INTERVAL '7 days')
GROUP BY event_type
`

type GetLearningEventStatsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
}

type GetLearningEventStatsRow struct {
	EventType     string  `json:"event_type"`
	EventCount    int64   `json:"event_count"`
	AvgConfidence float64 `json:"avg_confidence"`
	AvgDurationMs float64 `json:"avg_duration_ms"`
	SuccessCount  int64   `json:"success_count"`
	FailureCount  int64   `json:"failure_count"`
}

func (q *Queries) GetLearningEventStats(ctx context.Context, arg GetLearningEventStatsParams) (*GetLearningEventStatsRow, error) {
	row := q.db.QueryRow(ctx, GetLearningEventStats, arg.Column1, arg.CreatedAt)
	var i GetLearningEventStatsRow
	err := row.Scan(
		&i.EventType,
		&i.EventCount,
		&i.AvgConfidence,
		&i.AvgDurationMs,
		&i.SuccessCount,
		&i.FailureCount,
	)
	return &i, err
}

const GetLearningEvents = `-- name: GetLearningEvents :many
SELECT id, user_id, event_type, context, input_data, output_data, outcome, confidence, feedback_score, learning_metadata, duration_ms, created_at, session_id, correlation_id FROM learning_events
WHERE user_id = $1::uuid
  AND (event_type = ANY($2::text[]) OR $2 IS NULL)
  AND (session_id = $3 OR $3 IS NULL)
  AND created_at >= COALESCE($4, NOW() - INTERVAL '30 days')
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type GetLearningEventsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	Column2   []string    `json:"column_2"`
	SessionID pgtype.Text `json:"session_id"`
	CreatedAt time.Time   `json:"created_at"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetLearningEvents(ctx context.Context, arg GetLearningEventsParams) ([]*LearningEvent, error) {
	rows, err := q.db.Query(ctx, GetLearningEvents,
		arg.Column1,
		arg.Column2,
		arg.SessionID,
		arg.CreatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LearningEvent{}
	for rows.Next() {
		var i LearningEvent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EventType,
			&i.Context,
			&i.InputData,
			&i.OutputData,
			&i.Outcome,
			&i.Confidence,
			&i.FeedbackScore,
			&i.LearningMetadata,
			&i.DurationMs,
			&i.CreatedAt,
			&i.SessionID,
			&i.CorrelationID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLearningEventsByCorrelation = `-- name: GetLearningEventsByCorrelation :many
SELECT id, user_id, event_type, context, input_data, output_data, outcome, confidence, feedback_score, learning_metadata, duration_ms, created_at, session_id, correlation_id FROM learning_events
WHERE correlation_id = $1::uuid
ORDER BY created_at ASC
`

func (q *Queries) GetLearningEventsByCorrelation(ctx context.Context, dollar_1 pgtype.UUID) ([]*LearningEvent, error) {
	rows, err := q.db.Query(ctx, GetLearningEventsByCorrelation, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LearningEvent{}
	for rows.Next() {
		var i LearningEvent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EventType,
			&i.Context,
			&i.InputData,
			&i.OutputData,
			&i.Outcome,
			&i.Confidence,
			&i.FeedbackScore,
			&i.LearningMetadata,
			&i.DurationMs,
			&i.CreatedAt,
			&i.SessionID,
			&i.CorrelationID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSkillProgression = `-- name: GetSkillProgression :one
SELECT 
    skill_name,
    proficiency_level,
    experience_points,
    successful_uses,
    total_uses,
    CASE 
        WHEN total_uses > 0 THEN successful_uses::float / total_uses 
        ELSE 0 
    END as success_rate,
    learning_curve
FROM user_skills
WHERE user_id = $1::uuid 
  AND skill_category = $2 
  AND skill_name = $3
`

type GetSkillProgressionParams struct {
	Column1       pgtype.UUID `json:"column_1"`
	SkillCategory string      `json:"skill_category"`
	SkillName     string      `json:"skill_name"`
}

type GetSkillProgressionRow struct {
	SkillName        string      `json:"skill_name"`
	ProficiencyLevel float64     `json:"proficiency_level"`
	ExperiencePoints pgtype.Int4 `json:"experience_points"`
	SuccessfulUses   pgtype.Int4 `json:"successful_uses"`
	TotalUses        pgtype.Int4 `json:"total_uses"`
	SuccessRate      int32       `json:"success_rate"`
	LearningCurve    []byte      `json:"learning_curve"`
}

func (q *Queries) GetSkillProgression(ctx context.Context, arg GetSkillProgressionParams) (*GetSkillProgressionRow, error) {
	row := q.db.QueryRow(ctx, GetSkillProgression, arg.Column1, arg.SkillCategory, arg.SkillName)
	var i GetSkillProgressionRow
	err := row.Scan(
		&i.SkillName,
		&i.ProficiencyLevel,
		&i.ExperiencePoints,
		&i.SuccessfulUses,
		&i.TotalUses,
		&i.SuccessRate,
		&i.LearningCurve,
	)
	return &i, err
}

const GetSkillsByProficiency = `-- name: GetSkillsByProficiency :many
SELECT id, user_id, skill_category, skill_name, proficiency_level, experience_points, successful_uses, total_uses, last_used, learning_curve, related_patterns, created_at, updated_at FROM user_skills
WHERE user_id = $1::uuid
  AND proficiency_level >= $2
  AND proficiency_level <= $3
ORDER BY skill_category, skill_name
`

type GetSkillsByProficiencyParams struct {
	Column1            pgtype.UUID `json:"column_1"`
	ProficiencyLevel   float64     `json:"proficiency_level"`
	ProficiencyLevel_2 float64     `json:"proficiency_level_2"`
}

func (q *Queries) GetSkillsByProficiency(ctx context.Context, arg GetSkillsByProficiencyParams) ([]*UserSkill, error) {
	rows, err := q.db.Query(ctx, GetSkillsByProficiency, arg.Column1, arg.ProficiencyLevel, arg.ProficiencyLevel_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserSkill{}
	for rows.Next() {
		var i UserSkill
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SkillCategory,
			&i.SkillName,
			&i.ProficiencyLevel,
			&i.ExperiencePoints,
			&i.SuccessfulUses,
			&i.TotalUses,
			&i.LastUsed,
			&i.LearningCurve,
			&i.RelatedPatterns,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTopSkills = `-- name: GetTopSkills :many
SELECT 
    skill_category,
    skill_name,
    proficiency_level,
    experience_points,
    last_used
FROM user_skills
WHERE user_id = $1::uuid
ORDER BY proficiency_level DESC, experience_points DESC
LIMIT $2
`

type GetTopSkillsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type GetTopSkillsRow struct {
	SkillCategory    string             `json:"skill_category"`
	SkillName        string             `json:"skill_name"`
	ProficiencyLevel float64            `json:"proficiency_level"`
	ExperiencePoints pgtype.Int4        `json:"experience_points"`
	LastUsed         pgtype.Timestamptz `json:"last_used"`
}

func (q *Queries) GetTopSkills(ctx context.Context, arg GetTopSkillsParams) ([]*GetTopSkillsRow, error) {
	rows, err := q.db.Query(ctx, GetTopSkills, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTopSkillsRow{}
	for rows.Next() {
		var i GetTopSkillsRow
		if err := rows.Scan(
			&i.SkillCategory,
			&i.SkillName,
			&i.ProficiencyLevel,
			&i.ExperiencePoints,
			&i.LastUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserSkill = `-- name: GetUserSkill :one
SELECT id, user_id, skill_category, skill_name, proficiency_level, experience_points, successful_uses, total_uses, last_used, learning_curve, related_patterns, created_at, updated_at FROM user_skills
WHERE user_id = $1::uuid 
  AND skill_category = $2 
  AND skill_name = $3
`

type GetUserSkillParams struct {
	Column1       pgtype.UUID `json:"column_1"`
	SkillCategory string      `json:"skill_category"`
	SkillName     string      `json:"skill_name"`
}

func (q *Queries) GetUserSkill(ctx context.Context, arg GetUserSkillParams) (*UserSkill, error) {
	row := q.db.QueryRow(ctx, GetUserSkill, arg.Column1, arg.SkillCategory, arg.SkillName)
	var i UserSkill
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillCategory,
		&i.SkillName,
		&i.ProficiencyLevel,
		&i.ExperiencePoints,
		&i.SuccessfulUses,
		&i.TotalUses,
		&i.LastUsed,
		&i.LearningCurve,
		&i.RelatedPatterns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetUserSkills = `-- name: GetUserSkills :many
SELECT id, user_id, skill_category, skill_name, proficiency_level, experience_points, successful_uses, total_uses, last_used, learning_curve, related_patterns, created_at, updated_at FROM user_skills
WHERE user_id = $1::uuid
  AND (skill_category = $2 OR $2 IS NULL)
ORDER BY proficiency_level DESC, experience_points DESC
LIMIT $3 OFFSET $4
`

type GetUserSkillsParams struct {
	Column1       pgtype.UUID `json:"column_1"`
	SkillCategory string      `json:"skill_category"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

func (q *Queries) GetUserSkills(ctx context.Context, arg GetUserSkillsParams) ([]*UserSkill, error) {
	rows, err := q.db.Query(ctx, GetUserSkills,
		arg.Column1,
		arg.SkillCategory,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UserSkill{}
	for rows.Next() {
		var i UserSkill
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SkillCategory,
			&i.SkillName,
			&i.ProficiencyLevel,
			&i.ExperiencePoints,
			&i.SuccessfulUses,
			&i.TotalUses,
			&i.LastUsed,
			&i.LearningCurve,
			&i.RelatedPatterns,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchPatternsByData = `-- name: SearchPatternsByData :many
SELECT id, user_id, pattern_type, pattern_name, pattern_signature, pattern_data, confidence, occurrence_count, positive_outcomes, negative_outcomes, last_observed, is_active, created_at, updated_at FROM learned_patterns
WHERE user_id = $1::uuid
  AND pattern_data @> $2
  AND is_active = true
ORDER BY confidence DESC
LIMIT $3
`

type SearchPatternsByDataParams struct {
	Column1     pgtype.UUID `json:"column_1"`
	PatternData []byte      `json:"pattern_data"`
	Limit       int32       `json:"limit"`
}

func (q *Queries) SearchPatternsByData(ctx context.Context, arg SearchPatternsByDataParams) ([]*LearnedPattern, error) {
	rows, err := q.db.Query(ctx, SearchPatternsByData, arg.Column1, arg.PatternData, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*LearnedPattern{}
	for rows.Next() {
		var i LearnedPattern
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PatternType,
			&i.PatternName,
			&i.PatternSignature,
			&i.PatternData,
			&i.Confidence,
			&i.OccurrenceCount,
			&i.PositiveOutcomes,
			&i.NegativeOutcomes,
			&i.LastObserved,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateLearningEventFeedback = `-- name: UpdateLearningEventFeedback :one
UPDATE learning_events
SET feedback_score = $2,
    learning_metadata = learning_metadata || $3
WHERE id = $1
RETURNING id, user_id, event_type, context, input_data, output_data, outcome, confidence, feedback_score, learning_metadata, duration_ms, created_at, session_id, correlation_id
`

type UpdateLearningEventFeedbackParams struct {
	ID               pgtype.UUID `json:"id"`
	FeedbackScore    pgtype.Int4 `json:"feedback_score"`
	LearningMetadata []byte      `json:"learning_metadata"`
}

func (q *Queries) UpdateLearningEventFeedback(ctx context.Context, arg UpdateLearningEventFeedbackParams) (*LearningEvent, error) {
	row := q.db.QueryRow(ctx, UpdateLearningEventFeedback, arg.ID, arg.FeedbackScore, arg.LearningMetadata)
	var i LearningEvent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventType,
		&i.Context,
		&i.InputData,
		&i.OutputData,
		&i.Outcome,
		&i.Confidence,
		&i.FeedbackScore,
		&i.LearningMetadata,
		&i.DurationMs,
		&i.CreatedAt,
		&i.SessionID,
		&i.CorrelationID,
	)
	return &i, err
}

const UpdatePatternOutcome = `-- name: UpdatePatternOutcome :one
UPDATE learned_patterns
SET positive_outcomes = positive_outcomes + $2,
    negative_outcomes = negative_outcomes + $3,
    confidence = CASE 
        WHEN ($2 + $3) > 0 THEN 
            LEAST(1.0, positive_outcomes::float / (positive_outcomes + negative_outcomes + $2 + $3))
        ELSE confidence
    END,
    last_observed = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, pattern_type, pattern_name, pattern_signature, pattern_data, confidence, occurrence_count, positive_outcomes, negative_outcomes, last_observed, is_active, created_at, updated_at
`

type UpdatePatternOutcomeParams struct {
	ID               pgtype.UUID `json:"id"`
	PositiveOutcomes pgtype.Int4 `json:"positive_outcomes"`
	NegativeOutcomes pgtype.Int4 `json:"negative_outcomes"`
}

func (q *Queries) UpdatePatternOutcome(ctx context.Context, arg UpdatePatternOutcomeParams) (*LearnedPattern, error) {
	row := q.db.QueryRow(ctx, UpdatePatternOutcome, arg.ID, arg.PositiveOutcomes, arg.NegativeOutcomes)
	var i LearnedPattern
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PatternType,
		&i.PatternName,
		&i.PatternSignature,
		&i.PatternData,
		&i.Confidence,
		&i.OccurrenceCount,
		&i.PositiveOutcomes,
		&i.NegativeOutcomes,
		&i.LastObserved,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSkillRelatedPatterns = `-- name: UpdateSkillRelatedPatterns :one
UPDATE user_skills
SET related_patterns = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, skill_category, skill_name, proficiency_level, experience_points, successful_uses, total_uses, last_used, learning_curve, related_patterns, created_at, updated_at
`

type UpdateSkillRelatedPatternsParams struct {
	ID              pgtype.UUID   `json:"id"`
	RelatedPatterns []pgtype.UUID `json:"related_patterns"`
}

func (q *Queries) UpdateSkillRelatedPatterns(ctx context.Context, arg UpdateSkillRelatedPatternsParams) (*UserSkill, error) {
	row := q.db.QueryRow(ctx, UpdateSkillRelatedPatterns, arg.ID, arg.RelatedPatterns)
	var i UserSkill
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillCategory,
		&i.SkillName,
		&i.ProficiencyLevel,
		&i.ExperiencePoints,
		&i.SuccessfulUses,
		&i.TotalUses,
		&i.LastUsed,
		&i.LearningCurve,
		&i.RelatedPatterns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSkillUsage = `-- name: UpdateSkillUsage :one
UPDATE user_skills
SET successful_uses = successful_uses + $2,
    total_uses = total_uses + $3,
    last_used = NOW(),
    proficiency_level = LEAST(1.0, proficiency_level + ($2::float / GREATEST(total_uses + $3, 1)) * 0.1),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, skill_category, skill_name, proficiency_level, experience_points, successful_uses, total_uses, last_used, learning_curve, related_patterns, created_at, updated_at
`

type UpdateSkillUsageParams struct {
	ID             pgtype.UUID `json:"id"`
	SuccessfulUses pgtype.Int4 `json:"successful_uses"`
	TotalUses      pgtype.Int4 `json:"total_uses"`
}

func (q *Queries) UpdateSkillUsage(ctx context.Context, arg UpdateSkillUsageParams) (*UserSkill, error) {
	row := q.db.QueryRow(ctx, UpdateSkillUsage, arg.ID, arg.SuccessfulUses, arg.TotalUses)
	var i UserSkill
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SkillCategory,
		&i.SkillName,
		&i.ProficiencyLevel,
		&i.ExperiencePoints,
		&i.SuccessfulUses,
		&i.TotalUses,
		&i.LastUsed,
		&i.LearningCurve,
		&i.RelatedPatterns,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
