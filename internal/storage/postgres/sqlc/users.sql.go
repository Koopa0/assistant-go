// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const AddFavoriteTool = `-- name: AddFavoriteTool :one
UPDATE users SET
    preferences = jsonb_set(
        preferences, 
        '{favoriteTools}', 
        COALESCE(preferences->'favoriteTools', '[]'::jsonb) || $2::jsonb,
        true
    ),
    updated_at = NOW()
WHERE id = $1 AND is_active = true
RETURNING id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at
`

type AddFavoriteToolParams struct {
	ID      pgtype.UUID `json:"id"`
	Column2 []byte      `json:"column_2"`
}

func (q *Queries) AddFavoriteTool(ctx context.Context, arg AddFavoriteToolParams) (*User, error) {
	row := q.db.QueryRow(ctx, AddFavoriteTool, arg.ID, arg.Column2)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CountActiveUsers = `-- name: CountActiveUsers :one
SELECT COUNT(*) FROM users WHERE is_active = true
`

func (q *Queries) CountActiveUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountActiveUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateUser = `-- name: CreateUser :one
INSERT INTO users (
    username, email, password_hash, full_name, avatar_url, preferences
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at
`

type CreateUserParams struct {
	Username     string      `json:"username"`
	Email        string      `json:"email"`
	PasswordHash string      `json:"password_hash"`
	FullName     pgtype.Text `json:"full_name"`
	AvatarUrl    pgtype.Text `json:"avatar_url"`
	Preferences  []byte      `json:"preferences"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, CreateUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.FullName,
		arg.AvatarUrl,
		arg.Preferences,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeactivateUser = `-- name: DeactivateUser :one
UPDATE users SET
    is_active = false,
    updated_at = NOW()
WHERE id = $1
RETURNING id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at
`

func (q *Queries) DeactivateUser(ctx context.Context, id pgtype.UUID) (*User, error) {
	row := q.db.QueryRow(ctx, DeactivateUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetActiveUsers = `-- name: GetActiveUsers :many
SELECT id, username, email, full_name, avatar_url, created_at, updated_at
FROM users 
WHERE is_active = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetActiveUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetActiveUsersRow struct {
	ID        pgtype.UUID `json:"id"`
	Username  string      `json:"username"`
	Email     string      `json:"email"`
	FullName  pgtype.Text `json:"full_name"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) GetActiveUsers(ctx context.Context, arg GetActiveUsersParams) ([]*GetActiveUsersRow, error) {
	rows, err := q.db.Query(ctx, GetActiveUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveUsersRow{}
	for rows.Next() {
		var i GetActiveUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserActivitySummary = `-- name: GetUserActivitySummary :one
SELECT 
    u.id,
    COUNT(DISTINCT c.id)::integer as conversations_count,
    COUNT(DISTINCT m.id)::integer as messages_count,
    COUNT(DISTINCT te.id)::integer as tool_executions_count,
    MAX(m.created_at) as last_activity_at,
    EXTRACT(EPOCH FROM (NOW() - u.created_at))::integer as days_since_signup
FROM users u
LEFT JOIN conversations c ON u.id = c.user_id
LEFT JOIN messages m ON c.id = m.conversation_id
LEFT JOIN tool_executions te ON m.id = te.message_id
WHERE u.id = $1 AND u.is_active = true
GROUP BY u.id, u.created_at
`

type GetUserActivitySummaryRow struct {
	ID                  pgtype.UUID `json:"id"`
	ConversationsCount  int32       `json:"conversations_count"`
	MessagesCount       int32       `json:"messages_count"`
	ToolExecutionsCount int32       `json:"tool_executions_count"`
	LastActivityAt      interface{} `json:"last_activity_at"`
	DaysSinceSignup     int32       `json:"days_since_signup"`
}

func (q *Queries) GetUserActivitySummary(ctx context.Context, id pgtype.UUID) (*GetUserActivitySummaryRow, error) {
	row := q.db.QueryRow(ctx, GetUserActivitySummary, id)
	var i GetUserActivitySummaryRow
	err := row.Scan(
		&i.ID,
		&i.ConversationsCount,
		&i.MessagesCount,
		&i.ToolExecutionsCount,
		&i.LastActivityAt,
		&i.DaysSinceSignup,
	)
	return &i, err
}

const GetUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at FROM users WHERE email = $1 AND is_active = true
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at FROM users WHERE id = $1 AND is_active = true
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at FROM users WHERE username = $1 AND is_active = true
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetUserFavoriteTools = `-- name: GetUserFavoriteTools :many
SELECT 
    (preferences->'favoriteTools')::jsonb as favorite_tools
FROM users 
WHERE id = $1 AND is_active = true
`

// User favorite tools
func (q *Queries) GetUserFavoriteTools(ctx context.Context, id pgtype.UUID) ([][]byte, error) {
	rows, err := q.db.Query(ctx, GetUserFavoriteTools, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := [][]byte{}
	for rows.Next() {
		var favorite_tools []byte
		if err := rows.Scan(&favorite_tools); err != nil {
			return nil, err
		}
		items = append(items, favorite_tools)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserSettings = `-- name: GetUserSettings :one

SELECT 
    id,
    preferences,
    (preferences->>'language')::text as language,
    (preferences->>'theme')::text as theme,
    (preferences->>'defaultProgrammingLanguage')::text as default_programming_language,
    (preferences->>'emailNotifications')::boolean as email_notifications,
    (preferences->>'timezone')::text as timezone
FROM users 
WHERE id = $1 AND is_active = true
`

type GetUserSettingsRow struct {
	ID                         pgtype.UUID `json:"id"`
	Preferences                []byte      `json:"preferences"`
	Language                   string      `json:"language"`
	Theme                      string      `json:"theme"`
	DefaultProgrammingLanguage string      `json:"default_programming_language"`
	EmailNotifications         bool        `json:"email_notifications"`
	Timezone                   string      `json:"timezone"`
}

// User API Keys related queries (to be implemented after migration)
// User preferences and settings
func (q *Queries) GetUserSettings(ctx context.Context, id pgtype.UUID) (*GetUserSettingsRow, error) {
	row := q.db.QueryRow(ctx, GetUserSettings, id)
	var i GetUserSettingsRow
	err := row.Scan(
		&i.ID,
		&i.Preferences,
		&i.Language,
		&i.Theme,
		&i.DefaultProgrammingLanguage,
		&i.EmailNotifications,
		&i.Timezone,
	)
	return &i, err
}

const GetUserStatistics = `-- name: GetUserStatistics :one
SELECT 
    u.id,
    u.username,
    u.email,
    u.full_name,
    u.created_at,
    COUNT(DISTINCT c.id)::integer as total_conversations,
    COUNT(DISTINCT te.id)::integer as total_tools_used,
    COALESCE(SUM(apu.input_tokens + apu.output_tokens), 0)::integer as total_tokens_used,
    COALESCE(SUM(apu.cost_cents), 0)::integer as total_cost_cents
FROM users u
LEFT JOIN conversations c ON u.id = c.user_id
LEFT JOIN tool_executions te ON te.message_id IN (
    SELECT m.id FROM messages m 
    JOIN conversations conv ON m.conversation_id = conv.id 
    WHERE conv.user_id = u.id
)
LEFT JOIN ai_provider_usage apu ON u.id = apu.user_id
WHERE u.id = $1 AND u.is_active = true
GROUP BY u.id, u.username, u.email, u.full_name, u.created_at
`

type GetUserStatisticsRow struct {
	ID                 pgtype.UUID `json:"id"`
	Username           string      `json:"username"`
	Email              string      `json:"email"`
	FullName           pgtype.Text `json:"full_name"`
	CreatedAt          time.Time   `json:"created_at"`
	TotalConversations int32       `json:"total_conversations"`
	TotalToolsUsed     int32       `json:"total_tools_used"`
	TotalTokensUsed    int32       `json:"total_tokens_used"`
	TotalCostCents     int32       `json:"total_cost_cents"`
}

func (q *Queries) GetUserStatistics(ctx context.Context, id pgtype.UUID) (*GetUserStatisticsRow, error) {
	row := q.db.QueryRow(ctx, GetUserStatistics, id)
	var i GetUserStatisticsRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.CreatedAt,
		&i.TotalConversations,
		&i.TotalToolsUsed,
		&i.TotalTokensUsed,
		&i.TotalCostCents,
	)
	return &i, err
}

const RemoveFavoriteTool = `-- name: RemoveFavoriteTool :one
UPDATE users SET
    preferences = jsonb_set(
        preferences,
        '{favoriteTools}',
        (preferences->'favoriteTools') - $2::text,
        true
    ),
    updated_at = NOW()
WHERE id = $1 AND is_active = true
RETURNING id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at
`

type RemoveFavoriteToolParams struct {
	ID      pgtype.UUID `json:"id"`
	Column2 string      `json:"column_2"`
}

func (q *Queries) RemoveFavoriteTool(ctx context.Context, arg RemoveFavoriteToolParams) (*User, error) {
	row := q.db.QueryRow(ctx, RemoveFavoriteTool, arg.ID, arg.Column2)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const SearchUsers = `-- name: SearchUsers :many
SELECT id, username, email, full_name, avatar_url, created_at, updated_at
FROM users 
WHERE is_active = true 
  AND (
    username ILIKE '%' || $1 || '%' OR 
    email ILIKE '%' || $1 || '%' OR 
    full_name ILIKE '%' || $1 || '%'
  )
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchUsersParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchUsersRow struct {
	ID        pgtype.UUID `json:"id"`
	Username  string      `json:"username"`
	Email     string      `json:"email"`
	FullName  pgtype.Text `json:"full_name"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]*SearchUsersRow, error) {
	rows, err := q.db.Query(ctx, SearchUsers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchUsersRow{}
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users SET
    password_hash = $2,
    updated_at = NOW()
WHERE id = $1 AND is_active = true
RETURNING id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at
`

type UpdateUserPasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash string      `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (*User, error) {
	row := q.db.QueryRow(ctx, UpdateUserPassword, arg.ID, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateUserPreferences = `-- name: UpdateUserPreferences :one
UPDATE users SET
    preferences = $2,
    updated_at = NOW()
WHERE id = $1 AND is_active = true
RETURNING id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at
`

type UpdateUserPreferencesParams struct {
	ID          pgtype.UUID `json:"id"`
	Preferences []byte      `json:"preferences"`
}

func (q *Queries) UpdateUserPreferences(ctx context.Context, arg UpdateUserPreferencesParams) (*User, error) {
	row := q.db.QueryRow(ctx, UpdateUserPreferences, arg.ID, arg.Preferences)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users SET
    full_name = COALESCE($2, full_name),
    avatar_url = COALESCE($3, avatar_url),
    updated_at = NOW()
WHERE id = $1 AND is_active = true
RETURNING id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at
`

type UpdateUserProfileParams struct {
	ID        pgtype.UUID `json:"id"`
	FullName  pgtype.Text `json:"full_name"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (*User, error) {
	row := q.db.QueryRow(ctx, UpdateUserProfile, arg.ID, arg.FullName, arg.AvatarUrl)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateUserSettings = `-- name: UpdateUserSettings :one
UPDATE users SET
    preferences = preferences || $2,
    updated_at = NOW()
WHERE id = $1 AND is_active = true
RETURNING id, username, email, password_hash, full_name, avatar_url, preferences, is_active, created_at, updated_at
`

type UpdateUserSettingsParams struct {
	ID          pgtype.UUID `json:"id"`
	Preferences []byte      `json:"preferences"`
}

func (q *Queries) UpdateUserSettings(ctx context.Context, arg UpdateUserSettingsParams) (*User, error) {
	row := q.db.QueryRow(ctx, UpdateUserSettings, arg.ID, arg.Preferences)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.AvatarUrl,
		&i.Preferences,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
