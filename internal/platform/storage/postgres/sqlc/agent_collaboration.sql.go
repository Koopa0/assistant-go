// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: agent_collaboration.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const CompleteCollaboration = `-- name: CompleteCollaboration :one
UPDATE agent_collaborations
SET outcome = $2,
    total_duration_ms = EXTRACT(EPOCH FROM (NOW() - created_at)) * 1000,
    completed_at = NOW()
WHERE id = $1
RETURNING id, user_id, session_id, lead_agent_id, participating_agents, collaboration_type, task_description, task_complexity, collaboration_plan, execution_trace, outcome, total_duration_ms, resource_usage, created_at, completed_at
`

type CompleteCollaborationParams struct {
	ID      pgtype.UUID `json:"id"`
	Outcome pgtype.Text `json:"outcome"`
}

func (q *Queries) CompleteCollaboration(ctx context.Context, arg CompleteCollaborationParams) (*AgentCollaboration, error) {
	row := q.db.QueryRow(ctx, CompleteCollaboration, arg.ID, arg.Outcome)
	var i AgentCollaboration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.LeadAgentID,
		&i.ParticipatingAgents,
		&i.CollaborationType,
		&i.TaskDescription,
		&i.TaskComplexity,
		&i.CollaborationPlan,
		&i.ExecutionTrace,
		&i.Outcome,
		&i.TotalDurationMs,
		&i.ResourceUsage,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const CreateAgentCollaboration = `-- name: CreateAgentCollaboration :one

INSERT INTO agent_collaborations (
    user_id,
    session_id,
    lead_agent_id,
    participating_agents,
    collaboration_type,
    task_description,
    task_complexity,
    collaboration_plan
) VALUES (
    $1::uuid, $2, $3::uuid, $4, $5, $6, $7, $8
) RETURNING id, user_id, session_id, lead_agent_id, participating_agents, collaboration_type, task_description, task_complexity, collaboration_plan, execution_trace, outcome, total_duration_ms, resource_usage, created_at, completed_at
`

type CreateAgentCollaborationParams struct {
	Column1             pgtype.UUID   `json:"column_1"`
	SessionID           string        `json:"session_id"`
	Column3             pgtype.UUID   `json:"column_3"`
	ParticipatingAgents []pgtype.UUID `json:"participating_agents"`
	CollaborationType   string        `json:"collaboration_type"`
	TaskDescription     string        `json:"task_description"`
	TaskComplexity      pgtype.Float8 `json:"task_complexity"`
	CollaborationPlan   []byte        `json:"collaboration_plan"`
}

// =====================================================
// AGENT COLLABORATIONS QUERIES
// =====================================================
func (q *Queries) CreateAgentCollaboration(ctx context.Context, arg CreateAgentCollaborationParams) (*AgentCollaboration, error) {
	row := q.db.QueryRow(ctx, CreateAgentCollaboration,
		arg.Column1,
		arg.SessionID,
		arg.Column3,
		arg.ParticipatingAgents,
		arg.CollaborationType,
		arg.TaskDescription,
		arg.TaskComplexity,
		arg.CollaborationPlan,
	)
	var i AgentCollaboration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.LeadAgentID,
		&i.ParticipatingAgents,
		&i.CollaborationType,
		&i.TaskDescription,
		&i.TaskComplexity,
		&i.CollaborationPlan,
		&i.ExecutionTrace,
		&i.Outcome,
		&i.TotalDurationMs,
		&i.ResourceUsage,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const CreateAgentDefinition = `-- name: CreateAgentDefinition :one


INSERT INTO agent_definitions (
    agent_name,
    agent_type,
    capabilities,
    expertise_domains,
    collaboration_preferences,
    performance_metrics
) VALUES (
    $1, $2, $3, $4, $5, $6
) ON CONFLICT (agent_name)
DO UPDATE SET
    agent_type = $2,
    capabilities = $3,
    expertise_domains = $4,
    collaboration_preferences = $5,
    performance_metrics = $6,
    updated_at = NOW()
RETURNING id, agent_name, agent_type, capabilities, expertise_domains, collaboration_preferences, performance_metrics, is_active, created_at, updated_at
`

type CreateAgentDefinitionParams struct {
	AgentName                string   `json:"agent_name"`
	AgentType                string   `json:"agent_type"`
	Capabilities             []byte   `json:"capabilities"`
	ExpertiseDomains         []string `json:"expertise_domains"`
	CollaborationPreferences []byte   `json:"collaboration_preferences"`
	PerformanceMetrics       []byte   `json:"performance_metrics"`
}

// Agent collaboration queries
// =====================================================
// AGENT DEFINITIONS QUERIES
// =====================================================
func (q *Queries) CreateAgentDefinition(ctx context.Context, arg CreateAgentDefinitionParams) (*AgentDefinition, error) {
	row := q.db.QueryRow(ctx, CreateAgentDefinition,
		arg.AgentName,
		arg.AgentType,
		arg.Capabilities,
		arg.ExpertiseDomains,
		arg.CollaborationPreferences,
		arg.PerformanceMetrics,
	)
	var i AgentDefinition
	err := row.Scan(
		&i.ID,
		&i.AgentName,
		&i.AgentType,
		&i.Capabilities,
		&i.ExpertiseDomains,
		&i.CollaborationPreferences,
		&i.PerformanceMetrics,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateKnowledgeShare = `-- name: CreateKnowledgeShare :one

INSERT INTO agent_knowledge_shares (
    source_agent_id,
    target_agent_id,
    knowledge_type,
    knowledge_content,
    relevance_score,
    collaboration_id
) VALUES (
    $1::uuid, $2::uuid, $3, $4, $5, $6::uuid
) RETURNING id, source_agent_id, target_agent_id, knowledge_type, knowledge_content, relevance_score, was_accepted, integration_result, collaboration_id, created_at
`

type CreateKnowledgeShareParams struct {
	Column1          pgtype.UUID   `json:"column_1"`
	Column2          pgtype.UUID   `json:"column_2"`
	KnowledgeType    string        `json:"knowledge_type"`
	KnowledgeContent []byte        `json:"knowledge_content"`
	RelevanceScore   pgtype.Float8 `json:"relevance_score"`
	Column6          pgtype.UUID   `json:"column_6"`
}

// =====================================================
// AGENT KNOWLEDGE SHARING QUERIES
// =====================================================
func (q *Queries) CreateKnowledgeShare(ctx context.Context, arg CreateKnowledgeShareParams) (*AgentKnowledgeShare, error) {
	row := q.db.QueryRow(ctx, CreateKnowledgeShare,
		arg.Column1,
		arg.Column2,
		arg.KnowledgeType,
		arg.KnowledgeContent,
		arg.RelevanceScore,
		arg.Column6,
	)
	var i AgentKnowledgeShare
	err := row.Scan(
		&i.ID,
		&i.SourceAgentID,
		&i.TargetAgentID,
		&i.KnowledgeType,
		&i.KnowledgeContent,
		&i.RelevanceScore,
		&i.WasAccepted,
		&i.IntegrationResult,
		&i.CollaborationID,
		&i.CreatedAt,
	)
	return &i, err
}

const DeactivateAgent = `-- name: DeactivateAgent :exec
UPDATE agent_definitions
SET is_active = false,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateAgent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeactivateAgent, id)
	return err
}

const GetActiveCollaborations = `-- name: GetActiveCollaborations :many
SELECT ac.id, ac.user_id, ac.session_id, ac.lead_agent_id, ac.participating_agents, ac.collaboration_type, ac.task_description, ac.task_complexity, ac.collaboration_plan, ac.execution_trace, ac.outcome, ac.total_duration_ms, ac.resource_usage, ac.created_at, ac.completed_at,
       ad.agent_name as lead_agent_name
FROM agent_collaborations ac
JOIN agent_definitions ad ON ac.lead_agent_id = ad.id
WHERE ac.user_id = $1::uuid
  AND ac.completed_at IS NULL
ORDER BY ac.created_at DESC
`

type GetActiveCollaborationsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	UserID              pgtype.UUID        `json:"user_id"`
	SessionID           string             `json:"session_id"`
	LeadAgentID         pgtype.UUID        `json:"lead_agent_id"`
	ParticipatingAgents []pgtype.UUID      `json:"participating_agents"`
	CollaborationType   string             `json:"collaboration_type"`
	TaskDescription     string             `json:"task_description"`
	TaskComplexity      pgtype.Float8      `json:"task_complexity"`
	CollaborationPlan   []byte             `json:"collaboration_plan"`
	ExecutionTrace      []byte             `json:"execution_trace"`
	Outcome             pgtype.Text        `json:"outcome"`
	TotalDurationMs     pgtype.Int4        `json:"total_duration_ms"`
	ResourceUsage       []byte             `json:"resource_usage"`
	CreatedAt           time.Time          `json:"created_at"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
	LeadAgentName       string             `json:"lead_agent_name"`
}

func (q *Queries) GetActiveCollaborations(ctx context.Context, dollar_1 pgtype.UUID) ([]*GetActiveCollaborationsRow, error) {
	rows, err := q.db.Query(ctx, GetActiveCollaborations, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveCollaborationsRow{}
	for rows.Next() {
		var i GetActiveCollaborationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.LeadAgentID,
			&i.ParticipatingAgents,
			&i.CollaborationType,
			&i.TaskDescription,
			&i.TaskComplexity,
			&i.CollaborationPlan,
			&i.ExecutionTrace,
			&i.Outcome,
			&i.TotalDurationMs,
			&i.ResourceUsage,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.LeadAgentName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAgentCollaboration = `-- name: GetAgentCollaboration :one
SELECT ac.id, ac.user_id, ac.session_id, ac.lead_agent_id, ac.participating_agents, ac.collaboration_type, ac.task_description, ac.task_complexity, ac.collaboration_plan, ac.execution_trace, ac.outcome, ac.total_duration_ms, ac.resource_usage, ac.created_at, ac.completed_at,
       ad.agent_name as lead_agent_name
FROM agent_collaborations ac
JOIN agent_definitions ad ON ac.lead_agent_id = ad.id
WHERE ac.id = $1
`

type GetAgentCollaborationRow struct {
	ID                  pgtype.UUID        `json:"id"`
	UserID              pgtype.UUID        `json:"user_id"`
	SessionID           string             `json:"session_id"`
	LeadAgentID         pgtype.UUID        `json:"lead_agent_id"`
	ParticipatingAgents []pgtype.UUID      `json:"participating_agents"`
	CollaborationType   string             `json:"collaboration_type"`
	TaskDescription     string             `json:"task_description"`
	TaskComplexity      pgtype.Float8      `json:"task_complexity"`
	CollaborationPlan   []byte             `json:"collaboration_plan"`
	ExecutionTrace      []byte             `json:"execution_trace"`
	Outcome             pgtype.Text        `json:"outcome"`
	TotalDurationMs     pgtype.Int4        `json:"total_duration_ms"`
	ResourceUsage       []byte             `json:"resource_usage"`
	CreatedAt           time.Time          `json:"created_at"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
	LeadAgentName       string             `json:"lead_agent_name"`
}

func (q *Queries) GetAgentCollaboration(ctx context.Context, id pgtype.UUID) (*GetAgentCollaborationRow, error) {
	row := q.db.QueryRow(ctx, GetAgentCollaboration, id)
	var i GetAgentCollaborationRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.LeadAgentID,
		&i.ParticipatingAgents,
		&i.CollaborationType,
		&i.TaskDescription,
		&i.TaskComplexity,
		&i.CollaborationPlan,
		&i.ExecutionTrace,
		&i.Outcome,
		&i.TotalDurationMs,
		&i.ResourceUsage,
		&i.CreatedAt,
		&i.CompletedAt,
		&i.LeadAgentName,
	)
	return &i, err
}

const GetAgentCollaborations = `-- name: GetAgentCollaborations :many
SELECT ac.id, ac.user_id, ac.session_id, ac.lead_agent_id, ac.participating_agents, ac.collaboration_type, ac.task_description, ac.task_complexity, ac.collaboration_plan, ac.execution_trace, ac.outcome, ac.total_duration_ms, ac.resource_usage, ac.created_at, ac.completed_at,
       ad.agent_name as lead_agent_name
FROM agent_collaborations ac
JOIN agent_definitions ad ON ac.lead_agent_id = ad.id
WHERE ac.user_id = $1::uuid
  AND (ac.collaboration_type = $2 OR $2 IS NULL)
  AND (ac.session_id = $3 OR $3 IS NULL)
ORDER BY ac.created_at DESC
LIMIT $4 OFFSET $5
`

type GetAgentCollaborationsParams struct {
	Column1           pgtype.UUID `json:"column_1"`
	CollaborationType string      `json:"collaboration_type"`
	SessionID         string      `json:"session_id"`
	Limit             int32       `json:"limit"`
	Offset            int32       `json:"offset"`
}

type GetAgentCollaborationsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	UserID              pgtype.UUID        `json:"user_id"`
	SessionID           string             `json:"session_id"`
	LeadAgentID         pgtype.UUID        `json:"lead_agent_id"`
	ParticipatingAgents []pgtype.UUID      `json:"participating_agents"`
	CollaborationType   string             `json:"collaboration_type"`
	TaskDescription     string             `json:"task_description"`
	TaskComplexity      pgtype.Float8      `json:"task_complexity"`
	CollaborationPlan   []byte             `json:"collaboration_plan"`
	ExecutionTrace      []byte             `json:"execution_trace"`
	Outcome             pgtype.Text        `json:"outcome"`
	TotalDurationMs     pgtype.Int4        `json:"total_duration_ms"`
	ResourceUsage       []byte             `json:"resource_usage"`
	CreatedAt           time.Time          `json:"created_at"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
	LeadAgentName       string             `json:"lead_agent_name"`
}

func (q *Queries) GetAgentCollaborations(ctx context.Context, arg GetAgentCollaborationsParams) ([]*GetAgentCollaborationsRow, error) {
	rows, err := q.db.Query(ctx, GetAgentCollaborations,
		arg.Column1,
		arg.CollaborationType,
		arg.SessionID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAgentCollaborationsRow{}
	for rows.Next() {
		var i GetAgentCollaborationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.LeadAgentID,
			&i.ParticipatingAgents,
			&i.CollaborationType,
			&i.TaskDescription,
			&i.TaskComplexity,
			&i.CollaborationPlan,
			&i.ExecutionTrace,
			&i.Outcome,
			&i.TotalDurationMs,
			&i.ResourceUsage,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.LeadAgentName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAgentDefinition = `-- name: GetAgentDefinition :one
SELECT id, agent_name, agent_type, capabilities, expertise_domains, collaboration_preferences, performance_metrics, is_active, created_at, updated_at FROM agent_definitions
WHERE id = $1
`

func (q *Queries) GetAgentDefinition(ctx context.Context, id pgtype.UUID) (*AgentDefinition, error) {
	row := q.db.QueryRow(ctx, GetAgentDefinition, id)
	var i AgentDefinition
	err := row.Scan(
		&i.ID,
		&i.AgentName,
		&i.AgentType,
		&i.Capabilities,
		&i.ExpertiseDomains,
		&i.CollaborationPreferences,
		&i.PerformanceMetrics,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetAgentDefinitionByName = `-- name: GetAgentDefinitionByName :one
SELECT id, agent_name, agent_type, capabilities, expertise_domains, collaboration_preferences, performance_metrics, is_active, created_at, updated_at FROM agent_definitions
WHERE agent_name = $1
  AND is_active = true
`

func (q *Queries) GetAgentDefinitionByName(ctx context.Context, agentName string) (*AgentDefinition, error) {
	row := q.db.QueryRow(ctx, GetAgentDefinitionByName, agentName)
	var i AgentDefinition
	err := row.Scan(
		&i.ID,
		&i.AgentName,
		&i.AgentType,
		&i.Capabilities,
		&i.ExpertiseDomains,
		&i.CollaborationPreferences,
		&i.PerformanceMetrics,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetAgentDefinitions = `-- name: GetAgentDefinitions :many
SELECT id, agent_name, agent_type, capabilities, expertise_domains, collaboration_preferences, performance_metrics, is_active, created_at, updated_at FROM agent_definitions
WHERE (agent_type = ANY($1::text[]) OR $1 IS NULL)
  AND is_active = true
ORDER BY agent_name
`

func (q *Queries) GetAgentDefinitions(ctx context.Context, dollar_1 []string) ([]*AgentDefinition, error) {
	rows, err := q.db.Query(ctx, GetAgentDefinitions, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AgentDefinition{}
	for rows.Next() {
		var i AgentDefinition
		if err := rows.Scan(
			&i.ID,
			&i.AgentName,
			&i.AgentType,
			&i.Capabilities,
			&i.ExpertiseDomains,
			&i.CollaborationPreferences,
			&i.PerformanceMetrics,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAgentPerformanceRankings = `-- name: GetAgentPerformanceRankings :many
SELECT 
    ad.agent_name,
    ad.agent_type,
    COUNT(ac.id) as total_collaborations,
    COUNT(ac.id) FILTER (WHERE ac.outcome = 'success') as successful_collaborations,
    COUNT(ac.id) FILTER (WHERE ac.outcome = 'success')::float / COUNT(ac.id) as success_rate,
    AVG(CASE WHEN ac.outcome = 'success' THEN ac.total_duration_ms END) as avg_success_duration,
    AVG(ac.task_complexity) as avg_task_complexity
FROM agent_definitions ad
LEFT JOIN agent_collaborations ac ON ad.id = ac.lead_agent_id
WHERE ad.is_active = true
  AND (ac.user_id = $1::uuid OR ac.user_id IS NULL)
  AND (ac.created_at >= COALESCE($2, NOW() - INTERVAL '30 days') OR ac.created_at IS NULL)
GROUP BY ad.id, ad.agent_name, ad.agent_type
HAVING COUNT(ac.id) > 0
ORDER BY success_rate DESC, avg_success_duration ASC
`

type GetAgentPerformanceRankingsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
}

type GetAgentPerformanceRankingsRow struct {
	AgentName                string  `json:"agent_name"`
	AgentType                string  `json:"agent_type"`
	TotalCollaborations      int64   `json:"total_collaborations"`
	SuccessfulCollaborations int64   `json:"successful_collaborations"`
	SuccessRate              int32   `json:"success_rate"`
	AvgSuccessDuration       float64 `json:"avg_success_duration"`
	AvgTaskComplexity        float64 `json:"avg_task_complexity"`
}

func (q *Queries) GetAgentPerformanceRankings(ctx context.Context, arg GetAgentPerformanceRankingsParams) ([]*GetAgentPerformanceRankingsRow, error) {
	rows, err := q.db.Query(ctx, GetAgentPerformanceRankings, arg.Column1, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAgentPerformanceRankingsRow{}
	for rows.Next() {
		var i GetAgentPerformanceRankingsRow
		if err := rows.Scan(
			&i.AgentName,
			&i.AgentType,
			&i.TotalCollaborations,
			&i.SuccessfulCollaborations,
			&i.SuccessRate,
			&i.AvgSuccessDuration,
			&i.AvgTaskComplexity,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAgentsByCapability = `-- name: GetAgentsByCapability :many
SELECT id, agent_name, agent_type, capabilities, expertise_domains, collaboration_preferences, performance_metrics, is_active, created_at, updated_at FROM agent_definitions
WHERE capabilities @> $1
  AND is_active = true
ORDER BY (capabilities->>'confidence')::float DESC
`

func (q *Queries) GetAgentsByCapability(ctx context.Context, capabilities []byte) ([]*AgentDefinition, error) {
	rows, err := q.db.Query(ctx, GetAgentsByCapability, capabilities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AgentDefinition{}
	for rows.Next() {
		var i AgentDefinition
		if err := rows.Scan(
			&i.ID,
			&i.AgentName,
			&i.AgentType,
			&i.Capabilities,
			&i.ExpertiseDomains,
			&i.CollaborationPreferences,
			&i.PerformanceMetrics,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAgentsByDomain = `-- name: GetAgentsByDomain :many
SELECT id, agent_name, agent_type, capabilities, expertise_domains, collaboration_preferences, performance_metrics, is_active, created_at, updated_at FROM agent_definitions
WHERE $1 = ANY(expertise_domains)
  AND is_active = true
ORDER BY agent_name
`

func (q *Queries) GetAgentsByDomain(ctx context.Context, expertiseDomains []string) ([]*AgentDefinition, error) {
	rows, err := q.db.Query(ctx, GetAgentsByDomain, expertiseDomains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AgentDefinition{}
	for rows.Next() {
		var i AgentDefinition
		if err := rows.Scan(
			&i.ID,
			&i.AgentName,
			&i.AgentType,
			&i.Capabilities,
			&i.ExpertiseDomains,
			&i.CollaborationPreferences,
			&i.PerformanceMetrics,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCollaborationEfficiency = `-- name: GetCollaborationEfficiency :one

SELECT 
    AVG(CASE WHEN outcome = 'success' THEN total_duration_ms END) as avg_success_duration,
    AVG(CASE WHEN outcome = 'failure' THEN total_duration_ms END) as avg_failure_duration,
    COUNT(*) FILTER (WHERE outcome = 'success')::float / COUNT(*) as overall_success_rate,
    AVG(task_complexity) as avg_task_complexity,
    COUNT(DISTINCT lead_agent_id) as unique_lead_agents,
    AVG(array_length(participating_agents, 1)) as avg_participants
FROM agent_collaborations
WHERE user_id = $1::uuid
  AND completed_at IS NOT NULL
  AND created_at >= COALESCE($2, NOW() - INTERVAL '30 days')
`

type GetCollaborationEfficiencyParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
}

type GetCollaborationEfficiencyRow struct {
	AvgSuccessDuration float64 `json:"avg_success_duration"`
	AvgFailureDuration float64 `json:"avg_failure_duration"`
	OverallSuccessRate int32   `json:"overall_success_rate"`
	AvgTaskComplexity  float64 `json:"avg_task_complexity"`
	UniqueLeadAgents   int64   `json:"unique_lead_agents"`
	AvgParticipants    float64 `json:"avg_participants"`
}

// =====================================================
// AGENT COLLABORATION ANALYTICS QUERIES
// =====================================================
func (q *Queries) GetCollaborationEfficiency(ctx context.Context, arg GetCollaborationEfficiencyParams) (*GetCollaborationEfficiencyRow, error) {
	row := q.db.QueryRow(ctx, GetCollaborationEfficiency, arg.Column1, arg.CreatedAt)
	var i GetCollaborationEfficiencyRow
	err := row.Scan(
		&i.AvgSuccessDuration,
		&i.AvgFailureDuration,
		&i.OverallSuccessRate,
		&i.AvgTaskComplexity,
		&i.UniqueLeadAgents,
		&i.AvgParticipants,
	)
	return &i, err
}

const GetCollaborationStatistics = `-- name: GetCollaborationStatistics :one
SELECT 
    collaboration_type,
    COUNT(*) as total_collaborations,
    AVG(task_complexity) as avg_complexity,
    AVG(total_duration_ms) as avg_duration_ms,
    COUNT(*) FILTER (WHERE outcome = 'success') as successful_count,
    COUNT(*) FILTER (WHERE outcome = 'failure') as failed_count,
    COUNT(*) FILTER (WHERE completed_at IS NULL) as active_count
FROM agent_collaborations
WHERE user_id = $1::uuid
  AND created_at >= COALESCE($2, NOW() - INTERVAL '30 days')
GROUP BY collaboration_type
`

type GetCollaborationStatisticsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
}

type GetCollaborationStatisticsRow struct {
	CollaborationType   string  `json:"collaboration_type"`
	TotalCollaborations int64   `json:"total_collaborations"`
	AvgComplexity       float64 `json:"avg_complexity"`
	AvgDurationMs       float64 `json:"avg_duration_ms"`
	SuccessfulCount     int64   `json:"successful_count"`
	FailedCount         int64   `json:"failed_count"`
	ActiveCount         int64   `json:"active_count"`
}

func (q *Queries) GetCollaborationStatistics(ctx context.Context, arg GetCollaborationStatisticsParams) (*GetCollaborationStatisticsRow, error) {
	row := q.db.QueryRow(ctx, GetCollaborationStatistics, arg.Column1, arg.CreatedAt)
	var i GetCollaborationStatisticsRow
	err := row.Scan(
		&i.CollaborationType,
		&i.TotalCollaborations,
		&i.AvgComplexity,
		&i.AvgDurationMs,
		&i.SuccessfulCount,
		&i.FailedCount,
		&i.ActiveCount,
	)
	return &i, err
}

const GetCollaborationTrends = `-- name: GetCollaborationTrends :many
SELECT 
    DATE_TRUNC($2::text, created_at) as time_period,
    COUNT(*) as total_collaborations,
    COUNT(*) FILTER (WHERE outcome = 'success') as successful_collaborations,
    AVG(task_complexity) as avg_complexity,
    AVG(total_duration_ms) as avg_duration
FROM agent_collaborations
WHERE user_id = $1::uuid
  AND created_at >= COALESCE($3, NOW() - INTERVAL '90 days')
GROUP BY DATE_TRUNC($2::text, created_at)
ORDER BY time_period
`

type GetCollaborationTrendsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	Column2   string      `json:"column_2"`
	CreatedAt time.Time   `json:"created_at"`
}

type GetCollaborationTrendsRow struct {
	TimePeriod               pgtype.Interval `json:"time_period"`
	TotalCollaborations      int64           `json:"total_collaborations"`
	SuccessfulCollaborations int64           `json:"successful_collaborations"`
	AvgComplexity            float64         `json:"avg_complexity"`
	AvgDuration              float64         `json:"avg_duration"`
}

func (q *Queries) GetCollaborationTrends(ctx context.Context, arg GetCollaborationTrendsParams) ([]*GetCollaborationTrendsRow, error) {
	rows, err := q.db.Query(ctx, GetCollaborationTrends, arg.Column1, arg.Column2, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetCollaborationTrendsRow{}
	for rows.Next() {
		var i GetCollaborationTrendsRow
		if err := rows.Scan(
			&i.TimePeriod,
			&i.TotalCollaborations,
			&i.SuccessfulCollaborations,
			&i.AvgComplexity,
			&i.AvgDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCollaborationsByAgent = `-- name: GetCollaborationsByAgent :many
SELECT ac.id, ac.user_id, ac.session_id, ac.lead_agent_id, ac.participating_agents, ac.collaboration_type, ac.task_description, ac.task_complexity, ac.collaboration_plan, ac.execution_trace, ac.outcome, ac.total_duration_ms, ac.resource_usage, ac.created_at, ac.completed_at,
       ad.agent_name as lead_agent_name,
       CASE 
         WHEN ac.lead_agent_id = $2::uuid THEN 'lead'
         ELSE 'participant'
       END as role
FROM agent_collaborations ac
JOIN agent_definitions ad ON ac.lead_agent_id = ad.id
WHERE ac.user_id = $1::uuid
  AND (ac.lead_agent_id = $2::uuid OR $2::uuid = ANY(ac.participating_agents))
ORDER BY ac.created_at DESC
LIMIT $3
`

type GetCollaborationsByAgentParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
	Limit   int32       `json:"limit"`
}

type GetCollaborationsByAgentRow struct {
	ID                  pgtype.UUID        `json:"id"`
	UserID              pgtype.UUID        `json:"user_id"`
	SessionID           string             `json:"session_id"`
	LeadAgentID         pgtype.UUID        `json:"lead_agent_id"`
	ParticipatingAgents []pgtype.UUID      `json:"participating_agents"`
	CollaborationType   string             `json:"collaboration_type"`
	TaskDescription     string             `json:"task_description"`
	TaskComplexity      pgtype.Float8      `json:"task_complexity"`
	CollaborationPlan   []byte             `json:"collaboration_plan"`
	ExecutionTrace      []byte             `json:"execution_trace"`
	Outcome             pgtype.Text        `json:"outcome"`
	TotalDurationMs     pgtype.Int4        `json:"total_duration_ms"`
	ResourceUsage       []byte             `json:"resource_usage"`
	CreatedAt           time.Time          `json:"created_at"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
	LeadAgentName       string             `json:"lead_agent_name"`
	Role                string             `json:"role"`
}

func (q *Queries) GetCollaborationsByAgent(ctx context.Context, arg GetCollaborationsByAgentParams) ([]*GetCollaborationsByAgentRow, error) {
	rows, err := q.db.Query(ctx, GetCollaborationsByAgent, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetCollaborationsByAgentRow{}
	for rows.Next() {
		var i GetCollaborationsByAgentRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.LeadAgentID,
			&i.ParticipatingAgents,
			&i.CollaborationType,
			&i.TaskDescription,
			&i.TaskComplexity,
			&i.CollaborationPlan,
			&i.ExecutionTrace,
			&i.Outcome,
			&i.TotalDurationMs,
			&i.ResourceUsage,
			&i.CreatedAt,
			&i.CompletedAt,
			&i.LeadAgentName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKnowledgeFlowNetwork = `-- name: GetKnowledgeFlowNetwork :many
SELECT 
    sad.agent_name as source_agent,
    tad.agent_name as target_agent,
    COUNT(*) as knowledge_transfers,
    AVG(relevance_score) as avg_relevance,
    COUNT(*) FILTER (WHERE was_accepted = true)::float / COUNT(*) as acceptance_rate
FROM agent_knowledge_shares aks
JOIN agent_definitions sad ON aks.source_agent_id = sad.id
JOIN agent_definitions tad ON aks.target_agent_id = tad.id
WHERE aks.created_at >= COALESCE($1, NOW() - INTERVAL '30 days')
GROUP BY sad.agent_name, tad.agent_name
HAVING COUNT(*) >= $2
ORDER BY knowledge_transfers DESC
`

type GetKnowledgeFlowNetworkParams struct {
	CreatedAt time.Time   `json:"created_at"`
	Column2   interface{} `json:"column_2"`
}

type GetKnowledgeFlowNetworkRow struct {
	SourceAgent        string  `json:"source_agent"`
	TargetAgent        string  `json:"target_agent"`
	KnowledgeTransfers int64   `json:"knowledge_transfers"`
	AvgRelevance       float64 `json:"avg_relevance"`
	AcceptanceRate     int32   `json:"acceptance_rate"`
}

func (q *Queries) GetKnowledgeFlowNetwork(ctx context.Context, arg GetKnowledgeFlowNetworkParams) ([]*GetKnowledgeFlowNetworkRow, error) {
	rows, err := q.db.Query(ctx, GetKnowledgeFlowNetwork, arg.CreatedAt, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetKnowledgeFlowNetworkRow{}
	for rows.Next() {
		var i GetKnowledgeFlowNetworkRow
		if err := rows.Scan(
			&i.SourceAgent,
			&i.TargetAgent,
			&i.KnowledgeTransfers,
			&i.AvgRelevance,
			&i.AcceptanceRate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKnowledgeReceptionStats = `-- name: GetKnowledgeReceptionStats :many
SELECT 
    sad.agent_name as source_agent,
    knowledge_type,
    COUNT(*) as received_count,
    AVG(relevance_score) as avg_relevance,
    COUNT(*) FILTER (WHERE was_accepted = true) as accepted_count
FROM agent_knowledge_shares aks
JOIN agent_definitions sad ON aks.source_agent_id = sad.id
WHERE aks.target_agent_id = $1::uuid
  AND aks.created_at >= COALESCE($2, NOW() - INTERVAL '30 days')
GROUP BY sad.agent_name, knowledge_type
ORDER BY received_count DESC
`

type GetKnowledgeReceptionStatsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
}

type GetKnowledgeReceptionStatsRow struct {
	SourceAgent   string  `json:"source_agent"`
	KnowledgeType string  `json:"knowledge_type"`
	ReceivedCount int64   `json:"received_count"`
	AvgRelevance  float64 `json:"avg_relevance"`
	AcceptedCount int64   `json:"accepted_count"`
}

func (q *Queries) GetKnowledgeReceptionStats(ctx context.Context, arg GetKnowledgeReceptionStatsParams) ([]*GetKnowledgeReceptionStatsRow, error) {
	rows, err := q.db.Query(ctx, GetKnowledgeReceptionStats, arg.Column1, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetKnowledgeReceptionStatsRow{}
	for rows.Next() {
		var i GetKnowledgeReceptionStatsRow
		if err := rows.Scan(
			&i.SourceAgent,
			&i.KnowledgeType,
			&i.ReceivedCount,
			&i.AvgRelevance,
			&i.AcceptedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKnowledgeShare = `-- name: GetKnowledgeShare :one
SELECT aks.id, aks.source_agent_id, aks.target_agent_id, aks.knowledge_type, aks.knowledge_content, aks.relevance_score, aks.was_accepted, aks.integration_result, aks.collaboration_id, aks.created_at,
       sad.agent_name as source_agent_name,
       tad.agent_name as target_agent_name
FROM agent_knowledge_shares aks
JOIN agent_definitions sad ON aks.source_agent_id = sad.id
JOIN agent_definitions tad ON aks.target_agent_id = tad.id
WHERE aks.id = $1
`

type GetKnowledgeShareRow struct {
	ID                pgtype.UUID   `json:"id"`
	SourceAgentID     pgtype.UUID   `json:"source_agent_id"`
	TargetAgentID     pgtype.UUID   `json:"target_agent_id"`
	KnowledgeType     string        `json:"knowledge_type"`
	KnowledgeContent  []byte        `json:"knowledge_content"`
	RelevanceScore    pgtype.Float8 `json:"relevance_score"`
	WasAccepted       pgtype.Bool   `json:"was_accepted"`
	IntegrationResult []byte        `json:"integration_result"`
	CollaborationID   pgtype.UUID   `json:"collaboration_id"`
	CreatedAt         time.Time     `json:"created_at"`
	SourceAgentName   string        `json:"source_agent_name"`
	TargetAgentName   string        `json:"target_agent_name"`
}

func (q *Queries) GetKnowledgeShare(ctx context.Context, id pgtype.UUID) (*GetKnowledgeShareRow, error) {
	row := q.db.QueryRow(ctx, GetKnowledgeShare, id)
	var i GetKnowledgeShareRow
	err := row.Scan(
		&i.ID,
		&i.SourceAgentID,
		&i.TargetAgentID,
		&i.KnowledgeType,
		&i.KnowledgeContent,
		&i.RelevanceScore,
		&i.WasAccepted,
		&i.IntegrationResult,
		&i.CollaborationID,
		&i.CreatedAt,
		&i.SourceAgentName,
		&i.TargetAgentName,
	)
	return &i, err
}

const GetKnowledgeShares = `-- name: GetKnowledgeShares :many
SELECT aks.id, aks.source_agent_id, aks.target_agent_id, aks.knowledge_type, aks.knowledge_content, aks.relevance_score, aks.was_accepted, aks.integration_result, aks.collaboration_id, aks.created_at,
       sad.agent_name as source_agent_name,
       tad.agent_name as target_agent_name
FROM agent_knowledge_shares aks
JOIN agent_definitions sad ON aks.source_agent_id = sad.id
JOIN agent_definitions tad ON aks.target_agent_id = tad.id
WHERE (aks.source_agent_id = $1::uuid OR $1 IS NULL)
  AND (aks.target_agent_id = $2::uuid OR $2 IS NULL)
  AND (aks.knowledge_type = $3 OR $3 IS NULL)
ORDER BY aks.created_at DESC
LIMIT $4 OFFSET $5
`

type GetKnowledgeSharesParams struct {
	Column1       pgtype.UUID `json:"column_1"`
	Column2       pgtype.UUID `json:"column_2"`
	KnowledgeType string      `json:"knowledge_type"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

type GetKnowledgeSharesRow struct {
	ID                pgtype.UUID   `json:"id"`
	SourceAgentID     pgtype.UUID   `json:"source_agent_id"`
	TargetAgentID     pgtype.UUID   `json:"target_agent_id"`
	KnowledgeType     string        `json:"knowledge_type"`
	KnowledgeContent  []byte        `json:"knowledge_content"`
	RelevanceScore    pgtype.Float8 `json:"relevance_score"`
	WasAccepted       pgtype.Bool   `json:"was_accepted"`
	IntegrationResult []byte        `json:"integration_result"`
	CollaborationID   pgtype.UUID   `json:"collaboration_id"`
	CreatedAt         time.Time     `json:"created_at"`
	SourceAgentName   string        `json:"source_agent_name"`
	TargetAgentName   string        `json:"target_agent_name"`
}

func (q *Queries) GetKnowledgeShares(ctx context.Context, arg GetKnowledgeSharesParams) ([]*GetKnowledgeSharesRow, error) {
	rows, err := q.db.Query(ctx, GetKnowledgeShares,
		arg.Column1,
		arg.Column2,
		arg.KnowledgeType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetKnowledgeSharesRow{}
	for rows.Next() {
		var i GetKnowledgeSharesRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceAgentID,
			&i.TargetAgentID,
			&i.KnowledgeType,
			&i.KnowledgeContent,
			&i.RelevanceScore,
			&i.WasAccepted,
			&i.IntegrationResult,
			&i.CollaborationID,
			&i.CreatedAt,
			&i.SourceAgentName,
			&i.TargetAgentName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKnowledgeSharesByCollaboration = `-- name: GetKnowledgeSharesByCollaboration :many
SELECT aks.id, aks.source_agent_id, aks.target_agent_id, aks.knowledge_type, aks.knowledge_content, aks.relevance_score, aks.was_accepted, aks.integration_result, aks.collaboration_id, aks.created_at,
       sad.agent_name as source_agent_name,
       tad.agent_name as target_agent_name
FROM agent_knowledge_shares aks
JOIN agent_definitions sad ON aks.source_agent_id = sad.id
JOIN agent_definitions tad ON aks.target_agent_id = tad.id
WHERE aks.collaboration_id = $1::uuid
ORDER BY aks.created_at
`

type GetKnowledgeSharesByCollaborationRow struct {
	ID                pgtype.UUID   `json:"id"`
	SourceAgentID     pgtype.UUID   `json:"source_agent_id"`
	TargetAgentID     pgtype.UUID   `json:"target_agent_id"`
	KnowledgeType     string        `json:"knowledge_type"`
	KnowledgeContent  []byte        `json:"knowledge_content"`
	RelevanceScore    pgtype.Float8 `json:"relevance_score"`
	WasAccepted       pgtype.Bool   `json:"was_accepted"`
	IntegrationResult []byte        `json:"integration_result"`
	CollaborationID   pgtype.UUID   `json:"collaboration_id"`
	CreatedAt         time.Time     `json:"created_at"`
	SourceAgentName   string        `json:"source_agent_name"`
	TargetAgentName   string        `json:"target_agent_name"`
}

func (q *Queries) GetKnowledgeSharesByCollaboration(ctx context.Context, dollar_1 pgtype.UUID) ([]*GetKnowledgeSharesByCollaborationRow, error) {
	rows, err := q.db.Query(ctx, GetKnowledgeSharesByCollaboration, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetKnowledgeSharesByCollaborationRow{}
	for rows.Next() {
		var i GetKnowledgeSharesByCollaborationRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceAgentID,
			&i.TargetAgentID,
			&i.KnowledgeType,
			&i.KnowledgeContent,
			&i.RelevanceScore,
			&i.WasAccepted,
			&i.IntegrationResult,
			&i.CollaborationID,
			&i.CreatedAt,
			&i.SourceAgentName,
			&i.TargetAgentName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMostEffectiveCollaborations = `-- name: GetMostEffectiveCollaborations :many
SELECT 
    ac.collaboration_type,
    ac.lead_agent_id,
    ad.agent_name as lead_agent_name,
    ac.participating_agents,
    AVG(ac.task_complexity) as avg_complexity,
    AVG(ac.total_duration_ms) as avg_duration_ms,
    COUNT(*) as collaboration_count,
    COUNT(*) FILTER (WHERE ac.outcome = 'success')::float / COUNT(*) as success_rate
FROM agent_collaborations ac
JOIN agent_definitions ad ON ac.lead_agent_id = ad.id
WHERE ac.user_id = $1::uuid
  AND ac.completed_at IS NOT NULL
GROUP BY ac.collaboration_type, ac.lead_agent_id, ad.agent_name, ac.participating_agents
HAVING COUNT(*) >= $2
ORDER BY success_rate DESC, avg_duration_ms ASC
LIMIT $3
`

type GetMostEffectiveCollaborationsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Limit   int32       `json:"limit"`
}

type GetMostEffectiveCollaborationsRow struct {
	CollaborationType   string        `json:"collaboration_type"`
	LeadAgentID         pgtype.UUID   `json:"lead_agent_id"`
	LeadAgentName       string        `json:"lead_agent_name"`
	ParticipatingAgents []pgtype.UUID `json:"participating_agents"`
	AvgComplexity       float64       `json:"avg_complexity"`
	AvgDurationMs       float64       `json:"avg_duration_ms"`
	CollaborationCount  int64         `json:"collaboration_count"`
	SuccessRate         int32         `json:"success_rate"`
}

func (q *Queries) GetMostEffectiveCollaborations(ctx context.Context, arg GetMostEffectiveCollaborationsParams) ([]*GetMostEffectiveCollaborationsRow, error) {
	rows, err := q.db.Query(ctx, GetMostEffectiveCollaborations, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMostEffectiveCollaborationsRow{}
	for rows.Next() {
		var i GetMostEffectiveCollaborationsRow
		if err := rows.Scan(
			&i.CollaborationType,
			&i.LeadAgentID,
			&i.LeadAgentName,
			&i.ParticipatingAgents,
			&i.AvgComplexity,
			&i.AvgDurationMs,
			&i.CollaborationCount,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMostSharedKnowledge = `-- name: GetMostSharedKnowledge :many
SELECT 
    knowledge_type,
    COUNT(*) as share_count,
    AVG(relevance_score) as avg_relevance,
    COUNT(*) FILTER (WHERE was_accepted = true)::float / COUNT(*) as acceptance_rate
FROM agent_knowledge_shares
WHERE source_agent_id = $1::uuid
  AND created_at >= COALESCE($2, NOW() - INTERVAL '30 days')
GROUP BY knowledge_type
ORDER BY share_count DESC, acceptance_rate DESC
`

type GetMostSharedKnowledgeParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
}

type GetMostSharedKnowledgeRow struct {
	KnowledgeType  string  `json:"knowledge_type"`
	ShareCount     int64   `json:"share_count"`
	AvgRelevance   float64 `json:"avg_relevance"`
	AcceptanceRate int32   `json:"acceptance_rate"`
}

func (q *Queries) GetMostSharedKnowledge(ctx context.Context, arg GetMostSharedKnowledgeParams) ([]*GetMostSharedKnowledgeRow, error) {
	rows, err := q.db.Query(ctx, GetMostSharedKnowledge, arg.Column1, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMostSharedKnowledgeRow{}
	for rows.Next() {
		var i GetMostSharedKnowledgeRow
		if err := rows.Scan(
			&i.KnowledgeType,
			&i.ShareCount,
			&i.AvgRelevance,
			&i.AcceptanceRate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetOptimalTeamCompositions = `-- name: GetOptimalTeamCompositions :many
SELECT 
    collaboration_type,
    participating_agents,
    COUNT(*) as usage_count,
    AVG(task_complexity) as avg_complexity,
    COUNT(*) FILTER (WHERE outcome = 'success')::float / COUNT(*) as success_rate,
    AVG(total_duration_ms) as avg_duration
FROM agent_collaborations
WHERE user_id = $1::uuid
  AND completed_at IS NOT NULL
  AND created_at >= COALESCE($2, NOW() - INTERVAL '30 days')
GROUP BY collaboration_type, participating_agents
HAVING COUNT(*) >= $3
ORDER BY success_rate DESC, avg_duration ASC
`

type GetOptimalTeamCompositionsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
	Column3   interface{} `json:"column_3"`
}

type GetOptimalTeamCompositionsRow struct {
	CollaborationType   string        `json:"collaboration_type"`
	ParticipatingAgents []pgtype.UUID `json:"participating_agents"`
	UsageCount          int64         `json:"usage_count"`
	AvgComplexity       float64       `json:"avg_complexity"`
	SuccessRate         int32         `json:"success_rate"`
	AvgDuration         float64       `json:"avg_duration"`
}

func (q *Queries) GetOptimalTeamCompositions(ctx context.Context, arg GetOptimalTeamCompositionsParams) ([]*GetOptimalTeamCompositionsRow, error) {
	rows, err := q.db.Query(ctx, GetOptimalTeamCompositions, arg.Column1, arg.CreatedAt, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOptimalTeamCompositionsRow{}
	for rows.Next() {
		var i GetOptimalTeamCompositionsRow
		if err := rows.Scan(
			&i.CollaborationType,
			&i.ParticipatingAgents,
			&i.UsageCount,
			&i.AvgComplexity,
			&i.SuccessRate,
			&i.AvgDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RecommendCollaborationPartners = `-- name: RecommendCollaborationPartners :many
SELECT 
    ad.id,
    ad.agent_name,
    ad.agent_type,
    ad.capabilities,
    ad.expertise_domains
FROM agent_definitions ad
WHERE ad.id != $1::uuid
  AND ad.is_active = true
ORDER BY ad.agent_name
LIMIT $2
`

type RecommendCollaborationPartnersParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type RecommendCollaborationPartnersRow struct {
	ID               pgtype.UUID `json:"id"`
	AgentName        string      `json:"agent_name"`
	AgentType        string      `json:"agent_type"`
	Capabilities     []byte      `json:"capabilities"`
	ExpertiseDomains []string    `json:"expertise_domains"`
}

func (q *Queries) RecommendCollaborationPartners(ctx context.Context, arg RecommendCollaborationPartnersParams) ([]*RecommendCollaborationPartnersRow, error) {
	rows, err := q.db.Query(ctx, RecommendCollaborationPartners, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*RecommendCollaborationPartnersRow{}
	for rows.Next() {
		var i RecommendCollaborationPartnersRow
		if err := rows.Scan(
			&i.ID,
			&i.AgentName,
			&i.AgentType,
			&i.Capabilities,
			&i.ExpertiseDomains,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateAgentCapabilities = `-- name: UpdateAgentCapabilities :one
UPDATE agent_definitions
SET capabilities = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, agent_name, agent_type, capabilities, expertise_domains, collaboration_preferences, performance_metrics, is_active, created_at, updated_at
`

type UpdateAgentCapabilitiesParams struct {
	ID           pgtype.UUID `json:"id"`
	Capabilities []byte      `json:"capabilities"`
}

func (q *Queries) UpdateAgentCapabilities(ctx context.Context, arg UpdateAgentCapabilitiesParams) (*AgentDefinition, error) {
	row := q.db.QueryRow(ctx, UpdateAgentCapabilities, arg.ID, arg.Capabilities)
	var i AgentDefinition
	err := row.Scan(
		&i.ID,
		&i.AgentName,
		&i.AgentType,
		&i.Capabilities,
		&i.ExpertiseDomains,
		&i.CollaborationPreferences,
		&i.PerformanceMetrics,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateAgentPerformance = `-- name: UpdateAgentPerformance :one
UPDATE agent_definitions
SET performance_metrics = performance_metrics || $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, agent_name, agent_type, capabilities, expertise_domains, collaboration_preferences, performance_metrics, is_active, created_at, updated_at
`

type UpdateAgentPerformanceParams struct {
	ID                 pgtype.UUID `json:"id"`
	PerformanceMetrics []byte      `json:"performance_metrics"`
}

func (q *Queries) UpdateAgentPerformance(ctx context.Context, arg UpdateAgentPerformanceParams) (*AgentDefinition, error) {
	row := q.db.QueryRow(ctx, UpdateAgentPerformance, arg.ID, arg.PerformanceMetrics)
	var i AgentDefinition
	err := row.Scan(
		&i.ID,
		&i.AgentName,
		&i.AgentType,
		&i.Capabilities,
		&i.ExpertiseDomains,
		&i.CollaborationPreferences,
		&i.PerformanceMetrics,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateCollaborationExecution = `-- name: UpdateCollaborationExecution :one
UPDATE agent_collaborations
SET execution_trace = $2,
    resource_usage = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, session_id, lead_agent_id, participating_agents, collaboration_type, task_description, task_complexity, collaboration_plan, execution_trace, outcome, total_duration_ms, resource_usage, created_at, completed_at
`

type UpdateCollaborationExecutionParams struct {
	ID             pgtype.UUID `json:"id"`
	ExecutionTrace []byte      `json:"execution_trace"`
	ResourceUsage  []byte      `json:"resource_usage"`
}

func (q *Queries) UpdateCollaborationExecution(ctx context.Context, arg UpdateCollaborationExecutionParams) (*AgentCollaboration, error) {
	row := q.db.QueryRow(ctx, UpdateCollaborationExecution, arg.ID, arg.ExecutionTrace, arg.ResourceUsage)
	var i AgentCollaboration
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.LeadAgentID,
		&i.ParticipatingAgents,
		&i.CollaborationType,
		&i.TaskDescription,
		&i.TaskComplexity,
		&i.CollaborationPlan,
		&i.ExecutionTrace,
		&i.Outcome,
		&i.TotalDurationMs,
		&i.ResourceUsage,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const UpdateKnowledgeShareAcceptance = `-- name: UpdateKnowledgeShareAcceptance :one
UPDATE agent_knowledge_shares
SET was_accepted = $2,
    integration_result = $3
WHERE id = $1
RETURNING id, source_agent_id, target_agent_id, knowledge_type, knowledge_content, relevance_score, was_accepted, integration_result, collaboration_id, created_at
`

type UpdateKnowledgeShareAcceptanceParams struct {
	ID                pgtype.UUID `json:"id"`
	WasAccepted       pgtype.Bool `json:"was_accepted"`
	IntegrationResult []byte      `json:"integration_result"`
}

func (q *Queries) UpdateKnowledgeShareAcceptance(ctx context.Context, arg UpdateKnowledgeShareAcceptanceParams) (*AgentKnowledgeShare, error) {
	row := q.db.QueryRow(ctx, UpdateKnowledgeShareAcceptance, arg.ID, arg.WasAccepted, arg.IntegrationResult)
	var i AgentKnowledgeShare
	err := row.Scan(
		&i.ID,
		&i.SourceAgentID,
		&i.TargetAgentID,
		&i.KnowledgeType,
		&i.KnowledgeContent,
		&i.RelevanceScore,
		&i.WasAccepted,
		&i.IntegrationResult,
		&i.CollaborationID,
		&i.CreatedAt,
	)
	return &i, err
}
