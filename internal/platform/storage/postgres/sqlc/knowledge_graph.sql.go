// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: knowledge_graph.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector "github.com/pgvector/pgvector-go"
)

const CreateKnowledgeEdge = `-- name: CreateKnowledgeEdge :one

INSERT INTO knowledge_edges (
    user_id,
    source_node_id,
    target_node_id,
    edge_type,
    strength,
    properties,
    evidence_count
) VALUES (
    $1::uuid, $2::uuid, $3::uuid, $4, $5, $6, $7
) ON CONFLICT (source_node_id, target_node_id, edge_type)
DO UPDATE SET
    strength = (knowledge_edges.strength + $5) / 2,
    properties = knowledge_edges.properties || COALESCE($6, '{}'::jsonb),
    evidence_count = knowledge_edges.evidence_count + COALESCE($7, 1),
    last_observed = NOW(),
    updated_at = NOW()
RETURNING id, user_id, source_node_id, target_node_id, edge_type, strength, properties, evidence_count, last_observed, created_at, updated_at, is_active
`

type CreateKnowledgeEdgeParams struct {
	Column1       pgtype.UUID   `json:"column_1"`
	Column2       pgtype.UUID   `json:"column_2"`
	Column3       pgtype.UUID   `json:"column_3"`
	EdgeType      string        `json:"edge_type"`
	Strength      pgtype.Float8 `json:"strength"`
	Properties    []byte        `json:"properties"`
	EvidenceCount pgtype.Int4   `json:"evidence_count"`
}

// =====================================================
// KNOWLEDGE EDGES QUERIES
// =====================================================
func (q *Queries) CreateKnowledgeEdge(ctx context.Context, arg CreateKnowledgeEdgeParams) (*KnowledgeEdge, error) {
	row := q.db.QueryRow(ctx, CreateKnowledgeEdge,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.EdgeType,
		arg.Strength,
		arg.Properties,
		arg.EvidenceCount,
	)
	var i KnowledgeEdge
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceNodeID,
		&i.TargetNodeID,
		&i.EdgeType,
		&i.Strength,
		&i.Properties,
		&i.EvidenceCount,
		&i.LastObserved,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return &i, err
}

const CreateKnowledgeEvolution = `-- name: CreateKnowledgeEvolution :one

INSERT INTO knowledge_evolution (
    user_id,
    entity_type,
    entity_id,
    change_type,
    previous_state,
    new_state,
    change_reason,
    confidence
) VALUES (
    $1::uuid, $2, $3::uuid, $4, $5, $6, $7, $8
) RETURNING id, user_id, entity_type, entity_id, change_type, previous_state, new_state, change_reason, confidence, created_at
`

type CreateKnowledgeEvolutionParams struct {
	Column1       pgtype.UUID   `json:"column_1"`
	EntityType    string        `json:"entity_type"`
	Column3       pgtype.UUID   `json:"column_3"`
	ChangeType    string        `json:"change_type"`
	PreviousState []byte        `json:"previous_state"`
	NewState      []byte        `json:"new_state"`
	ChangeReason  pgtype.Text   `json:"change_reason"`
	Confidence    pgtype.Float8 `json:"confidence"`
}

// =====================================================
// KNOWLEDGE EVOLUTION QUERIES
// =====================================================
func (q *Queries) CreateKnowledgeEvolution(ctx context.Context, arg CreateKnowledgeEvolutionParams) (*KnowledgeEvolution, error) {
	row := q.db.QueryRow(ctx, CreateKnowledgeEvolution,
		arg.Column1,
		arg.EntityType,
		arg.Column3,
		arg.ChangeType,
		arg.PreviousState,
		arg.NewState,
		arg.ChangeReason,
		arg.Confidence,
	)
	var i KnowledgeEvolution
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EntityType,
		&i.EntityID,
		&i.ChangeType,
		&i.PreviousState,
		&i.NewState,
		&i.ChangeReason,
		&i.Confidence,
		&i.CreatedAt,
	)
	return &i, err
}

const CreateKnowledgeNode = `-- name: CreateKnowledgeNode :one


INSERT INTO knowledge_nodes (
    user_id,
    node_type,
    node_name,
    display_name,
    description,
    properties,
    embedding,
    importance
) VALUES (
    $1::uuid, $2, $3, $4, $5, $6, $7, $8
) ON CONFLICT (user_id, node_type, node_name)
DO UPDATE SET
    display_name = COALESCE($4, knowledge_nodes.display_name),
    description = COALESCE($5, knowledge_nodes.description),
    properties = knowledge_nodes.properties || COALESCE($6, '{}'::jsonb),
    embedding = COALESCE($7, knowledge_nodes.embedding),
    importance = COALESCE($8, knowledge_nodes.importance),
    updated_at = NOW()
RETURNING id, user_id, node_type, node_name, display_name, description, properties, embedding, importance, access_frequency, last_accessed, created_at, updated_at, is_active
`

type CreateKnowledgeNodeParams struct {
	Column1     pgtype.UUID     `json:"column_1"`
	NodeType    string          `json:"node_type"`
	NodeName    string          `json:"node_name"`
	DisplayName pgtype.Text     `json:"display_name"`
	Description pgtype.Text     `json:"description"`
	Properties  []byte          `json:"properties"`
	Embedding   pgvector.Vector `json:"embedding"`
	Importance  pgtype.Float8   `json:"importance"`
}

// Knowledge graph queries
// =====================================================
// KNOWLEDGE NODES QUERIES
// =====================================================
func (q *Queries) CreateKnowledgeNode(ctx context.Context, arg CreateKnowledgeNodeParams) (*KnowledgeNode, error) {
	row := q.db.QueryRow(ctx, CreateKnowledgeNode,
		arg.Column1,
		arg.NodeType,
		arg.NodeName,
		arg.DisplayName,
		arg.Description,
		arg.Properties,
		arg.Embedding,
		arg.Importance,
	)
	var i KnowledgeNode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NodeType,
		&i.NodeName,
		&i.DisplayName,
		&i.Description,
		&i.Properties,
		&i.Embedding,
		&i.Importance,
		&i.AccessFrequency,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return &i, err
}

const DeactivateKnowledgeEdge = `-- name: DeactivateKnowledgeEdge :exec
UPDATE knowledge_edges
SET is_active = false,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateKnowledgeEdge(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeactivateKnowledgeEdge, id)
	return err
}

const DeactivateKnowledgeNode = `-- name: DeactivateKnowledgeNode :exec
UPDATE knowledge_nodes
SET is_active = false,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateKnowledgeNode(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeactivateKnowledgeNode, id)
	return err
}

const FindDirectConnections = `-- name: FindDirectConnections :many
SELECT 
    ke.id, ke.user_id, ke.source_node_id, ke.target_node_id, ke.edge_type, ke.strength, ke.properties, ke.evidence_count, ke.last_observed, ke.created_at, ke.updated_at, ke.is_active,
    tn.node_name as target_name
FROM knowledge_edges ke
JOIN knowledge_nodes tn ON ke.target_node_id = tn.id
WHERE ke.source_node_id = $2::uuid
  AND ke.user_id = $1::uuid
  AND ke.is_active = true
ORDER BY ke.strength DESC
`

type FindDirectConnectionsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
}

type FindDirectConnectionsRow struct {
	ID            pgtype.UUID        `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	SourceNodeID  pgtype.UUID        `json:"source_node_id"`
	TargetNodeID  pgtype.UUID        `json:"target_node_id"`
	EdgeType      string             `json:"edge_type"`
	Strength      pgtype.Float8      `json:"strength"`
	Properties    []byte             `json:"properties"`
	EvidenceCount pgtype.Int4        `json:"evidence_count"`
	LastObserved  pgtype.Timestamptz `json:"last_observed"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	IsActive      pgtype.Bool        `json:"is_active"`
	TargetName    string             `json:"target_name"`
}

func (q *Queries) FindDirectConnections(ctx context.Context, arg FindDirectConnectionsParams) ([]*FindDirectConnectionsRow, error) {
	rows, err := q.db.Query(ctx, FindDirectConnections, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FindDirectConnectionsRow{}
	for rows.Next() {
		var i FindDirectConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SourceNodeID,
			&i.TargetNodeID,
			&i.EdgeType,
			&i.Strength,
			&i.Properties,
			&i.EvidenceCount,
			&i.LastObserved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.TargetName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetConnectedNodes = `-- name: GetConnectedNodes :many
SELECT DISTINCT
    kn.id,
    kn.node_name,
    kn.node_type,
    kn.importance
FROM knowledge_nodes kn
JOIN knowledge_edges ke ON (ke.source_node_id = kn.id OR ke.target_node_id = kn.id)
WHERE kn.user_id = $1::uuid
  AND (ke.source_node_id = $2::uuid OR ke.target_node_id = $2::uuid)
  AND kn.id != $2::uuid
  AND kn.is_active = true
  AND ke.is_active = true
ORDER BY kn.importance DESC
`

type GetConnectedNodesParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
}

type GetConnectedNodesRow struct {
	ID         pgtype.UUID   `json:"id"`
	NodeName   string        `json:"node_name"`
	NodeType   string        `json:"node_type"`
	Importance pgtype.Float8 `json:"importance"`
}

func (q *Queries) GetConnectedNodes(ctx context.Context, arg GetConnectedNodesParams) ([]*GetConnectedNodesRow, error) {
	rows, err := q.db.Query(ctx, GetConnectedNodes, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetConnectedNodesRow{}
	for rows.Next() {
		var i GetConnectedNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.NodeName,
			&i.NodeType,
			&i.Importance,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEdgesByType = `-- name: GetEdgesByType :many
SELECT ke.id, ke.user_id, ke.source_node_id, ke.target_node_id, ke.edge_type, ke.strength, ke.properties, ke.evidence_count, ke.last_observed, ke.created_at, ke.updated_at, ke.is_active, 
       sn.node_name as source_name,
       tn.node_name as target_name
FROM knowledge_edges ke
JOIN knowledge_nodes sn ON ke.source_node_id = sn.id
JOIN knowledge_nodes tn ON ke.target_node_id = tn.id
WHERE ke.user_id = $1::uuid
  AND ke.edge_type = $2
  AND ke.is_active = true
ORDER BY ke.strength DESC
LIMIT $3
`

type GetEdgesByTypeParams struct {
	Column1  pgtype.UUID `json:"column_1"`
	EdgeType string      `json:"edge_type"`
	Limit    int32       `json:"limit"`
}

type GetEdgesByTypeRow struct {
	ID            pgtype.UUID        `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	SourceNodeID  pgtype.UUID        `json:"source_node_id"`
	TargetNodeID  pgtype.UUID        `json:"target_node_id"`
	EdgeType      string             `json:"edge_type"`
	Strength      pgtype.Float8      `json:"strength"`
	Properties    []byte             `json:"properties"`
	EvidenceCount pgtype.Int4        `json:"evidence_count"`
	LastObserved  pgtype.Timestamptz `json:"last_observed"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	IsActive      pgtype.Bool        `json:"is_active"`
	SourceName    string             `json:"source_name"`
	TargetName    string             `json:"target_name"`
}

func (q *Queries) GetEdgesByType(ctx context.Context, arg GetEdgesByTypeParams) ([]*GetEdgesByTypeRow, error) {
	rows, err := q.db.Query(ctx, GetEdgesByType, arg.Column1, arg.EdgeType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEdgesByTypeRow{}
	for rows.Next() {
		var i GetEdgesByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SourceNodeID,
			&i.TargetNodeID,
			&i.EdgeType,
			&i.Strength,
			&i.Properties,
			&i.EvidenceCount,
			&i.LastObserved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.SourceName,
			&i.TargetName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEntityEvolutionHistory = `-- name: GetEntityEvolutionHistory :many
SELECT id, user_id, entity_type, entity_id, change_type, previous_state, new_state, change_reason, confidence, created_at FROM knowledge_evolution
WHERE entity_id = $1::uuid
ORDER BY created_at ASC
`

func (q *Queries) GetEntityEvolutionHistory(ctx context.Context, dollar_1 pgtype.UUID) ([]*KnowledgeEvolution, error) {
	rows, err := q.db.Query(ctx, GetEntityEvolutionHistory, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*KnowledgeEvolution{}
	for rows.Next() {
		var i KnowledgeEvolution
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EntityType,
			&i.EntityID,
			&i.ChangeType,
			&i.PreviousState,
			&i.NewState,
			&i.ChangeReason,
			&i.Confidence,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetGraphStatistics = `-- name: GetGraphStatistics :one

SELECT 
    (SELECT COUNT(*) FROM knowledge_nodes WHERE user_id = $1::uuid AND is_active = true) as total_nodes,
    (SELECT COUNT(*) FROM knowledge_edges WHERE user_id = $1::uuid AND is_active = true) as total_edges,
    (SELECT COUNT(DISTINCT node_type) FROM knowledge_nodes WHERE user_id = $1::uuid AND is_active = true) as node_types,
    (SELECT COUNT(DISTINCT edge_type) FROM knowledge_edges WHERE user_id = $1::uuid AND is_active = true) as edge_types,
    (SELECT AVG(importance) FROM knowledge_nodes WHERE user_id = $1::uuid AND is_active = true) as avg_node_importance,
    (SELECT AVG(strength) FROM knowledge_edges WHERE user_id = $1::uuid AND is_active = true) as avg_edge_strength
`

type GetGraphStatisticsRow struct {
	TotalNodes        int64   `json:"total_nodes"`
	TotalEdges        int64   `json:"total_edges"`
	NodeTypes         int64   `json:"node_types"`
	EdgeTypes         int64   `json:"edge_types"`
	AvgNodeImportance float64 `json:"avg_node_importance"`
	AvgEdgeStrength   float64 `json:"avg_edge_strength"`
}

// =====================================================
// KNOWLEDGE GRAPH ANALYTICS QUERIES
// =====================================================
func (q *Queries) GetGraphStatistics(ctx context.Context, dollar_1 pgtype.UUID) (*GetGraphStatisticsRow, error) {
	row := q.db.QueryRow(ctx, GetGraphStatistics, dollar_1)
	var i GetGraphStatisticsRow
	err := row.Scan(
		&i.TotalNodes,
		&i.TotalEdges,
		&i.NodeTypes,
		&i.EdgeTypes,
		&i.AvgNodeImportance,
		&i.AvgEdgeStrength,
	)
	return &i, err
}

const GetHighlyConnectedNodes = `-- name: GetHighlyConnectedNodes :many
SELECT 
    kn.id, kn.user_id, kn.node_type, kn.node_name, kn.display_name, kn.description, kn.properties, kn.embedding, kn.importance, kn.access_frequency, kn.last_accessed, kn.created_at, kn.updated_at, kn.is_active,
    COUNT(ke.id) as connection_count
FROM knowledge_nodes kn
LEFT JOIN knowledge_edges ke ON (ke.source_node_id = kn.id OR ke.target_node_id = kn.id)
WHERE kn.user_id = $1::uuid
  AND kn.is_active = true
  AND (ke.is_active = true OR ke.id IS NULL)
GROUP BY kn.id
HAVING COUNT(ke.id) >= $2
ORDER BY COUNT(ke.id) DESC
`

type GetHighlyConnectedNodesParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	ID      pgtype.UUID `json:"id"`
}

type GetHighlyConnectedNodesRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	NodeType        string             `json:"node_type"`
	NodeName        string             `json:"node_name"`
	DisplayName     pgtype.Text        `json:"display_name"`
	Description     pgtype.Text        `json:"description"`
	Properties      []byte             `json:"properties"`
	Embedding       pgvector.Vector    `json:"embedding"`
	Importance      pgtype.Float8      `json:"importance"`
	AccessFrequency pgtype.Float8      `json:"access_frequency"`
	LastAccessed    pgtype.Timestamptz `json:"last_accessed"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	IsActive        pgtype.Bool        `json:"is_active"`
	ConnectionCount int64              `json:"connection_count"`
}

func (q *Queries) GetHighlyConnectedNodes(ctx context.Context, arg GetHighlyConnectedNodesParams) ([]*GetHighlyConnectedNodesRow, error) {
	rows, err := q.db.Query(ctx, GetHighlyConnectedNodes, arg.Column1, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetHighlyConnectedNodesRow{}
	for rows.Next() {
		var i GetHighlyConnectedNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NodeType,
			&i.NodeName,
			&i.DisplayName,
			&i.Description,
			&i.Properties,
			&i.Embedding,
			&i.Importance,
			&i.AccessFrequency,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.ConnectionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKnowledgeEdge = `-- name: GetKnowledgeEdge :one
SELECT id, user_id, source_node_id, target_node_id, edge_type, strength, properties, evidence_count, last_observed, created_at, updated_at, is_active FROM knowledge_edges
WHERE id = $1
`

func (q *Queries) GetKnowledgeEdge(ctx context.Context, id pgtype.UUID) (*KnowledgeEdge, error) {
	row := q.db.QueryRow(ctx, GetKnowledgeEdge, id)
	var i KnowledgeEdge
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceNodeID,
		&i.TargetNodeID,
		&i.EdgeType,
		&i.Strength,
		&i.Properties,
		&i.EvidenceCount,
		&i.LastObserved,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return &i, err
}

const GetKnowledgeEdges = `-- name: GetKnowledgeEdges :many
SELECT ke.id, ke.user_id, ke.source_node_id, ke.target_node_id, ke.edge_type, ke.strength, ke.properties, ke.evidence_count, ke.last_observed, ke.created_at, ke.updated_at, ke.is_active, 
       sn.node_name as source_name,
       tn.node_name as target_name
FROM knowledge_edges ke
JOIN knowledge_nodes sn ON ke.source_node_id = sn.id
JOIN knowledge_nodes tn ON ke.target_node_id = tn.id
WHERE ke.user_id = $1::uuid
  AND (ke.edge_type = ANY($2::text[]) OR $2 IS NULL)
  AND ke.is_active = true
ORDER BY ke.strength DESC, ke.evidence_count DESC
LIMIT $3 OFFSET $4
`

type GetKnowledgeEdgesParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 []string    `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type GetKnowledgeEdgesRow struct {
	ID            pgtype.UUID        `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	SourceNodeID  pgtype.UUID        `json:"source_node_id"`
	TargetNodeID  pgtype.UUID        `json:"target_node_id"`
	EdgeType      string             `json:"edge_type"`
	Strength      pgtype.Float8      `json:"strength"`
	Properties    []byte             `json:"properties"`
	EvidenceCount pgtype.Int4        `json:"evidence_count"`
	LastObserved  pgtype.Timestamptz `json:"last_observed"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	IsActive      pgtype.Bool        `json:"is_active"`
	SourceName    string             `json:"source_name"`
	TargetName    string             `json:"target_name"`
}

func (q *Queries) GetKnowledgeEdges(ctx context.Context, arg GetKnowledgeEdgesParams) ([]*GetKnowledgeEdgesRow, error) {
	rows, err := q.db.Query(ctx, GetKnowledgeEdges,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetKnowledgeEdgesRow{}
	for rows.Next() {
		var i GetKnowledgeEdgesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SourceNodeID,
			&i.TargetNodeID,
			&i.EdgeType,
			&i.Strength,
			&i.Properties,
			&i.EvidenceCount,
			&i.LastObserved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.SourceName,
			&i.TargetName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKnowledgeEvolution = `-- name: GetKnowledgeEvolution :many
SELECT id, user_id, entity_type, entity_id, change_type, previous_state, new_state, change_reason, confidence, created_at FROM knowledge_evolution
WHERE user_id = $1::uuid
  AND (entity_type = $2 OR $2 IS NULL)
  AND (entity_id = $3::uuid OR $3 IS NULL)
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type GetKnowledgeEvolutionParams struct {
	Column1    pgtype.UUID `json:"column_1"`
	EntityType string      `json:"entity_type"`
	Column3    pgtype.UUID `json:"column_3"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) GetKnowledgeEvolution(ctx context.Context, arg GetKnowledgeEvolutionParams) ([]*KnowledgeEvolution, error) {
	rows, err := q.db.Query(ctx, GetKnowledgeEvolution,
		arg.Column1,
		arg.EntityType,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*KnowledgeEvolution{}
	for rows.Next() {
		var i KnowledgeEvolution
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EntityType,
			&i.EntityID,
			&i.ChangeType,
			&i.PreviousState,
			&i.NewState,
			&i.ChangeReason,
			&i.Confidence,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKnowledgeNode = `-- name: GetKnowledgeNode :one
SELECT id, user_id, node_type, node_name, display_name, description, properties, embedding, importance, access_frequency, last_accessed, created_at, updated_at, is_active FROM knowledge_nodes
WHERE id = $1
`

func (q *Queries) GetKnowledgeNode(ctx context.Context, id pgtype.UUID) (*KnowledgeNode, error) {
	row := q.db.QueryRow(ctx, GetKnowledgeNode, id)
	var i KnowledgeNode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NodeType,
		&i.NodeName,
		&i.DisplayName,
		&i.Description,
		&i.Properties,
		&i.Embedding,
		&i.Importance,
		&i.AccessFrequency,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return &i, err
}

const GetKnowledgeNodeByName = `-- name: GetKnowledgeNodeByName :one
SELECT id, user_id, node_type, node_name, display_name, description, properties, embedding, importance, access_frequency, last_accessed, created_at, updated_at, is_active FROM knowledge_nodes
WHERE user_id = $1::uuid
  AND node_type = $2
  AND node_name = $3
  AND is_active = true
`

type GetKnowledgeNodeByNameParams struct {
	Column1  pgtype.UUID `json:"column_1"`
	NodeType string      `json:"node_type"`
	NodeName string      `json:"node_name"`
}

func (q *Queries) GetKnowledgeNodeByName(ctx context.Context, arg GetKnowledgeNodeByNameParams) (*KnowledgeNode, error) {
	row := q.db.QueryRow(ctx, GetKnowledgeNodeByName, arg.Column1, arg.NodeType, arg.NodeName)
	var i KnowledgeNode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NodeType,
		&i.NodeName,
		&i.DisplayName,
		&i.Description,
		&i.Properties,
		&i.Embedding,
		&i.Importance,
		&i.AccessFrequency,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return &i, err
}

const GetKnowledgeNodes = `-- name: GetKnowledgeNodes :many
SELECT id, user_id, node_type, node_name, display_name, description, properties, embedding, importance, access_frequency, last_accessed, created_at, updated_at, is_active FROM knowledge_nodes
WHERE user_id = $1::uuid
  AND (node_type = ANY($2::text[]) OR $2 IS NULL)
  AND is_active = true
ORDER BY importance DESC, access_frequency DESC
LIMIT $3 OFFSET $4
`

type GetKnowledgeNodesParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 []string    `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) GetKnowledgeNodes(ctx context.Context, arg GetKnowledgeNodesParams) ([]*KnowledgeNode, error) {
	rows, err := q.db.Query(ctx, GetKnowledgeNodes,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*KnowledgeNode{}
	for rows.Next() {
		var i KnowledgeNode
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NodeType,
			&i.NodeName,
			&i.DisplayName,
			&i.Description,
			&i.Properties,
			&i.Embedding,
			&i.Importance,
			&i.AccessFrequency,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMostConnectedNodes = `-- name: GetMostConnectedNodes :many
SELECT 
    kn.id, kn.user_id, kn.node_type, kn.node_name, kn.display_name, kn.description, kn.properties, kn.embedding, kn.importance, kn.access_frequency, kn.last_accessed, kn.created_at, kn.updated_at, kn.is_active,
    (SELECT COUNT(*) FROM knowledge_edges WHERE source_node_id = kn.id OR target_node_id = kn.id) as connection_count
FROM knowledge_nodes kn
WHERE kn.user_id = $1::uuid
  AND kn.is_active = true
ORDER BY connection_count DESC, kn.importance DESC
LIMIT $2
`

type GetMostConnectedNodesParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Limit   int32       `json:"limit"`
}

type GetMostConnectedNodesRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	NodeType        string             `json:"node_type"`
	NodeName        string             `json:"node_name"`
	DisplayName     pgtype.Text        `json:"display_name"`
	Description     pgtype.Text        `json:"description"`
	Properties      []byte             `json:"properties"`
	Embedding       pgvector.Vector    `json:"embedding"`
	Importance      pgtype.Float8      `json:"importance"`
	AccessFrequency pgtype.Float8      `json:"access_frequency"`
	LastAccessed    pgtype.Timestamptz `json:"last_accessed"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	IsActive        pgtype.Bool        `json:"is_active"`
	ConnectionCount int64              `json:"connection_count"`
}

func (q *Queries) GetMostConnectedNodes(ctx context.Context, arg GetMostConnectedNodesParams) ([]*GetMostConnectedNodesRow, error) {
	rows, err := q.db.Query(ctx, GetMostConnectedNodes, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMostConnectedNodesRow{}
	for rows.Next() {
		var i GetMostConnectedNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NodeType,
			&i.NodeName,
			&i.DisplayName,
			&i.Description,
			&i.Properties,
			&i.Embedding,
			&i.Importance,
			&i.AccessFrequency,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.ConnectionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetNodeConnections = `-- name: GetNodeConnections :many
SELECT ke.id, ke.user_id, ke.source_node_id, ke.target_node_id, ke.edge_type, ke.strength, ke.properties, ke.evidence_count, ke.last_observed, ke.created_at, ke.updated_at, ke.is_active,
       CASE 
         WHEN ke.source_node_id = $2::uuid THEN tn.node_name
         ELSE sn.node_name
       END as connected_node_name,
       CASE 
         WHEN ke.source_node_id = $2::uuid THEN tn.id
         ELSE sn.id
       END as connected_node_id,
       CASE 
         WHEN ke.source_node_id = $2::uuid THEN 'outgoing'
         ELSE 'incoming'
       END as direction
FROM knowledge_edges ke
JOIN knowledge_nodes sn ON ke.source_node_id = sn.id
JOIN knowledge_nodes tn ON ke.target_node_id = tn.id
WHERE ke.user_id = $1::uuid
  AND (ke.source_node_id = $2::uuid OR ke.target_node_id = $2::uuid)
  AND ke.is_active = true
ORDER BY ke.strength DESC
`

type GetNodeConnectionsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
}

type GetNodeConnectionsRow struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
	SourceNodeID      pgtype.UUID        `json:"source_node_id"`
	TargetNodeID      pgtype.UUID        `json:"target_node_id"`
	EdgeType          string             `json:"edge_type"`
	Strength          pgtype.Float8      `json:"strength"`
	Properties        []byte             `json:"properties"`
	EvidenceCount     pgtype.Int4        `json:"evidence_count"`
	LastObserved      pgtype.Timestamptz `json:"last_observed"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	IsActive          pgtype.Bool        `json:"is_active"`
	ConnectedNodeName interface{}        `json:"connected_node_name"`
	ConnectedNodeID   interface{}        `json:"connected_node_id"`
	Direction         string             `json:"direction"`
}

func (q *Queries) GetNodeConnections(ctx context.Context, arg GetNodeConnectionsParams) ([]*GetNodeConnectionsRow, error) {
	rows, err := q.db.Query(ctx, GetNodeConnections, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetNodeConnectionsRow{}
	for rows.Next() {
		var i GetNodeConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SourceNodeID,
			&i.TargetNodeID,
			&i.EdgeType,
			&i.Strength,
			&i.Properties,
			&i.EvidenceCount,
			&i.LastObserved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.ConnectedNodeName,
			&i.ConnectedNodeID,
			&i.Direction,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetNodesByImportance = `-- name: GetNodesByImportance :many
SELECT id, user_id, node_type, node_name, display_name, description, properties, embedding, importance, access_frequency, last_accessed, created_at, updated_at, is_active FROM knowledge_nodes
WHERE user_id = $1::uuid
  AND importance >= $2
  AND is_active = true
ORDER BY importance DESC
LIMIT $3
`

type GetNodesByImportanceParams struct {
	Column1    pgtype.UUID   `json:"column_1"`
	Importance pgtype.Float8 `json:"importance"`
	Limit      int32         `json:"limit"`
}

func (q *Queries) GetNodesByImportance(ctx context.Context, arg GetNodesByImportanceParams) ([]*KnowledgeNode, error) {
	rows, err := q.db.Query(ctx, GetNodesByImportance, arg.Column1, arg.Importance, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*KnowledgeNode{}
	for rows.Next() {
		var i KnowledgeNode
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NodeType,
			&i.NodeName,
			&i.DisplayName,
			&i.Description,
			&i.Properties,
			&i.Embedding,
			&i.Importance,
			&i.AccessFrequency,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetOrphanNodes = `-- name: GetOrphanNodes :many
SELECT kn.id, kn.user_id, kn.node_type, kn.node_name, kn.display_name, kn.description, kn.properties, kn.embedding, kn.importance, kn.access_frequency, kn.last_accessed, kn.created_at, kn.updated_at, kn.is_active
FROM knowledge_nodes kn
LEFT JOIN knowledge_edges ke ON (ke.source_node_id = kn.id OR ke.target_node_id = kn.id)
WHERE kn.user_id = $1::uuid
  AND kn.is_active = true
  AND ke.id IS NULL
ORDER BY kn.created_at DESC
`

func (q *Queries) GetOrphanNodes(ctx context.Context, dollar_1 pgtype.UUID) ([]*KnowledgeNode, error) {
	rows, err := q.db.Query(ctx, GetOrphanNodes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*KnowledgeNode{}
	for rows.Next() {
		var i KnowledgeNode
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NodeType,
			&i.NodeName,
			&i.DisplayName,
			&i.Description,
			&i.Properties,
			&i.Embedding,
			&i.Importance,
			&i.AccessFrequency,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecentChanges = `-- name: GetRecentChanges :many
SELECT ke.id, ke.user_id, ke.entity_type, ke.entity_id, ke.change_type, ke.previous_state, ke.new_state, ke.change_reason, ke.confidence, ke.created_at, 
       CASE 
         WHEN ke.entity_type = 'node' THEN kn.node_name
         ELSE CONCAT('Edge: ', sn.node_name, ' -> ', tn.node_name)
       END as entity_name
FROM knowledge_evolution ke
LEFT JOIN knowledge_nodes kn ON ke.entity_type = 'node' AND ke.entity_id = kn.id
LEFT JOIN knowledge_edges kedge ON ke.entity_type = 'edge' AND ke.entity_id = kedge.id
LEFT JOIN knowledge_nodes sn ON kedge.source_node_id = sn.id
LEFT JOIN knowledge_nodes tn ON kedge.target_node_id = tn.id
WHERE ke.user_id = $1::uuid
  AND ke.created_at >= $2
ORDER BY ke.created_at DESC
LIMIT $3
`

type GetRecentChangesParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
	Limit     int32       `json:"limit"`
}

type GetRecentChangesRow struct {
	ID            pgtype.UUID   `json:"id"`
	UserID        pgtype.UUID   `json:"user_id"`
	EntityType    string        `json:"entity_type"`
	EntityID      pgtype.UUID   `json:"entity_id"`
	ChangeType    string        `json:"change_type"`
	PreviousState []byte        `json:"previous_state"`
	NewState      []byte        `json:"new_state"`
	ChangeReason  pgtype.Text   `json:"change_reason"`
	Confidence    pgtype.Float8 `json:"confidence"`
	CreatedAt     time.Time     `json:"created_at"`
	EntityName    interface{}   `json:"entity_name"`
}

func (q *Queries) GetRecentChanges(ctx context.Context, arg GetRecentChangesParams) ([]*GetRecentChangesRow, error) {
	rows, err := q.db.Query(ctx, GetRecentChanges, arg.Column1, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecentChangesRow{}
	for rows.Next() {
		var i GetRecentChangesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EntityType,
			&i.EntityID,
			&i.ChangeType,
			&i.PreviousState,
			&i.NewState,
			&i.ChangeReason,
			&i.Confidence,
			&i.CreatedAt,
			&i.EntityName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetStrongestConnections = `-- name: GetStrongestConnections :many
SELECT ke.id, ke.user_id, ke.source_node_id, ke.target_node_id, ke.edge_type, ke.strength, ke.properties, ke.evidence_count, ke.last_observed, ke.created_at, ke.updated_at, ke.is_active, 
       sn.node_name as source_name,
       tn.node_name as target_name
FROM knowledge_edges ke
JOIN knowledge_nodes sn ON ke.source_node_id = sn.id
JOIN knowledge_nodes tn ON ke.target_node_id = tn.id
WHERE ke.user_id = $1::uuid
  AND ke.strength >= $2
  AND ke.is_active = true
ORDER BY ke.strength DESC
LIMIT $3
`

type GetStrongestConnectionsParams struct {
	Column1  pgtype.UUID   `json:"column_1"`
	Strength pgtype.Float8 `json:"strength"`
	Limit    int32         `json:"limit"`
}

type GetStrongestConnectionsRow struct {
	ID            pgtype.UUID        `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	SourceNodeID  pgtype.UUID        `json:"source_node_id"`
	TargetNodeID  pgtype.UUID        `json:"target_node_id"`
	EdgeType      string             `json:"edge_type"`
	Strength      pgtype.Float8      `json:"strength"`
	Properties    []byte             `json:"properties"`
	EvidenceCount pgtype.Int4        `json:"evidence_count"`
	LastObserved  pgtype.Timestamptz `json:"last_observed"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	IsActive      pgtype.Bool        `json:"is_active"`
	SourceName    string             `json:"source_name"`
	TargetName    string             `json:"target_name"`
}

func (q *Queries) GetStrongestConnections(ctx context.Context, arg GetStrongestConnectionsParams) ([]*GetStrongestConnectionsRow, error) {
	rows, err := q.db.Query(ctx, GetStrongestConnections, arg.Column1, arg.Strength, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetStrongestConnectionsRow{}
	for rows.Next() {
		var i GetStrongestConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SourceNodeID,
			&i.TargetNodeID,
			&i.EdgeType,
			&i.Strength,
			&i.Properties,
			&i.EvidenceCount,
			&i.LastObserved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.SourceName,
			&i.TargetName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchKnowledgeNodesByName = `-- name: SearchKnowledgeNodesByName :many
SELECT id, user_id, node_type, node_name, display_name, description, properties, embedding, importance, access_frequency, last_accessed, created_at, updated_at, is_active FROM knowledge_nodes
WHERE user_id = $1::uuid
  AND to_tsvector('english', node_name || ' ' || COALESCE(display_name, '') || ' ' || COALESCE(description, '')) 
      @@ plainto_tsquery('english', $2)
  AND is_active = true
ORDER BY importance DESC
LIMIT $3
`

type SearchKnowledgeNodesByNameParams struct {
	Column1        pgtype.UUID `json:"column_1"`
	PlaintoTsquery string      `json:"plainto_tsquery"`
	Limit          int32       `json:"limit"`
}

func (q *Queries) SearchKnowledgeNodesByName(ctx context.Context, arg SearchKnowledgeNodesByNameParams) ([]*KnowledgeNode, error) {
	rows, err := q.db.Query(ctx, SearchKnowledgeNodesByName, arg.Column1, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*KnowledgeNode{}
	for rows.Next() {
		var i KnowledgeNode
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NodeType,
			&i.NodeName,
			&i.DisplayName,
			&i.Description,
			&i.Properties,
			&i.Embedding,
			&i.Importance,
			&i.AccessFrequency,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchKnowledgeNodesBySimilarity = `-- name: SearchKnowledgeNodesBySimilarity :many
SELECT 
    id,
    node_type,
    node_name,
    display_name,
    importance,
    embedding <=> $2::vector as distance
FROM knowledge_nodes
WHERE user_id = $1::uuid
  AND embedding IS NOT NULL
  AND is_active = true
ORDER BY embedding <=> $2::vector
LIMIT $3
`

type SearchKnowledgeNodesBySimilarityParams struct {
	Column1 pgtype.UUID     `json:"column_1"`
	Column2 pgvector.Vector `json:"column_2"`
	Limit   int32           `json:"limit"`
}

type SearchKnowledgeNodesBySimilarityRow struct {
	ID          pgtype.UUID   `json:"id"`
	NodeType    string        `json:"node_type"`
	NodeName    string        `json:"node_name"`
	DisplayName pgtype.Text   `json:"display_name"`
	Importance  pgtype.Float8 `json:"importance"`
	Distance    interface{}   `json:"distance"`
}

func (q *Queries) SearchKnowledgeNodesBySimilarity(ctx context.Context, arg SearchKnowledgeNodesBySimilarityParams) ([]*SearchKnowledgeNodesBySimilarityRow, error) {
	rows, err := q.db.Query(ctx, SearchKnowledgeNodesBySimilarity, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchKnowledgeNodesBySimilarityRow{}
	for rows.Next() {
		var i SearchKnowledgeNodesBySimilarityRow
		if err := rows.Scan(
			&i.ID,
			&i.NodeType,
			&i.NodeName,
			&i.DisplayName,
			&i.Importance,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateKnowledgeEdgeStrength = `-- name: UpdateKnowledgeEdgeStrength :one
UPDATE knowledge_edges
SET strength = $2,
    evidence_count = evidence_count + 1,
    last_observed = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, source_node_id, target_node_id, edge_type, strength, properties, evidence_count, last_observed, created_at, updated_at, is_active
`

type UpdateKnowledgeEdgeStrengthParams struct {
	ID       pgtype.UUID   `json:"id"`
	Strength pgtype.Float8 `json:"strength"`
}

func (q *Queries) UpdateKnowledgeEdgeStrength(ctx context.Context, arg UpdateKnowledgeEdgeStrengthParams) (*KnowledgeEdge, error) {
	row := q.db.QueryRow(ctx, UpdateKnowledgeEdgeStrength, arg.ID, arg.Strength)
	var i KnowledgeEdge
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceNodeID,
		&i.TargetNodeID,
		&i.EdgeType,
		&i.Strength,
		&i.Properties,
		&i.EvidenceCount,
		&i.LastObserved,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return &i, err
}

const UpdateKnowledgeNodeAccess = `-- name: UpdateKnowledgeNodeAccess :one
UPDATE knowledge_nodes
SET access_frequency = access_frequency + 1,
    last_accessed = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, node_type, node_name, display_name, description, properties, embedding, importance, access_frequency, last_accessed, created_at, updated_at, is_active
`

func (q *Queries) UpdateKnowledgeNodeAccess(ctx context.Context, id pgtype.UUID) (*KnowledgeNode, error) {
	row := q.db.QueryRow(ctx, UpdateKnowledgeNodeAccess, id)
	var i KnowledgeNode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NodeType,
		&i.NodeName,
		&i.DisplayName,
		&i.Description,
		&i.Properties,
		&i.Embedding,
		&i.Importance,
		&i.AccessFrequency,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return &i, err
}

const UpdateKnowledgeNodeProperties = `-- name: UpdateKnowledgeNodeProperties :one
UPDATE knowledge_nodes
SET properties = properties || $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, node_type, node_name, display_name, description, properties, embedding, importance, access_frequency, last_accessed, created_at, updated_at, is_active
`

type UpdateKnowledgeNodePropertiesParams struct {
	ID         pgtype.UUID `json:"id"`
	Properties []byte      `json:"properties"`
}

func (q *Queries) UpdateKnowledgeNodeProperties(ctx context.Context, arg UpdateKnowledgeNodePropertiesParams) (*KnowledgeNode, error) {
	row := q.db.QueryRow(ctx, UpdateKnowledgeNodeProperties, arg.ID, arg.Properties)
	var i KnowledgeNode
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NodeType,
		&i.NodeName,
		&i.DisplayName,
		&i.Description,
		&i.Properties,
		&i.Embedding,
		&i.Importance,
		&i.AccessFrequency,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return &i, err
}

const WeakenKnowledgeEdge = `-- name: WeakenKnowledgeEdge :one
UPDATE knowledge_edges
SET strength = strength * $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, source_node_id, target_node_id, edge_type, strength, properties, evidence_count, last_observed, created_at, updated_at, is_active
`

type WeakenKnowledgeEdgeParams struct {
	ID       pgtype.UUID   `json:"id"`
	Strength pgtype.Float8 `json:"strength"`
}

func (q *Queries) WeakenKnowledgeEdge(ctx context.Context, arg WeakenKnowledgeEdgeParams) (*KnowledgeEdge, error) {
	row := q.db.QueryRow(ctx, WeakenKnowledgeEdge, arg.ID, arg.Strength)
	var i KnowledgeEdge
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceNodeID,
		&i.TargetNodeID,
		&i.EdgeType,
		&i.Strength,
		&i.Properties,
		&i.EvidenceCount,
		&i.LastObserved,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return &i, err
}
