// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vector_similarity.sql

package sqlc

import (
	"context"
	"encoding/json"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector "github.com/pgvector/pgvector-go"
)

const BulkDeleteEmbeddings = `-- name: BulkDeleteEmbeddings :exec
DELETE FROM embeddings
WHERE id = ANY($1::uuid[])
`

// Delete multiple embeddings by IDs
func (q *Queries) BulkDeleteEmbeddings(ctx context.Context, dollar_1 []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, BulkDeleteEmbeddings, dollar_1)
	return err
}

const CountEmbeddingsByType = `-- name: CountEmbeddingsByType :one
SELECT COUNT(*) as count
FROM embeddings
WHERE content_type = $1
`

// Count embeddings by content type
func (q *Queries) CountEmbeddingsByType(ctx context.Context, contentType string) (int64, error) {
	row := q.db.QueryRow(ctx, CountEmbeddingsByType, contentType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DeleteEmbeddingsByContentType = `-- name: DeleteEmbeddingsByContentType :exec
DELETE FROM embeddings
WHERE content_type = $1
`

// Delete all embeddings for a specific content type
func (q *Queries) DeleteEmbeddingsByContentType(ctx context.Context, contentType string) error {
	_, err := q.db.Exec(ctx, DeleteEmbeddingsByContentType, contentType)
	return err
}

const DeleteEmbeddingsByMetadata = `-- name: DeleteEmbeddingsByMetadata :exec
DELETE FROM embeddings
WHERE metadata @> $1::jsonb
`

// Delete embeddings matching specific metadata criteria
func (q *Queries) DeleteEmbeddingsByMetadata(ctx context.Context, dollar_1 []byte) error {
	_, err := q.db.Exec(ctx, DeleteEmbeddingsByMetadata, dollar_1)
	return err
}

const DeleteExpiredEmbeddings = `-- name: DeleteExpiredEmbeddings :exec
DELETE FROM embeddings
WHERE created_at < $1
    AND ($2::text IS NULL OR content_type = $2)
`

type DeleteExpiredEmbeddingsParams struct {
	CreatedAt time.Time `json:"created_at"`
	Column2   string    `json:"column_2"`
}

// Delete embeddings older than a specific date
func (q *Queries) DeleteExpiredEmbeddings(ctx context.Context, arg DeleteExpiredEmbeddingsParams) error {
	_, err := q.db.Exec(ctx, DeleteExpiredEmbeddings, arg.CreatedAt, arg.Column2)
	return err
}

const GetEmbeddingStats = `-- name: GetEmbeddingStats :many
SELECT 
    content_type,
    COUNT(*) as count,
    MAX(created_at) as latest_created,
    AVG(array_length(embedding, 1)) as avg_dimensions
FROM embeddings
GROUP BY content_type
ORDER BY count DESC
`

type GetEmbeddingStatsRow struct {
	ContentType   string      `json:"content_type"`
	Count         int64       `json:"count"`
	LatestCreated interface{} `json:"latest_created"`
	AvgDimensions float64     `json:"avg_dimensions"`
}

// Get statistics about embeddings grouped by content type
func (q *Queries) GetEmbeddingStats(ctx context.Context) ([]*GetEmbeddingStatsRow, error) {
	rows, err := q.db.Query(ctx, GetEmbeddingStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEmbeddingStatsRow{}
	for rows.Next() {
		var i GetEmbeddingStatsRow
		if err := rows.Scan(
			&i.ContentType,
			&i.Count,
			&i.LatestCreated,
			&i.AvgDimensions,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchEmbeddingsByTypeWithMetadata = `-- name: SearchEmbeddingsByTypeWithMetadata :many
SELECT 
    id,
    content_type,
    content_id,
    content_text,
    embedding,
    metadata,
    created_at,
    1 - (embedding <=> $1::vector) as similarity
FROM embeddings
WHERE content_type = $2
    AND ($3::jsonb IS NULL OR metadata @> $3::jsonb)
    AND 1 - (embedding <=> $1::vector) > $4
ORDER BY embedding <=> $1::vector
LIMIT $5
`

type SearchEmbeddingsByTypeWithMetadataParams struct {
	Column1     pgvector.Vector `json:"column_1"`
	ContentType string          `json:"content_type"`
	Column3     []byte          `json:"column_3"`
	Embedding   pgvector.Vector `json:"embedding"`
	Limit       int32           `json:"limit"`
}

type SearchEmbeddingsByTypeWithMetadataRow struct {
	ID          pgtype.UUID     `json:"id"`
	ContentType string          `json:"content_type"`
	ContentID   pgtype.UUID     `json:"content_id"`
	ContentText string          `json:"content_text"`
	Embedding   pgvector.Vector `json:"embedding"`
	Metadata    json.RawMessage `json:"metadata"`
	CreatedAt   time.Time       `json:"created_at"`
	Similarity  int32           `json:"similarity"`
}

// Search embeddings with metadata filtering
func (q *Queries) SearchEmbeddingsByTypeWithMetadata(ctx context.Context, arg SearchEmbeddingsByTypeWithMetadataParams) ([]*SearchEmbeddingsByTypeWithMetadataRow, error) {
	rows, err := q.db.Query(ctx, SearchEmbeddingsByTypeWithMetadata,
		arg.Column1,
		arg.ContentType,
		arg.Column3,
		arg.Embedding,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchEmbeddingsByTypeWithMetadataRow{}
	for rows.Next() {
		var i SearchEmbeddingsByTypeWithMetadataRow
		if err := rows.Scan(
			&i.ID,
			&i.ContentType,
			&i.ContentID,
			&i.ContentText,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateEmbeddingMetadata = `-- name: UpdateEmbeddingMetadata :exec
UPDATE embeddings
SET metadata = $2
WHERE id = $1
`

type UpdateEmbeddingMetadataParams struct {
	ID       pgtype.UUID     `json:"id"`
	Metadata json.RawMessage `json:"metadata"`
}

// Update metadata for a specific embedding
func (q *Queries) UpdateEmbeddingMetadata(ctx context.Context, arg UpdateEmbeddingMetadataParams) error {
	_, err := q.db.Exec(ctx, UpdateEmbeddingMetadata, arg.ID, arg.Metadata)
	return err
}
