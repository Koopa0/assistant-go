// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: advanced_memory.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector "github.com/pgvector/pgvector-go"
)

const AddCausalLink = `-- name: AddCausalLink :one
UPDATE episodic_memories
SET causal_links = array_append(causal_links, $2::uuid)
WHERE id = $1
  AND NOT ($2::uuid = ANY(causal_links))
RETURNING id, user_id, episode_type, episode_summary, full_context, emotional_valence, importance, vividness, embedding, temporal_context, spatial_context, social_context, causal_links, access_count, last_accessed, created_at, decay_rate
`

type AddCausalLinkParams struct {
	ID      pgtype.UUID `json:"id"`
	Column2 pgtype.UUID `json:"column_2"`
}

func (q *Queries) AddCausalLink(ctx context.Context, arg AddCausalLinkParams) (*EpisodicMemory, error) {
	row := q.db.QueryRow(ctx, AddCausalLink, arg.ID, arg.Column2)
	var i EpisodicMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeType,
		&i.EpisodeSummary,
		&i.FullContext,
		&i.EmotionalValence,
		&i.Importance,
		&i.Vividness,
		&i.Embedding,
		&i.TemporalContext,
		&i.SpatialContext,
		&i.SocialContext,
		&i.CausalLinks,
		&i.AccessCount,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.DecayRate,
	)
	return &i, err
}

const ClearExpiredWorkingMemory = `-- name: ClearExpiredWorkingMemory :exec
DELETE FROM working_memory
WHERE expires_at <= NOW()
`

func (q *Queries) ClearExpiredWorkingMemory(ctx context.Context) error {
	_, err := q.db.Exec(ctx, ClearExpiredWorkingMemory)
	return err
}

const ClearWorkingMemorySlot = `-- name: ClearWorkingMemorySlot :exec
DELETE FROM working_memory
WHERE user_id = $1::uuid
  AND session_id = $2
  AND memory_slot = $3
`

type ClearWorkingMemorySlotParams struct {
	Column1    pgtype.UUID `json:"column_1"`
	SessionID  string      `json:"session_id"`
	MemorySlot int32       `json:"memory_slot"`
}

func (q *Queries) ClearWorkingMemorySlot(ctx context.Context, arg ClearWorkingMemorySlotParams) error {
	_, err := q.db.Exec(ctx, ClearWorkingMemorySlot, arg.Column1, arg.SessionID, arg.MemorySlot)
	return err
}

const ConsolidateWorkingMemory = `-- name: ConsolidateWorkingMemory :many
SELECT 
    content_type,
    content,
    activation_level,
    reference_count,
    linked_memories
FROM working_memory
WHERE user_id = $1::uuid
  AND session_id = $2
  AND activation_level >= $3
  AND reference_count >= $4
  AND expires_at > NOW()
ORDER BY activation_level DESC
`

type ConsolidateWorkingMemoryParams struct {
	Column1         pgtype.UUID   `json:"column_1"`
	SessionID       string        `json:"session_id"`
	ActivationLevel pgtype.Float8 `json:"activation_level"`
	ReferenceCount  pgtype.Int4   `json:"reference_count"`
}

type ConsolidateWorkingMemoryRow struct {
	ContentType     string        `json:"content_type"`
	Content         []byte        `json:"content"`
	ActivationLevel pgtype.Float8 `json:"activation_level"`
	ReferenceCount  pgtype.Int4   `json:"reference_count"`
	LinkedMemories  []pgtype.UUID `json:"linked_memories"`
}

func (q *Queries) ConsolidateWorkingMemory(ctx context.Context, arg ConsolidateWorkingMemoryParams) ([]*ConsolidateWorkingMemoryRow, error) {
	rows, err := q.db.Query(ctx, ConsolidateWorkingMemory,
		arg.Column1,
		arg.SessionID,
		arg.ActivationLevel,
		arg.ReferenceCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ConsolidateWorkingMemoryRow{}
	for rows.Next() {
		var i ConsolidateWorkingMemoryRow
		if err := rows.Scan(
			&i.ContentType,
			&i.Content,
			&i.ActivationLevel,
			&i.ReferenceCount,
			&i.LinkedMemories,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CreateEpisodicMemory = `-- name: CreateEpisodicMemory :one


INSERT INTO episodic_memories (
    user_id,
    episode_type,
    episode_summary,
    full_context,
    emotional_valence,
    importance,
    vividness,
    embedding,
    temporal_context,
    spatial_context,
    social_context,
    causal_links,
    decay_rate
) VALUES (
    $1::uuid, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, user_id, episode_type, episode_summary, full_context, emotional_valence, importance, vividness, embedding, temporal_context, spatial_context, social_context, causal_links, access_count, last_accessed, created_at, decay_rate
`

type CreateEpisodicMemoryParams struct {
	Column1          pgtype.UUID     `json:"column_1"`
	EpisodeType      string          `json:"episode_type"`
	EpisodeSummary   string          `json:"episode_summary"`
	FullContext      []byte          `json:"full_context"`
	EmotionalValence pgtype.Float8   `json:"emotional_valence"`
	Importance       float64         `json:"importance"`
	Vividness        pgtype.Float8   `json:"vividness"`
	Embedding        pgvector.Vector `json:"embedding"`
	TemporalContext  []byte          `json:"temporal_context"`
	SpatialContext   []byte          `json:"spatial_context"`
	SocialContext    []byte          `json:"social_context"`
	CausalLinks      []pgtype.UUID   `json:"causal_links"`
	DecayRate        pgtype.Float8   `json:"decay_rate"`
}

// Advanced memory system queries
// =====================================================
// EPISODIC MEMORIES QUERIES
// =====================================================
func (q *Queries) CreateEpisodicMemory(ctx context.Context, arg CreateEpisodicMemoryParams) (*EpisodicMemory, error) {
	row := q.db.QueryRow(ctx, CreateEpisodicMemory,
		arg.Column1,
		arg.EpisodeType,
		arg.EpisodeSummary,
		arg.FullContext,
		arg.EmotionalValence,
		arg.Importance,
		arg.Vividness,
		arg.Embedding,
		arg.TemporalContext,
		arg.SpatialContext,
		arg.SocialContext,
		arg.CausalLinks,
		arg.DecayRate,
	)
	var i EpisodicMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeType,
		&i.EpisodeSummary,
		&i.FullContext,
		&i.EmotionalValence,
		&i.Importance,
		&i.Vividness,
		&i.Embedding,
		&i.TemporalContext,
		&i.SpatialContext,
		&i.SocialContext,
		&i.CausalLinks,
		&i.AccessCount,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.DecayRate,
	)
	return &i, err
}

const CreateProceduralMemory = `-- name: CreateProceduralMemory :one

INSERT INTO procedural_memories (
    user_id,
    procedure_name,
    procedure_type,
    trigger_conditions,
    steps,
    prerequisites,
    expected_outcomes
) VALUES (
    $1::uuid, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, procedure_name, procedure_type, trigger_conditions, steps, prerequisites, expected_outcomes, success_rate, execution_count, average_duration_ms, optimization_history, is_automated, automation_confidence, last_executed, created_at, updated_at
`

type CreateProceduralMemoryParams struct {
	Column1           pgtype.UUID `json:"column_1"`
	ProcedureName     string      `json:"procedure_name"`
	ProcedureType     string      `json:"procedure_type"`
	TriggerConditions []byte      `json:"trigger_conditions"`
	Steps             []byte      `json:"steps"`
	Prerequisites     []byte      `json:"prerequisites"`
	ExpectedOutcomes  []byte      `json:"expected_outcomes"`
}

// =====================================================
// PROCEDURAL MEMORIES QUERIES
// =====================================================
func (q *Queries) CreateProceduralMemory(ctx context.Context, arg CreateProceduralMemoryParams) (*ProceduralMemory, error) {
	row := q.db.QueryRow(ctx, CreateProceduralMemory,
		arg.Column1,
		arg.ProcedureName,
		arg.ProcedureType,
		arg.TriggerConditions,
		arg.Steps,
		arg.Prerequisites,
		arg.ExpectedOutcomes,
	)
	var i ProceduralMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProcedureName,
		&i.ProcedureType,
		&i.TriggerConditions,
		&i.Steps,
		&i.Prerequisites,
		&i.ExpectedOutcomes,
		&i.SuccessRate,
		&i.ExecutionCount,
		&i.AverageDurationMs,
		&i.OptimizationHistory,
		&i.IsAutomated,
		&i.AutomationConfidence,
		&i.LastExecuted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateSemanticMemory = `-- name: CreateSemanticMemory :one

INSERT INTO semantic_memories (
    user_id,
    knowledge_type,
    subject,
    predicate,
    object,
    confidence,
    source_type,
    source_references,
    embedding
) VALUES (
    $1::uuid, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, user_id, knowledge_type, subject, predicate, object, confidence, source_type, source_references, embedding, contradiction_count, confirmation_count, last_confirmed, is_active, created_at, updated_at
`

type CreateSemanticMemoryParams struct {
	Column1          pgtype.UUID     `json:"column_1"`
	KnowledgeType    string          `json:"knowledge_type"`
	Subject          string          `json:"subject"`
	Predicate        string          `json:"predicate"`
	Object           []byte          `json:"object"`
	Confidence       float64         `json:"confidence"`
	SourceType       pgtype.Text     `json:"source_type"`
	SourceReferences []pgtype.UUID   `json:"source_references"`
	Embedding        pgvector.Vector `json:"embedding"`
}

// =====================================================
// SEMANTIC MEMORIES QUERIES
// =====================================================
func (q *Queries) CreateSemanticMemory(ctx context.Context, arg CreateSemanticMemoryParams) (*SemanticMemory, error) {
	row := q.db.QueryRow(ctx, CreateSemanticMemory,
		arg.Column1,
		arg.KnowledgeType,
		arg.Subject,
		arg.Predicate,
		arg.Object,
		arg.Confidence,
		arg.SourceType,
		arg.SourceReferences,
		arg.Embedding,
	)
	var i SemanticMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KnowledgeType,
		&i.Subject,
		&i.Predicate,
		&i.Object,
		&i.Confidence,
		&i.SourceType,
		&i.SourceReferences,
		&i.Embedding,
		&i.ContradictionCount,
		&i.ConfirmationCount,
		&i.LastConfirmed,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateWorkingMemorySlot = `-- name: CreateWorkingMemorySlot :one

INSERT INTO working_memory (
    user_id,
    session_id,
    memory_slot,
    content_type,
    content,
    activation_level,
    linked_memories,
    expires_at
) VALUES (
    $1::uuid, $2, $3, $4, $5, $6, $7, $8
) ON CONFLICT (user_id, session_id, memory_slot)
DO UPDATE SET
    content_type = $4,
    content = $5,
    activation_level = $6,
    linked_memories = $7,
    reference_count = working_memory.reference_count + 1,
    last_accessed = NOW(),
    expires_at = $8
RETURNING id, user_id, session_id, memory_slot, content_type, content, activation_level, reference_count, linked_memories, created_at, last_accessed, expires_at
`

type CreateWorkingMemorySlotParams struct {
	Column1         pgtype.UUID        `json:"column_1"`
	SessionID       string             `json:"session_id"`
	MemorySlot      int32              `json:"memory_slot"`
	ContentType     string             `json:"content_type"`
	Content         []byte             `json:"content"`
	ActivationLevel pgtype.Float8      `json:"activation_level"`
	LinkedMemories  []pgtype.UUID      `json:"linked_memories"`
	ExpiresAt       pgtype.Timestamptz `json:"expires_at"`
}

// =====================================================
// WORKING MEMORY QUERIES
// =====================================================
func (q *Queries) CreateWorkingMemorySlot(ctx context.Context, arg CreateWorkingMemorySlotParams) (*WorkingMemory, error) {
	row := q.db.QueryRow(ctx, CreateWorkingMemorySlot,
		arg.Column1,
		arg.SessionID,
		arg.MemorySlot,
		arg.ContentType,
		arg.Content,
		arg.ActivationLevel,
		arg.LinkedMemories,
		arg.ExpiresAt,
	)
	var i WorkingMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.MemorySlot,
		&i.ContentType,
		&i.Content,
		&i.ActivationLevel,
		&i.ReferenceCount,
		&i.LinkedMemories,
		&i.CreatedAt,
		&i.LastAccessed,
		&i.ExpiresAt,
	)
	return &i, err
}

const DeactivateConflictingMemories = `-- name: DeactivateConflictingMemories :exec
UPDATE semantic_memories
SET is_active = false,
    updated_at = NOW()
WHERE user_id = $1::uuid
  AND subject = $2
  AND predicate = $3
  AND object != $4
  AND confidence < $5
`

type DeactivateConflictingMemoriesParams struct {
	Column1    pgtype.UUID `json:"column_1"`
	Subject    string      `json:"subject"`
	Predicate  string      `json:"predicate"`
	Object     []byte      `json:"object"`
	Confidence float64     `json:"confidence"`
}

func (q *Queries) DeactivateConflictingMemories(ctx context.Context, arg DeactivateConflictingMemoriesParams) error {
	_, err := q.db.Exec(ctx, DeactivateConflictingMemories,
		arg.Column1,
		arg.Subject,
		arg.Predicate,
		arg.Object,
		arg.Confidence,
	)
	return err
}

const DeleteDecayedMemories = `-- name: DeleteDecayedMemories :exec
DELETE FROM episodic_memories
WHERE user_id = $1::uuid
  AND vividness < $2
  AND importance < $3
  AND created_at < NOW() - INTERVAL '1 year'
`

type DeleteDecayedMemoriesParams struct {
	Column1    pgtype.UUID   `json:"column_1"`
	Vividness  pgtype.Float8 `json:"vividness"`
	Importance float64       `json:"importance"`
}

func (q *Queries) DeleteDecayedMemories(ctx context.Context, arg DeleteDecayedMemoriesParams) error {
	_, err := q.db.Exec(ctx, DeleteDecayedMemories, arg.Column1, arg.Vividness, arg.Importance)
	return err
}

const ExtendWorkingMemoryExpiry = `-- name: ExtendWorkingMemoryExpiry :one
UPDATE working_memory
SET expires_at = $2,
    last_accessed = NOW()
WHERE id = $1
RETURNING id, user_id, session_id, memory_slot, content_type, content, activation_level, reference_count, linked_memories, created_at, last_accessed, expires_at
`

type ExtendWorkingMemoryExpiryParams struct {
	ID        pgtype.UUID        `json:"id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) ExtendWorkingMemoryExpiry(ctx context.Context, arg ExtendWorkingMemoryExpiryParams) (*WorkingMemory, error) {
	row := q.db.QueryRow(ctx, ExtendWorkingMemoryExpiry, arg.ID, arg.ExpiresAt)
	var i WorkingMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.MemorySlot,
		&i.ContentType,
		&i.Content,
		&i.ActivationLevel,
		&i.ReferenceCount,
		&i.LinkedMemories,
		&i.CreatedAt,
		&i.LastAccessed,
		&i.ExpiresAt,
	)
	return &i, err
}

const GetAutomatableProcedures = `-- name: GetAutomatableProcedures :many
SELECT id, user_id, procedure_name, procedure_type, trigger_conditions, steps, prerequisites, expected_outcomes, success_rate, execution_count, average_duration_ms, optimization_history, is_automated, automation_confidence, last_executed, created_at, updated_at FROM procedural_memories
WHERE user_id = $1::uuid
  AND success_rate >= $2
  AND execution_count >= $3
  AND automation_confidence >= $4
  AND NOT is_automated
ORDER BY automation_confidence DESC, success_rate DESC
`

type GetAutomatableProceduresParams struct {
	Column1              pgtype.UUID   `json:"column_1"`
	SuccessRate          pgtype.Float8 `json:"success_rate"`
	ExecutionCount       pgtype.Int4   `json:"execution_count"`
	AutomationConfidence pgtype.Float8 `json:"automation_confidence"`
}

func (q *Queries) GetAutomatableProcedures(ctx context.Context, arg GetAutomatableProceduresParams) ([]*ProceduralMemory, error) {
	rows, err := q.db.Query(ctx, GetAutomatableProcedures,
		arg.Column1,
		arg.SuccessRate,
		arg.ExecutionCount,
		arg.AutomationConfidence,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProceduralMemory{}
	for rows.Next() {
		var i ProceduralMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProcedureName,
			&i.ProcedureType,
			&i.TriggerConditions,
			&i.Steps,
			&i.Prerequisites,
			&i.ExpectedOutcomes,
			&i.SuccessRate,
			&i.ExecutionCount,
			&i.AverageDurationMs,
			&i.OptimizationHistory,
			&i.IsAutomated,
			&i.AutomationConfidence,
			&i.LastExecuted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEpisodicMemories = `-- name: GetEpisodicMemories :many
SELECT id, user_id, episode_type, episode_summary, full_context, emotional_valence, importance, vividness, embedding, temporal_context, spatial_context, social_context, causal_links, access_count, last_accessed, created_at, decay_rate FROM episodic_memories
WHERE user_id = $1::uuid
  AND (episode_type = $2 OR $2 IS NULL)
  AND importance >= COALESCE($3, 0.0)
  AND vividness >= COALESCE($4, 0.0)
ORDER BY importance DESC, vividness DESC, created_at DESC
LIMIT $5 OFFSET $6
`

type GetEpisodicMemoriesParams struct {
	Column1     pgtype.UUID   `json:"column_1"`
	EpisodeType string        `json:"episode_type"`
	Importance  float64       `json:"importance"`
	Vividness   pgtype.Float8 `json:"vividness"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
}

func (q *Queries) GetEpisodicMemories(ctx context.Context, arg GetEpisodicMemoriesParams) ([]*EpisodicMemory, error) {
	rows, err := q.db.Query(ctx, GetEpisodicMemories,
		arg.Column1,
		arg.EpisodeType,
		arg.Importance,
		arg.Vividness,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EpisodicMemory{}
	for rows.Next() {
		var i EpisodicMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EpisodeType,
			&i.EpisodeSummary,
			&i.FullContext,
			&i.EmotionalValence,
			&i.Importance,
			&i.Vividness,
			&i.Embedding,
			&i.TemporalContext,
			&i.SpatialContext,
			&i.SocialContext,
			&i.CausalLinks,
			&i.AccessCount,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.DecayRate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEpisodicMemory = `-- name: GetEpisodicMemory :one
SELECT id, user_id, episode_type, episode_summary, full_context, emotional_valence, importance, vividness, embedding, temporal_context, spatial_context, social_context, causal_links, access_count, last_accessed, created_at, decay_rate FROM episodic_memories
WHERE id = $1
`

func (q *Queries) GetEpisodicMemory(ctx context.Context, id pgtype.UUID) (*EpisodicMemory, error) {
	row := q.db.QueryRow(ctx, GetEpisodicMemory, id)
	var i EpisodicMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeType,
		&i.EpisodeSummary,
		&i.FullContext,
		&i.EmotionalValence,
		&i.Importance,
		&i.Vividness,
		&i.Embedding,
		&i.TemporalContext,
		&i.SpatialContext,
		&i.SocialContext,
		&i.CausalLinks,
		&i.AccessCount,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.DecayRate,
	)
	return &i, err
}

const GetKnowledgeGraph = `-- name: GetKnowledgeGraph :many
SELECT 
    sm.subject,
    sm.predicate,
    sm.object,
    sm.confidence,
    sm.knowledge_type
FROM semantic_memories sm
WHERE sm.user_id = $1::uuid
  AND sm.is_active = true
  AND sm.confidence >= $2
ORDER BY sm.confidence DESC
`

type GetKnowledgeGraphParams struct {
	Column1    pgtype.UUID `json:"column_1"`
	Confidence float64     `json:"confidence"`
}

type GetKnowledgeGraphRow struct {
	Subject       string  `json:"subject"`
	Predicate     string  `json:"predicate"`
	Object        []byte  `json:"object"`
	Confidence    float64 `json:"confidence"`
	KnowledgeType string  `json:"knowledge_type"`
}

func (q *Queries) GetKnowledgeGraph(ctx context.Context, arg GetKnowledgeGraphParams) ([]*GetKnowledgeGraphRow, error) {
	rows, err := q.db.Query(ctx, GetKnowledgeGraph, arg.Column1, arg.Confidence)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetKnowledgeGraphRow{}
	for rows.Next() {
		var i GetKnowledgeGraphRow
		if err := rows.Scan(
			&i.Subject,
			&i.Predicate,
			&i.Object,
			&i.Confidence,
			&i.KnowledgeType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMemoriesByCausalLink = `-- name: GetMemoriesByCausalLink :many
SELECT id, user_id, episode_type, episode_summary, full_context, emotional_valence, importance, vividness, embedding, temporal_context, spatial_context, social_context, causal_links, access_count, last_accessed, created_at, decay_rate FROM episodic_memories
WHERE user_id = $1::uuid
  AND $2::uuid = ANY(causal_links)
ORDER BY importance DESC
`

type GetMemoriesByCausalLinkParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
}

func (q *Queries) GetMemoriesByCausalLink(ctx context.Context, arg GetMemoriesByCausalLinkParams) ([]*EpisodicMemory, error) {
	rows, err := q.db.Query(ctx, GetMemoriesByCausalLink, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EpisodicMemory{}
	for rows.Next() {
		var i EpisodicMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EpisodeType,
			&i.EpisodeSummary,
			&i.FullContext,
			&i.EmotionalValence,
			&i.Importance,
			&i.Vividness,
			&i.Embedding,
			&i.TemporalContext,
			&i.SpatialContext,
			&i.SocialContext,
			&i.CausalLinks,
			&i.AccessCount,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.DecayRate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMemoriesByTemporalContext = `-- name: GetMemoriesByTemporalContext :many
SELECT id, user_id, episode_type, episode_summary, full_context, emotional_valence, importance, vividness, embedding, temporal_context, spatial_context, social_context, causal_links, access_count, last_accessed, created_at, decay_rate FROM episodic_memories
WHERE user_id = $1::uuid
  AND temporal_context @> $2
ORDER BY importance DESC
LIMIT $3
`

type GetMemoriesByTemporalContextParams struct {
	Column1         pgtype.UUID `json:"column_1"`
	TemporalContext []byte      `json:"temporal_context"`
	Limit           int32       `json:"limit"`
}

func (q *Queries) GetMemoriesByTemporalContext(ctx context.Context, arg GetMemoriesByTemporalContextParams) ([]*EpisodicMemory, error) {
	rows, err := q.db.Query(ctx, GetMemoriesByTemporalContext, arg.Column1, arg.TemporalContext, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EpisodicMemory{}
	for rows.Next() {
		var i EpisodicMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EpisodeType,
			&i.EpisodeSummary,
			&i.FullContext,
			&i.EmotionalValence,
			&i.Importance,
			&i.Vividness,
			&i.Embedding,
			&i.TemporalContext,
			&i.SpatialContext,
			&i.SocialContext,
			&i.CausalLinks,
			&i.AccessCount,
			&i.LastAccessed,
			&i.CreatedAt,
			&i.DecayRate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMostActiveWorkingMemory = `-- name: GetMostActiveWorkingMemory :many
SELECT id, user_id, session_id, memory_slot, content_type, content, activation_level, reference_count, linked_memories, created_at, last_accessed, expires_at FROM working_memory
WHERE user_id = $1::uuid
  AND session_id = $2
  AND expires_at > NOW()
ORDER BY activation_level DESC, reference_count DESC
LIMIT $3
`

type GetMostActiveWorkingMemoryParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	SessionID string      `json:"session_id"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) GetMostActiveWorkingMemory(ctx context.Context, arg GetMostActiveWorkingMemoryParams) ([]*WorkingMemory, error) {
	rows, err := q.db.Query(ctx, GetMostActiveWorkingMemory, arg.Column1, arg.SessionID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WorkingMemory{}
	for rows.Next() {
		var i WorkingMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MemorySlot,
			&i.ContentType,
			&i.Content,
			&i.ActivationLevel,
			&i.ReferenceCount,
			&i.LinkedMemories,
			&i.CreatedAt,
			&i.LastAccessed,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProceduralMemories = `-- name: GetProceduralMemories :many
SELECT id, user_id, procedure_name, procedure_type, trigger_conditions, steps, prerequisites, expected_outcomes, success_rate, execution_count, average_duration_ms, optimization_history, is_automated, automation_confidence, last_executed, created_at, updated_at FROM procedural_memories
WHERE user_id = $1::uuid
  AND (procedure_type = $2 OR $2 IS NULL)
ORDER BY success_rate DESC, execution_count DESC
LIMIT $3 OFFSET $4
`

type GetProceduralMemoriesParams struct {
	Column1       pgtype.UUID `json:"column_1"`
	ProcedureType string      `json:"procedure_type"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

func (q *Queries) GetProceduralMemories(ctx context.Context, arg GetProceduralMemoriesParams) ([]*ProceduralMemory, error) {
	rows, err := q.db.Query(ctx, GetProceduralMemories,
		arg.Column1,
		arg.ProcedureType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProceduralMemory{}
	for rows.Next() {
		var i ProceduralMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProcedureName,
			&i.ProcedureType,
			&i.TriggerConditions,
			&i.Steps,
			&i.Prerequisites,
			&i.ExpectedOutcomes,
			&i.SuccessRate,
			&i.ExecutionCount,
			&i.AverageDurationMs,
			&i.OptimizationHistory,
			&i.IsAutomated,
			&i.AutomationConfidence,
			&i.LastExecuted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProceduralMemory = `-- name: GetProceduralMemory :one
SELECT id, user_id, procedure_name, procedure_type, trigger_conditions, steps, prerequisites, expected_outcomes, success_rate, execution_count, average_duration_ms, optimization_history, is_automated, automation_confidence, last_executed, created_at, updated_at FROM procedural_memories
WHERE id = $1
`

func (q *Queries) GetProceduralMemory(ctx context.Context, id pgtype.UUID) (*ProceduralMemory, error) {
	row := q.db.QueryRow(ctx, GetProceduralMemory, id)
	var i ProceduralMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProcedureName,
		&i.ProcedureType,
		&i.TriggerConditions,
		&i.Steps,
		&i.Prerequisites,
		&i.ExpectedOutcomes,
		&i.SuccessRate,
		&i.ExecutionCount,
		&i.AverageDurationMs,
		&i.OptimizationHistory,
		&i.IsAutomated,
		&i.AutomationConfidence,
		&i.LastExecuted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetSemanticMemories = `-- name: GetSemanticMemories :many
SELECT id, user_id, knowledge_type, subject, predicate, object, confidence, source_type, source_references, embedding, contradiction_count, confirmation_count, last_confirmed, is_active, created_at, updated_at FROM semantic_memories
WHERE user_id = $1::uuid
  AND (knowledge_type = ANY($2::text[]) OR $2 IS NULL)
  AND is_active = true
  AND confidence >= COALESCE($3, 0.0)
ORDER BY confidence DESC, updated_at DESC
LIMIT $4 OFFSET $5
`

type GetSemanticMemoriesParams struct {
	Column1    pgtype.UUID `json:"column_1"`
	Column2    []string    `json:"column_2"`
	Confidence float64     `json:"confidence"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) GetSemanticMemories(ctx context.Context, arg GetSemanticMemoriesParams) ([]*SemanticMemory, error) {
	rows, err := q.db.Query(ctx, GetSemanticMemories,
		arg.Column1,
		arg.Column2,
		arg.Confidence,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SemanticMemory{}
	for rows.Next() {
		var i SemanticMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KnowledgeType,
			&i.Subject,
			&i.Predicate,
			&i.Object,
			&i.Confidence,
			&i.SourceType,
			&i.SourceReferences,
			&i.Embedding,
			&i.ContradictionCount,
			&i.ConfirmationCount,
			&i.LastConfirmed,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSemanticMemory = `-- name: GetSemanticMemory :one
SELECT id, user_id, knowledge_type, subject, predicate, object, confidence, source_type, source_references, embedding, contradiction_count, confirmation_count, last_confirmed, is_active, created_at, updated_at FROM semantic_memories
WHERE id = $1
`

func (q *Queries) GetSemanticMemory(ctx context.Context, id pgtype.UUID) (*SemanticMemory, error) {
	row := q.db.QueryRow(ctx, GetSemanticMemory, id)
	var i SemanticMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KnowledgeType,
		&i.Subject,
		&i.Predicate,
		&i.Object,
		&i.Confidence,
		&i.SourceType,
		&i.SourceReferences,
		&i.Embedding,
		&i.ContradictionCount,
		&i.ConfirmationCount,
		&i.LastConfirmed,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetSemanticRelationships = `-- name: GetSemanticRelationships :many
SELECT id, user_id, knowledge_type, subject, predicate, object, confidence, source_type, source_references, embedding, contradiction_count, confirmation_count, last_confirmed, is_active, created_at, updated_at FROM semantic_memories
WHERE user_id = $1::uuid
  AND (subject ILIKE '%' || $2 || '%' OR object::text ILIKE '%' || $2 || '%')
  AND is_active = true
ORDER BY confidence DESC
`

type GetSemanticRelationshipsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.Text `json:"column_2"`
}

func (q *Queries) GetSemanticRelationships(ctx context.Context, arg GetSemanticRelationshipsParams) ([]*SemanticMemory, error) {
	rows, err := q.db.Query(ctx, GetSemanticRelationships, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SemanticMemory{}
	for rows.Next() {
		var i SemanticMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KnowledgeType,
			&i.Subject,
			&i.Predicate,
			&i.Object,
			&i.Confidence,
			&i.SourceType,
			&i.SourceReferences,
			&i.Embedding,
			&i.ContradictionCount,
			&i.ConfirmationCount,
			&i.LastConfirmed,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetWorkingMemory = `-- name: GetWorkingMemory :many
SELECT id, user_id, session_id, memory_slot, content_type, content, activation_level, reference_count, linked_memories, created_at, last_accessed, expires_at FROM working_memory
WHERE user_id = $1::uuid
  AND session_id = $2
  AND expires_at > NOW()
ORDER BY memory_slot
`

type GetWorkingMemoryParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	SessionID string      `json:"session_id"`
}

func (q *Queries) GetWorkingMemory(ctx context.Context, arg GetWorkingMemoryParams) ([]*WorkingMemory, error) {
	rows, err := q.db.Query(ctx, GetWorkingMemory, arg.Column1, arg.SessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WorkingMemory{}
	for rows.Next() {
		var i WorkingMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MemorySlot,
			&i.ContentType,
			&i.Content,
			&i.ActivationLevel,
			&i.ReferenceCount,
			&i.LinkedMemories,
			&i.CreatedAt,
			&i.LastAccessed,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetWorkingMemorySlot = `-- name: GetWorkingMemorySlot :one
SELECT id, user_id, session_id, memory_slot, content_type, content, activation_level, reference_count, linked_memories, created_at, last_accessed, expires_at FROM working_memory
WHERE user_id = $1::uuid
  AND session_id = $2
  AND memory_slot = $3
  AND expires_at > NOW()
`

type GetWorkingMemorySlotParams struct {
	Column1    pgtype.UUID `json:"column_1"`
	SessionID  string      `json:"session_id"`
	MemorySlot int32       `json:"memory_slot"`
}

func (q *Queries) GetWorkingMemorySlot(ctx context.Context, arg GetWorkingMemorySlotParams) (*WorkingMemory, error) {
	row := q.db.QueryRow(ctx, GetWorkingMemorySlot, arg.Column1, arg.SessionID, arg.MemorySlot)
	var i WorkingMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.MemorySlot,
		&i.ContentType,
		&i.Content,
		&i.ActivationLevel,
		&i.ReferenceCount,
		&i.LinkedMemories,
		&i.CreatedAt,
		&i.LastAccessed,
		&i.ExpiresAt,
	)
	return &i, err
}

const OptimizeProcedure = `-- name: OptimizeProcedure :one
UPDATE procedural_memories
SET steps = $2,
    optimization_history = optimization_history || jsonb_build_object(
        'timestamp', EXTRACT(EPOCH FROM NOW()),
        'old_steps', steps,
        'improvement_reason', $3,
        'performance_gain', $4
    ),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, procedure_name, procedure_type, trigger_conditions, steps, prerequisites, expected_outcomes, success_rate, execution_count, average_duration_ms, optimization_history, is_automated, automation_confidence, last_executed, created_at, updated_at
`

type OptimizeProcedureParams struct {
	ID                 pgtype.UUID `json:"id"`
	Steps              []byte      `json:"steps"`
	JsonbBuildObject   interface{} `json:"jsonb_build_object"`
	JsonbBuildObject_2 interface{} `json:"jsonb_build_object_2"`
}

func (q *Queries) OptimizeProcedure(ctx context.Context, arg OptimizeProcedureParams) (*ProceduralMemory, error) {
	row := q.db.QueryRow(ctx, OptimizeProcedure,
		arg.ID,
		arg.Steps,
		arg.JsonbBuildObject,
		arg.JsonbBuildObject_2,
	)
	var i ProceduralMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProcedureName,
		&i.ProcedureType,
		&i.TriggerConditions,
		&i.Steps,
		&i.Prerequisites,
		&i.ExpectedOutcomes,
		&i.SuccessRate,
		&i.ExecutionCount,
		&i.AverageDurationMs,
		&i.OptimizationHistory,
		&i.IsAutomated,
		&i.AutomationConfidence,
		&i.LastExecuted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const SearchEpisodicMemoriesBySimilarity = `-- name: SearchEpisodicMemoriesBySimilarity :many
SELECT 
    id,
    episode_type,
    episode_summary,
    importance,
    vividness,
    created_at,
    embedding <=> $2::vector as distance
FROM episodic_memories
WHERE user_id = $1::uuid
  AND embedding IS NOT NULL
ORDER BY embedding <=> $2::vector
LIMIT $3
`

type SearchEpisodicMemoriesBySimilarityParams struct {
	Column1 pgtype.UUID     `json:"column_1"`
	Column2 pgvector.Vector `json:"column_2"`
	Limit   int32           `json:"limit"`
}

type SearchEpisodicMemoriesBySimilarityRow struct {
	ID             pgtype.UUID   `json:"id"`
	EpisodeType    string        `json:"episode_type"`
	EpisodeSummary string        `json:"episode_summary"`
	Importance     float64       `json:"importance"`
	Vividness      pgtype.Float8 `json:"vividness"`
	CreatedAt      time.Time     `json:"created_at"`
	Distance       interface{}   `json:"distance"`
}

func (q *Queries) SearchEpisodicMemoriesBySimilarity(ctx context.Context, arg SearchEpisodicMemoriesBySimilarityParams) ([]*SearchEpisodicMemoriesBySimilarityRow, error) {
	rows, err := q.db.Query(ctx, SearchEpisodicMemoriesBySimilarity, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchEpisodicMemoriesBySimilarityRow{}
	for rows.Next() {
		var i SearchEpisodicMemoriesBySimilarityRow
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeType,
			&i.EpisodeSummary,
			&i.Importance,
			&i.Vividness,
			&i.CreatedAt,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchProceduralMemoriesByConditions = `-- name: SearchProceduralMemoriesByConditions :many
SELECT id, user_id, procedure_name, procedure_type, trigger_conditions, steps, prerequisites, expected_outcomes, success_rate, execution_count, average_duration_ms, optimization_history, is_automated, automation_confidence, last_executed, created_at, updated_at FROM procedural_memories
WHERE user_id = $1::uuid
  AND trigger_conditions @> $2
ORDER BY success_rate DESC, automation_confidence DESC
LIMIT $3
`

type SearchProceduralMemoriesByConditionsParams struct {
	Column1           pgtype.UUID `json:"column_1"`
	TriggerConditions []byte      `json:"trigger_conditions"`
	Limit             int32       `json:"limit"`
}

func (q *Queries) SearchProceduralMemoriesByConditions(ctx context.Context, arg SearchProceduralMemoriesByConditionsParams) ([]*ProceduralMemory, error) {
	rows, err := q.db.Query(ctx, SearchProceduralMemoriesByConditions, arg.Column1, arg.TriggerConditions, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProceduralMemory{}
	for rows.Next() {
		var i ProceduralMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProcedureName,
			&i.ProcedureType,
			&i.TriggerConditions,
			&i.Steps,
			&i.Prerequisites,
			&i.ExpectedOutcomes,
			&i.SuccessRate,
			&i.ExecutionCount,
			&i.AverageDurationMs,
			&i.OptimizationHistory,
			&i.IsAutomated,
			&i.AutomationConfidence,
			&i.LastExecuted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchSemanticMemoriesBySimilarity = `-- name: SearchSemanticMemoriesBySimilarity :many
SELECT 
    id,
    knowledge_type,
    subject,
    predicate,
    object,
    confidence,
    embedding <=> $2::vector as distance
FROM semantic_memories
WHERE user_id = $1::uuid
  AND embedding IS NOT NULL
  AND is_active = true
ORDER BY embedding <=> $2::vector
LIMIT $3
`

type SearchSemanticMemoriesBySimilarityParams struct {
	Column1 pgtype.UUID     `json:"column_1"`
	Column2 pgvector.Vector `json:"column_2"`
	Limit   int32           `json:"limit"`
}

type SearchSemanticMemoriesBySimilarityRow struct {
	ID            pgtype.UUID `json:"id"`
	KnowledgeType string      `json:"knowledge_type"`
	Subject       string      `json:"subject"`
	Predicate     string      `json:"predicate"`
	Object        []byte      `json:"object"`
	Confidence    float64     `json:"confidence"`
	Distance      interface{} `json:"distance"`
}

func (q *Queries) SearchSemanticMemoriesBySimilarity(ctx context.Context, arg SearchSemanticMemoriesBySimilarityParams) ([]*SearchSemanticMemoriesBySimilarityRow, error) {
	rows, err := q.db.Query(ctx, SearchSemanticMemoriesBySimilarity, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchSemanticMemoriesBySimilarityRow{}
	for rows.Next() {
		var i SearchSemanticMemoriesBySimilarityRow
		if err := rows.Scan(
			&i.ID,
			&i.KnowledgeType,
			&i.Subject,
			&i.Predicate,
			&i.Object,
			&i.Confidence,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchSemanticMemoriesBySubject = `-- name: SearchSemanticMemoriesBySubject :many
SELECT id, user_id, knowledge_type, subject, predicate, object, confidence, source_type, source_references, embedding, contradiction_count, confirmation_count, last_confirmed, is_active, created_at, updated_at FROM semantic_memories
WHERE user_id = $1::uuid
  AND to_tsvector('english', subject) @@ plainto_tsquery('english', $2)
  AND is_active = true
ORDER BY confidence DESC
LIMIT $3
`

type SearchSemanticMemoriesBySubjectParams struct {
	Column1        pgtype.UUID `json:"column_1"`
	PlaintoTsquery string      `json:"plainto_tsquery"`
	Limit          int32       `json:"limit"`
}

func (q *Queries) SearchSemanticMemoriesBySubject(ctx context.Context, arg SearchSemanticMemoriesBySubjectParams) ([]*SemanticMemory, error) {
	rows, err := q.db.Query(ctx, SearchSemanticMemoriesBySubject, arg.Column1, arg.PlaintoTsquery, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SemanticMemory{}
	for rows.Next() {
		var i SemanticMemory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KnowledgeType,
			&i.Subject,
			&i.Predicate,
			&i.Object,
			&i.Confidence,
			&i.SourceType,
			&i.SourceReferences,
			&i.Embedding,
			&i.ContradictionCount,
			&i.ConfirmationCount,
			&i.LastConfirmed,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateAutomationConfidence = `-- name: UpdateAutomationConfidence :one
UPDATE procedural_memories
SET automation_confidence = $2,
    is_automated = CASE WHEN $2 >= $3 THEN true ELSE is_automated END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, procedure_name, procedure_type, trigger_conditions, steps, prerequisites, expected_outcomes, success_rate, execution_count, average_duration_ms, optimization_history, is_automated, automation_confidence, last_executed, created_at, updated_at
`

type UpdateAutomationConfidenceParams struct {
	ID                   pgtype.UUID   `json:"id"`
	AutomationConfidence pgtype.Float8 `json:"automation_confidence"`
	Column3              interface{}   `json:"column_3"`
}

func (q *Queries) UpdateAutomationConfidence(ctx context.Context, arg UpdateAutomationConfidenceParams) (*ProceduralMemory, error) {
	row := q.db.QueryRow(ctx, UpdateAutomationConfidence, arg.ID, arg.AutomationConfidence, arg.Column3)
	var i ProceduralMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProcedureName,
		&i.ProcedureType,
		&i.TriggerConditions,
		&i.Steps,
		&i.Prerequisites,
		&i.ExpectedOutcomes,
		&i.SuccessRate,
		&i.ExecutionCount,
		&i.AverageDurationMs,
		&i.OptimizationHistory,
		&i.IsAutomated,
		&i.AutomationConfidence,
		&i.LastExecuted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateEpisodicMemoryAccess = `-- name: UpdateEpisodicMemoryAccess :one
UPDATE episodic_memories
SET access_count = access_count + 1,
    last_accessed = NOW(),
    vividness = vividness * (1 - decay_rate)
WHERE id = $1
RETURNING id, user_id, episode_type, episode_summary, full_context, emotional_valence, importance, vividness, embedding, temporal_context, spatial_context, social_context, causal_links, access_count, last_accessed, created_at, decay_rate
`

func (q *Queries) UpdateEpisodicMemoryAccess(ctx context.Context, id pgtype.UUID) (*EpisodicMemory, error) {
	row := q.db.QueryRow(ctx, UpdateEpisodicMemoryAccess, id)
	var i EpisodicMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeType,
		&i.EpisodeSummary,
		&i.FullContext,
		&i.EmotionalValence,
		&i.Importance,
		&i.Vividness,
		&i.Embedding,
		&i.TemporalContext,
		&i.SpatialContext,
		&i.SocialContext,
		&i.CausalLinks,
		&i.AccessCount,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.DecayRate,
	)
	return &i, err
}

const UpdateEpisodicMemoryImportance = `-- name: UpdateEpisodicMemoryImportance :one
UPDATE episodic_memories
SET importance = $2,
    vividness = GREATEST(vividness, $2 * 0.8) -- Boost vividness for important memories
WHERE id = $1
RETURNING id, user_id, episode_type, episode_summary, full_context, emotional_valence, importance, vividness, embedding, temporal_context, spatial_context, social_context, causal_links, access_count, last_accessed, created_at, decay_rate
`

type UpdateEpisodicMemoryImportanceParams struct {
	ID         pgtype.UUID `json:"id"`
	Importance float64     `json:"importance"`
}

func (q *Queries) UpdateEpisodicMemoryImportance(ctx context.Context, arg UpdateEpisodicMemoryImportanceParams) (*EpisodicMemory, error) {
	row := q.db.QueryRow(ctx, UpdateEpisodicMemoryImportance, arg.ID, arg.Importance)
	var i EpisodicMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EpisodeType,
		&i.EpisodeSummary,
		&i.FullContext,
		&i.EmotionalValence,
		&i.Importance,
		&i.Vividness,
		&i.Embedding,
		&i.TemporalContext,
		&i.SpatialContext,
		&i.SocialContext,
		&i.CausalLinks,
		&i.AccessCount,
		&i.LastAccessed,
		&i.CreatedAt,
		&i.DecayRate,
	)
	return &i, err
}

const UpdateProceduralExecution = `-- name: UpdateProceduralExecution :one
UPDATE procedural_memories
SET execution_count = execution_count + 1,
    success_rate = (success_rate * execution_count + CASE WHEN $2 THEN 1.0 ELSE 0.0 END) / (execution_count + 1),
    average_duration_ms = CASE 
        WHEN $3 IS NOT NULL THEN 
            (COALESCE(average_duration_ms, 0) * execution_count + $3) / (execution_count + 1)
        ELSE average_duration_ms
    END,
    last_executed = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, procedure_name, procedure_type, trigger_conditions, steps, prerequisites, expected_outcomes, success_rate, execution_count, average_duration_ms, optimization_history, is_automated, automation_confidence, last_executed, created_at, updated_at
`

type UpdateProceduralExecutionParams struct {
	ID                pgtype.UUID   `json:"id"`
	SuccessRate       pgtype.Float8 `json:"success_rate"`
	AverageDurationMs pgtype.Int4   `json:"average_duration_ms"`
}

func (q *Queries) UpdateProceduralExecution(ctx context.Context, arg UpdateProceduralExecutionParams) (*ProceduralMemory, error) {
	row := q.db.QueryRow(ctx, UpdateProceduralExecution, arg.ID, arg.SuccessRate, arg.AverageDurationMs)
	var i ProceduralMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProcedureName,
		&i.ProcedureType,
		&i.TriggerConditions,
		&i.Steps,
		&i.Prerequisites,
		&i.ExpectedOutcomes,
		&i.SuccessRate,
		&i.ExecutionCount,
		&i.AverageDurationMs,
		&i.OptimizationHistory,
		&i.IsAutomated,
		&i.AutomationConfidence,
		&i.LastExecuted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSemanticMemoryConfidence = `-- name: UpdateSemanticMemoryConfidence :one
UPDATE semantic_memories
SET confidence = $2,
    confirmation_count = confirmation_count + CASE WHEN $3 THEN 1 ELSE 0 END,
    contradiction_count = contradiction_count + CASE WHEN NOT $3 THEN 1 ELSE 0 END,
    last_confirmed = CASE WHEN $3 THEN NOW() ELSE last_confirmed END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, knowledge_type, subject, predicate, object, confidence, source_type, source_references, embedding, contradiction_count, confirmation_count, last_confirmed, is_active, created_at, updated_at
`

type UpdateSemanticMemoryConfidenceParams struct {
	ID                pgtype.UUID `json:"id"`
	Confidence        float64     `json:"confidence"`
	ConfirmationCount pgtype.Int4 `json:"confirmation_count"`
}

func (q *Queries) UpdateSemanticMemoryConfidence(ctx context.Context, arg UpdateSemanticMemoryConfidenceParams) (*SemanticMemory, error) {
	row := q.db.QueryRow(ctx, UpdateSemanticMemoryConfidence, arg.ID, arg.Confidence, arg.ConfirmationCount)
	var i SemanticMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KnowledgeType,
		&i.Subject,
		&i.Predicate,
		&i.Object,
		&i.Confidence,
		&i.SourceType,
		&i.SourceReferences,
		&i.Embedding,
		&i.ContradictionCount,
		&i.ConfirmationCount,
		&i.LastConfirmed,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateWorkingMemoryActivation = `-- name: UpdateWorkingMemoryActivation :one
UPDATE working_memory
SET activation_level = $2,
    reference_count = reference_count + 1,
    last_accessed = NOW()
WHERE id = $1
RETURNING id, user_id, session_id, memory_slot, content_type, content, activation_level, reference_count, linked_memories, created_at, last_accessed, expires_at
`

type UpdateWorkingMemoryActivationParams struct {
	ID              pgtype.UUID   `json:"id"`
	ActivationLevel pgtype.Float8 `json:"activation_level"`
}

func (q *Queries) UpdateWorkingMemoryActivation(ctx context.Context, arg UpdateWorkingMemoryActivationParams) (*WorkingMemory, error) {
	row := q.db.QueryRow(ctx, UpdateWorkingMemoryActivation, arg.ID, arg.ActivationLevel)
	var i WorkingMemory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.MemorySlot,
		&i.ContentType,
		&i.Content,
		&i.ActivationLevel,
		&i.ReferenceCount,
		&i.LinkedMemories,
		&i.CreatedAt,
		&i.LastAccessed,
		&i.ExpiresAt,
	)
	return &i, err
}
