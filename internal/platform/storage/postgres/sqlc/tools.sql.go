// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tools.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateToolExecution = `-- name: CreateToolExecution :one

INSERT INTO tool_executions (
    tool_name, message_id, status, input_data, output_data, 
    error_message, execution_time_ms, started_at, completed_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, message_id, tool_name, input_data, output_data, status, error_message, execution_time_ms, started_at, completed_at
`

type CreateToolExecutionParams struct {
	ToolName        string             `json:"tool_name"`
	MessageID       pgtype.UUID        `json:"message_id"`
	Status          string             `json:"status"`
	InputData       []byte             `json:"input_data"`
	OutputData      []byte             `json:"output_data"`
	ErrorMessage    pgtype.Text        `json:"error_message"`
	ExecutionTimeMs pgtype.Int4        `json:"execution_time_ms"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
}

// Tools and tool execution related queries
func (q *Queries) CreateToolExecution(ctx context.Context, arg CreateToolExecutionParams) (*ToolExecution, error) {
	row := q.db.QueryRow(ctx, CreateToolExecution,
		arg.ToolName,
		arg.MessageID,
		arg.Status,
		arg.InputData,
		arg.OutputData,
		arg.ErrorMessage,
		arg.ExecutionTimeMs,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i ToolExecution
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ToolName,
		&i.InputData,
		&i.OutputData,
		&i.Status,
		&i.ErrorMessage,
		&i.ExecutionTimeMs,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const DeleteOldToolExecutions = `-- name: DeleteOldToolExecutions :exec
DELETE FROM tool_executions
WHERE started_at < $1
`

func (q *Queries) DeleteOldToolExecutions(ctx context.Context, startedAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, DeleteOldToolExecutions, startedAt)
	return err
}

const GetMostUsedTools = `-- name: GetMostUsedTools :many
SELECT 
    te.tool_name,
    COUNT(*)::integer as usage_count,
    MAX(te.started_at) as last_used
FROM tool_executions te
JOIN messages m ON te.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE c.user_id = $1
GROUP BY te.tool_name
ORDER BY usage_count DESC
LIMIT $2
`

type GetMostUsedToolsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

type GetMostUsedToolsRow struct {
	ToolName   string      `json:"tool_name"`
	UsageCount int32       `json:"usage_count"`
	LastUsed   interface{} `json:"last_used"`
}

func (q *Queries) GetMostUsedTools(ctx context.Context, arg GetMostUsedToolsParams) ([]*GetMostUsedToolsRow, error) {
	rows, err := q.db.Query(ctx, GetMostUsedTools, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMostUsedToolsRow{}
	for rows.Next() {
		var i GetMostUsedToolsRow
		if err := rows.Scan(&i.ToolName, &i.UsageCount, &i.LastUsed); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecentToolExecutions = `-- name: GetRecentToolExecutions :many
SELECT te.id, te.message_id, te.tool_name, te.input_data, te.output_data, te.status, te.error_message, te.execution_time_ms, te.started_at, te.completed_at
FROM tool_executions te
JOIN messages m ON te.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE c.user_id = $1
ORDER BY te.started_at DESC
LIMIT $2
`

type GetRecentToolExecutionsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetRecentToolExecutions(ctx context.Context, arg GetRecentToolExecutionsParams) ([]*ToolExecution, error) {
	rows, err := q.db.Query(ctx, GetRecentToolExecutions, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.InputData,
			&i.OutputData,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetToolExecution = `-- name: GetToolExecution :one
SELECT id, message_id, tool_name, input_data, output_data, status, error_message, execution_time_ms, started_at, completed_at
FROM tool_executions
WHERE id = $1
`

func (q *Queries) GetToolExecution(ctx context.Context, id pgtype.UUID) (*ToolExecution, error) {
	row := q.db.QueryRow(ctx, GetToolExecution, id)
	var i ToolExecution
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ToolName,
		&i.InputData,
		&i.OutputData,
		&i.Status,
		&i.ErrorMessage,
		&i.ExecutionTimeMs,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const GetToolExecutionCount = `-- name: GetToolExecutionCount :one
SELECT COUNT(*)::integer FROM tool_executions te
JOIN messages m ON te.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE c.user_id = $1
  AND ($2::text IS NULL OR te.tool_name = $2)
`

type GetToolExecutionCountParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	ToolName pgtype.Text `json:"tool_name"`
}

func (q *Queries) GetToolExecutionCount(ctx context.Context, arg GetToolExecutionCountParams) (int32, error) {
	row := q.db.QueryRow(ctx, GetToolExecutionCount, arg.UserID, arg.ToolName)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const GetToolExecutionTrends = `-- name: GetToolExecutionTrends :many
SELECT 
    DATE(te.started_at) as execution_date,
    te.tool_name,
    COUNT(*)::integer as executions,
    COUNT(CASE WHEN te.status = 'completed' THEN 1 END)::integer as successes,
    COUNT(CASE WHEN te.status = 'failed' THEN 1 END)::integer as failures
FROM tool_executions te
JOIN messages m ON te.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE c.user_id = $1
  AND te.started_at >= $2
  AND te.started_at <= $3
GROUP BY DATE(te.started_at), te.tool_name
ORDER BY execution_date DESC, executions DESC
`

type GetToolExecutionTrendsParams struct {
	UserID      pgtype.UUID        `json:"user_id"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	StartedAt_2 pgtype.Timestamptz `json:"started_at_2"`
}

type GetToolExecutionTrendsRow struct {
	ExecutionDate pgtype.Date `json:"execution_date"`
	ToolName      string      `json:"tool_name"`
	Executions    int32       `json:"executions"`
	Successes     int32       `json:"successes"`
	Failures      int32       `json:"failures"`
}

func (q *Queries) GetToolExecutionTrends(ctx context.Context, arg GetToolExecutionTrendsParams) ([]*GetToolExecutionTrendsRow, error) {
	rows, err := q.db.Query(ctx, GetToolExecutionTrends, arg.UserID, arg.StartedAt, arg.StartedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetToolExecutionTrendsRow{}
	for rows.Next() {
		var i GetToolExecutionTrendsRow
		if err := rows.Scan(
			&i.ExecutionDate,
			&i.ToolName,
			&i.Executions,
			&i.Successes,
			&i.Failures,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetToolExecutionsByMessage = `-- name: GetToolExecutionsByMessage :many
SELECT id, message_id, tool_name, input_data, output_data, status, error_message, execution_time_ms, started_at, completed_at
FROM tool_executions
WHERE message_id = $1
ORDER BY started_at ASC
`

func (q *Queries) GetToolExecutionsByMessage(ctx context.Context, messageID pgtype.UUID) ([]*ToolExecution, error) {
	rows, err := q.db.Query(ctx, GetToolExecutionsByMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.InputData,
			&i.OutputData,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetToolExecutionsByStatus = `-- name: GetToolExecutionsByStatus :many
SELECT te.id, te.message_id, te.tool_name, te.input_data, te.output_data, te.status, te.error_message, te.execution_time_ms, te.started_at, te.completed_at
FROM tool_executions te
JOIN messages m ON te.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE c.user_id = $1
  AND te.status = $2
ORDER BY te.started_at DESC
LIMIT $3 OFFSET $4
`

type GetToolExecutionsByStatusParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Status string      `json:"status"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetToolExecutionsByStatus(ctx context.Context, arg GetToolExecutionsByStatusParams) ([]*ToolExecution, error) {
	rows, err := q.db.Query(ctx, GetToolExecutionsByStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.InputData,
			&i.OutputData,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetToolExecutionsByTool = `-- name: GetToolExecutionsByTool :many
SELECT te.id, te.message_id, te.tool_name, te.input_data, te.output_data, te.status, te.error_message, te.execution_time_ms, te.started_at, te.completed_at
FROM tool_executions te
JOIN messages m ON te.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE te.tool_name = $1
  AND ($4::uuid IS NULL OR c.user_id = $4)
ORDER BY te.started_at DESC
LIMIT $2 OFFSET $3
`

type GetToolExecutionsByToolParams struct {
	ToolName string      `json:"tool_name"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	UserID   pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetToolExecutionsByTool(ctx context.Context, arg GetToolExecutionsByToolParams) ([]*ToolExecution, error) {
	rows, err := q.db.Query(ctx, GetToolExecutionsByTool,
		arg.ToolName,
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.InputData,
			&i.OutputData,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetToolExecutionsByUser = `-- name: GetToolExecutionsByUser :many
SELECT te.id, te.message_id, te.tool_name, te.input_data, te.output_data, te.status, te.error_message, te.execution_time_ms, te.started_at, te.completed_at
FROM tool_executions te
JOIN messages m ON te.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE c.user_id = $1
  AND ($4::text IS NULL OR te.tool_name = $4)
ORDER BY te.started_at DESC
LIMIT $2 OFFSET $3
`

type GetToolExecutionsByUserParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	ToolName pgtype.Text `json:"tool_name"`
}

func (q *Queries) GetToolExecutionsByUser(ctx context.Context, arg GetToolExecutionsByUserParams) ([]*ToolExecution, error) {
	rows, err := q.db.Query(ctx, GetToolExecutionsByUser,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.ToolName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.InputData,
			&i.OutputData,
			&i.Status,
			&i.ErrorMessage,
			&i.ExecutionTimeMs,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetToolUsageStats = `-- name: GetToolUsageStats :many
SELECT 
    te.tool_name,
    COUNT(*)::integer as total_executions,
    COUNT(CASE WHEN te.status = 'completed' THEN 1 END)::integer as success_count,
    COUNT(CASE WHEN te.status = 'failed' THEN 1 END)::integer as failure_count,
    ROUND(
        COUNT(CASE WHEN te.status = 'completed' THEN 1 END)::numeric * 100.0 / 
        NULLIF(COUNT(*), 0), 2
    )::float as success_rate,
    COALESCE(AVG(te.execution_time_ms)::integer, 0) as avg_execution_time_ms,
    MAX(te.started_at) as last_used
FROM tool_executions te
JOIN messages m ON te.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE c.user_id = $1
GROUP BY te.tool_name
ORDER BY total_executions DESC
`

type GetToolUsageStatsRow struct {
	ToolName           string      `json:"tool_name"`
	TotalExecutions    int32       `json:"total_executions"`
	SuccessCount       int32       `json:"success_count"`
	FailureCount       int32       `json:"failure_count"`
	SuccessRate        float64     `json:"success_rate"`
	AvgExecutionTimeMs interface{} `json:"avg_execution_time_ms"`
	LastUsed           interface{} `json:"last_used"`
}

func (q *Queries) GetToolUsageStats(ctx context.Context, userID pgtype.UUID) ([]*GetToolUsageStatsRow, error) {
	rows, err := q.db.Query(ctx, GetToolUsageStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetToolUsageStatsRow{}
	for rows.Next() {
		var i GetToolUsageStatsRow
		if err := rows.Scan(
			&i.ToolName,
			&i.TotalExecutions,
			&i.SuccessCount,
			&i.FailureCount,
			&i.SuccessRate,
			&i.AvgExecutionTimeMs,
			&i.LastUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetToolUsageStatsByTool = `-- name: GetToolUsageStatsByTool :one
SELECT 
    te.tool_name,
    COUNT(*)::integer as total_executions,
    COUNT(CASE WHEN te.status = 'completed' THEN 1 END)::integer as success_count,
    COUNT(CASE WHEN te.status = 'failed' THEN 1 END)::integer as failure_count,
    ROUND(
        COUNT(CASE WHEN te.status = 'completed' THEN 1 END)::numeric * 100.0 / 
        NULLIF(COUNT(*), 0), 2
    )::float as success_rate,
    COALESCE(AVG(te.execution_time_ms)::integer, 0) as avg_execution_time_ms,
    MAX(te.started_at) as last_used
FROM tool_executions te
JOIN messages m ON te.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE te.tool_name = $1 
  AND ($2::uuid IS NULL OR c.user_id = $2)
GROUP BY te.tool_name
`

type GetToolUsageStatsByToolParams struct {
	ToolName string      `json:"tool_name"`
	UserID   pgtype.UUID `json:"user_id"`
}

type GetToolUsageStatsByToolRow struct {
	ToolName           string      `json:"tool_name"`
	TotalExecutions    int32       `json:"total_executions"`
	SuccessCount       int32       `json:"success_count"`
	FailureCount       int32       `json:"failure_count"`
	SuccessRate        float64     `json:"success_rate"`
	AvgExecutionTimeMs interface{} `json:"avg_execution_time_ms"`
	LastUsed           interface{} `json:"last_used"`
}

func (q *Queries) GetToolUsageStatsByTool(ctx context.Context, arg GetToolUsageStatsByToolParams) (*GetToolUsageStatsByToolRow, error) {
	row := q.db.QueryRow(ctx, GetToolUsageStatsByTool, arg.ToolName, arg.UserID)
	var i GetToolUsageStatsByToolRow
	err := row.Scan(
		&i.ToolName,
		&i.TotalExecutions,
		&i.SuccessCount,
		&i.FailureCount,
		&i.SuccessRate,
		&i.AvgExecutionTimeMs,
		&i.LastUsed,
	)
	return &i, err
}

const UpdateToolExecutionStatus = `-- name: UpdateToolExecutionStatus :one
UPDATE tool_executions
SET 
    status = $2,
    output_data = $3,
    error_message = $4,
    execution_time_ms = $5,
    completed_at = $6
WHERE id = $1
RETURNING id, message_id, tool_name, input_data, output_data, status, error_message, execution_time_ms, started_at, completed_at
`

type UpdateToolExecutionStatusParams struct {
	ID              pgtype.UUID        `json:"id"`
	Status          string             `json:"status"`
	OutputData      []byte             `json:"output_data"`
	ErrorMessage    pgtype.Text        `json:"error_message"`
	ExecutionTimeMs pgtype.Int4        `json:"execution_time_ms"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) UpdateToolExecutionStatus(ctx context.Context, arg UpdateToolExecutionStatusParams) (*ToolExecution, error) {
	row := q.db.QueryRow(ctx, UpdateToolExecutionStatus,
		arg.ID,
		arg.Status,
		arg.OutputData,
		arg.ErrorMessage,
		arg.ExecutionTimeMs,
		arg.CompletedAt,
	)
	var i ToolExecution
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ToolName,
		&i.InputData,
		&i.OutputData,
		&i.Status,
		&i.ErrorMessage,
		&i.ExecutionTimeMs,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}
