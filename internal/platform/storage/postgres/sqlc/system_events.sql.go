// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: system_events.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateEventProjection = `-- name: CreateEventProjection :one

INSERT INTO event_projections (
    projection_name,
    projection_state
) VALUES (
    $1, $2
) ON CONFLICT (projection_name)
DO UPDATE SET
    projection_state = $2,
    updated_at = NOW()
RETURNING id, projection_name, last_processed_event_id, last_processed_at, projection_state, error_count, last_error, created_at, updated_at
`

type CreateEventProjectionParams struct {
	ProjectionName  string `json:"projection_name"`
	ProjectionState []byte `json:"projection_state"`
}

// =====================================================
// EVENT PROJECTIONS QUERIES
// =====================================================
func (q *Queries) CreateEventProjection(ctx context.Context, arg CreateEventProjectionParams) (*EventProjection, error) {
	row := q.db.QueryRow(ctx, CreateEventProjection, arg.ProjectionName, arg.ProjectionState)
	var i EventProjection
	err := row.Scan(
		&i.ID,
		&i.ProjectionName,
		&i.LastProcessedEventID,
		&i.LastProcessedAt,
		&i.ProjectionState,
		&i.ErrorCount,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateSystemEvent = `-- name: CreateSystemEvent :one


INSERT INTO system_events (
    event_type,
    aggregate_type,
    aggregate_id,
    user_id,
    event_data,
    event_metadata,
    event_version
) VALUES (
    $1, $2, $3::uuid, $4::uuid, $5, $6, $7
) RETURNING id, event_type, aggregate_type, aggregate_id, user_id, event_data, event_metadata, event_version, created_at, processed_at, processing_error
`

type CreateSystemEventParams struct {
	EventType     string      `json:"event_type"`
	AggregateType string      `json:"aggregate_type"`
	Column3       pgtype.UUID `json:"column_3"`
	Column4       pgtype.UUID `json:"column_4"`
	EventData     []byte      `json:"event_data"`
	EventMetadata []byte      `json:"event_metadata"`
	EventVersion  int32       `json:"event_version"`
}

// System events and event sourcing queries
// =====================================================
// SYSTEM EVENTS QUERIES
// =====================================================
func (q *Queries) CreateSystemEvent(ctx context.Context, arg CreateSystemEventParams) (*SystemEvent, error) {
	row := q.db.QueryRow(ctx, CreateSystemEvent,
		arg.EventType,
		arg.AggregateType,
		arg.Column3,
		arg.Column4,
		arg.EventData,
		arg.EventMetadata,
		arg.EventVersion,
	)
	var i SystemEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.AggregateType,
		&i.AggregateID,
		&i.UserID,
		&i.EventData,
		&i.EventMetadata,
		&i.EventVersion,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ProcessingError,
	)
	return &i, err
}

const DeleteOldEvents = `-- name: DeleteOldEvents :exec
DELETE FROM system_events
WHERE created_at < $1
  AND processed_at IS NOT NULL
`

func (q *Queries) DeleteOldEvents(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.Exec(ctx, DeleteOldEvents, createdAt)
	return err
}

const GetAllEventProjections = `-- name: GetAllEventProjections :many
SELECT id, projection_name, last_processed_event_id, last_processed_at, projection_state, error_count, last_error, created_at, updated_at FROM event_projections
ORDER BY projection_name
`

func (q *Queries) GetAllEventProjections(ctx context.Context) ([]*EventProjection, error) {
	rows, err := q.db.Query(ctx, GetAllEventProjections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*EventProjection{}
	for rows.Next() {
		var i EventProjection
		if err := rows.Scan(
			&i.ID,
			&i.ProjectionName,
			&i.LastProcessedEventID,
			&i.LastProcessedAt,
			&i.ProjectionState,
			&i.ErrorCount,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEventProjection = `-- name: GetEventProjection :one
SELECT id, projection_name, last_processed_event_id, last_processed_at, projection_state, error_count, last_error, created_at, updated_at FROM event_projections
WHERE projection_name = $1
`

func (q *Queries) GetEventProjection(ctx context.Context, projectionName string) (*EventProjection, error) {
	row := q.db.QueryRow(ctx, GetEventProjection, projectionName)
	var i EventProjection
	err := row.Scan(
		&i.ID,
		&i.ProjectionName,
		&i.LastProcessedEventID,
		&i.LastProcessedAt,
		&i.ProjectionState,
		&i.ErrorCount,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetEventStatistics = `-- name: GetEventStatistics :one
SELECT 
    event_type,
    COUNT(*) as total_events,
    COUNT(*) FILTER (WHERE processed_at IS NOT NULL) as processed_events,
    COUNT(*) FILTER (WHERE processing_error IS NOT NULL) as failed_events,
    MAX(created_at) as latest_event,
    MIN(created_at) as earliest_event
FROM system_events
WHERE (user_id = $1::uuid OR $1 IS NULL)
  AND created_at >= COALESCE($2, NOW() - INTERVAL '7 days')
GROUP BY event_type
ORDER BY total_events DESC
`

type GetEventStatisticsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
}

type GetEventStatisticsRow struct {
	EventType       string      `json:"event_type"`
	TotalEvents     int64       `json:"total_events"`
	ProcessedEvents int64       `json:"processed_events"`
	FailedEvents    int64       `json:"failed_events"`
	LatestEvent     interface{} `json:"latest_event"`
	EarliestEvent   interface{} `json:"earliest_event"`
}

func (q *Queries) GetEventStatistics(ctx context.Context, arg GetEventStatisticsParams) (*GetEventStatisticsRow, error) {
	row := q.db.QueryRow(ctx, GetEventStatistics, arg.Column1, arg.CreatedAt)
	var i GetEventStatisticsRow
	err := row.Scan(
		&i.EventType,
		&i.TotalEvents,
		&i.ProcessedEvents,
		&i.FailedEvents,
		&i.LatestEvent,
		&i.EarliestEvent,
	)
	return &i, err
}

const GetEventsByAggregate = `-- name: GetEventsByAggregate :many
SELECT id, event_type, aggregate_type, aggregate_id, user_id, event_data, event_metadata, event_version, created_at, processed_at, processing_error FROM system_events
WHERE aggregate_type = $1
  AND aggregate_id = $2::uuid
ORDER BY event_version ASC, created_at ASC
`

type GetEventsByAggregateParams struct {
	AggregateType string      `json:"aggregate_type"`
	Column2       pgtype.UUID `json:"column_2"`
}

func (q *Queries) GetEventsByAggregate(ctx context.Context, arg GetEventsByAggregateParams) ([]*SystemEvent, error) {
	rows, err := q.db.Query(ctx, GetEventsByAggregate, arg.AggregateType, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SystemEvent{}
	for rows.Next() {
		var i SystemEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.AggregateType,
			&i.AggregateID,
			&i.UserID,
			&i.EventData,
			&i.EventMetadata,
			&i.EventVersion,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEventsByType = `-- name: GetEventsByType :many
SELECT id, event_type, aggregate_type, aggregate_id, user_id, event_data, event_metadata, event_version, created_at, processed_at, processing_error FROM system_events
WHERE event_type = $1
  AND (user_id = $2::uuid OR $2 IS NULL)
  AND created_at >= COALESCE($3, NOW() - INTERVAL '30 days')
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type GetEventsByTypeParams struct {
	EventType string      `json:"event_type"`
	Column2   pgtype.UUID `json:"column_2"`
	CreatedAt time.Time   `json:"created_at"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) GetEventsByType(ctx context.Context, arg GetEventsByTypeParams) ([]*SystemEvent, error) {
	rows, err := q.db.Query(ctx, GetEventsByType,
		arg.EventType,
		arg.Column2,
		arg.CreatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SystemEvent{}
	for rows.Next() {
		var i SystemEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.AggregateType,
			&i.AggregateID,
			&i.UserID,
			&i.EventData,
			&i.EventMetadata,
			&i.EventVersion,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProjectionStatus = `-- name: GetProjectionStatus :one
SELECT 
    ep.projection_name,
    ep.last_processed_at,
    ep.error_count,
    ep.last_error,
    COUNT(se.id) as pending_events
FROM event_projections ep
LEFT JOIN system_events se ON se.id > COALESCE(ep.last_processed_event_id, '00000000-0000-0000-0000-000000000000'::uuid)
  AND se.processed_at IS NOT NULL
WHERE ep.projection_name = $1
GROUP BY ep.projection_name, ep.last_processed_at, ep.error_count, ep.last_error
`

type GetProjectionStatusRow struct {
	ProjectionName  string             `json:"projection_name"`
	LastProcessedAt pgtype.Timestamptz `json:"last_processed_at"`
	ErrorCount      pgtype.Int4        `json:"error_count"`
	LastError       pgtype.Text        `json:"last_error"`
	PendingEvents   int64              `json:"pending_events"`
}

func (q *Queries) GetProjectionStatus(ctx context.Context, projectionName string) (*GetProjectionStatusRow, error) {
	row := q.db.QueryRow(ctx, GetProjectionStatus, projectionName)
	var i GetProjectionStatusRow
	err := row.Scan(
		&i.ProjectionName,
		&i.LastProcessedAt,
		&i.ErrorCount,
		&i.LastError,
		&i.PendingEvents,
	)
	return &i, err
}

const GetRecentEvents = `-- name: GetRecentEvents :many
SELECT id, event_type, aggregate_type, aggregate_id, user_id, event_data, event_metadata, event_version, created_at, processed_at, processing_error FROM system_events
WHERE (user_id = $1::uuid OR $1 IS NULL)
  AND created_at >= COALESCE($2, NOW() - INTERVAL '24 hours')
ORDER BY created_at DESC
LIMIT $3
`

type GetRecentEventsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	CreatedAt time.Time   `json:"created_at"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) GetRecentEvents(ctx context.Context, arg GetRecentEventsParams) ([]*SystemEvent, error) {
	rows, err := q.db.Query(ctx, GetRecentEvents, arg.Column1, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SystemEvent{}
	for rows.Next() {
		var i SystemEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.AggregateType,
			&i.AggregateID,
			&i.UserID,
			&i.EventData,
			&i.EventMetadata,
			&i.EventVersion,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSystemEvent = `-- name: GetSystemEvent :one
SELECT id, event_type, aggregate_type, aggregate_id, user_id, event_data, event_metadata, event_version, created_at, processed_at, processing_error FROM system_events
WHERE id = $1
`

func (q *Queries) GetSystemEvent(ctx context.Context, id pgtype.UUID) (*SystemEvent, error) {
	row := q.db.QueryRow(ctx, GetSystemEvent, id)
	var i SystemEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.AggregateType,
		&i.AggregateID,
		&i.UserID,
		&i.EventData,
		&i.EventMetadata,
		&i.EventVersion,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ProcessingError,
	)
	return &i, err
}

const GetUnprocessedEvents = `-- name: GetUnprocessedEvents :many
SELECT id, event_type, aggregate_type, aggregate_id, user_id, event_data, event_metadata, event_version, created_at, processed_at, processing_error FROM system_events
WHERE processed_at IS NULL
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetUnprocessedEvents(ctx context.Context, limit int32) ([]*SystemEvent, error) {
	rows, err := q.db.Query(ctx, GetUnprocessedEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SystemEvent{}
	for rows.Next() {
		var i SystemEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.AggregateType,
			&i.AggregateID,
			&i.UserID,
			&i.EventData,
			&i.EventMetadata,
			&i.EventVersion,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ProcessingError,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkEventFailed = `-- name: MarkEventFailed :one
UPDATE system_events
SET processing_error = $2
WHERE id = $1
RETURNING id, event_type, aggregate_type, aggregate_id, user_id, event_data, event_metadata, event_version, created_at, processed_at, processing_error
`

type MarkEventFailedParams struct {
	ID              pgtype.UUID `json:"id"`
	ProcessingError pgtype.Text `json:"processing_error"`
}

func (q *Queries) MarkEventFailed(ctx context.Context, arg MarkEventFailedParams) (*SystemEvent, error) {
	row := q.db.QueryRow(ctx, MarkEventFailed, arg.ID, arg.ProcessingError)
	var i SystemEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.AggregateType,
		&i.AggregateID,
		&i.UserID,
		&i.EventData,
		&i.EventMetadata,
		&i.EventVersion,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ProcessingError,
	)
	return &i, err
}

const MarkEventProcessed = `-- name: MarkEventProcessed :one
UPDATE system_events
SET processed_at = NOW()
WHERE id = $1
RETURNING id, event_type, aggregate_type, aggregate_id, user_id, event_data, event_metadata, event_version, created_at, processed_at, processing_error
`

func (q *Queries) MarkEventProcessed(ctx context.Context, id pgtype.UUID) (*SystemEvent, error) {
	row := q.db.QueryRow(ctx, MarkEventProcessed, id)
	var i SystemEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.AggregateType,
		&i.AggregateID,
		&i.UserID,
		&i.EventData,
		&i.EventMetadata,
		&i.EventVersion,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ProcessingError,
	)
	return &i, err
}

const RecordProjectionError = `-- name: RecordProjectionError :one
UPDATE event_projections
SET error_count = error_count + 1,
    last_error = $2,
    updated_at = NOW()
WHERE projection_name = $1
RETURNING id, projection_name, last_processed_event_id, last_processed_at, projection_state, error_count, last_error, created_at, updated_at
`

type RecordProjectionErrorParams struct {
	ProjectionName string      `json:"projection_name"`
	LastError      pgtype.Text `json:"last_error"`
}

func (q *Queries) RecordProjectionError(ctx context.Context, arg RecordProjectionErrorParams) (*EventProjection, error) {
	row := q.db.QueryRow(ctx, RecordProjectionError, arg.ProjectionName, arg.LastError)
	var i EventProjection
	err := row.Scan(
		&i.ID,
		&i.ProjectionName,
		&i.LastProcessedEventID,
		&i.LastProcessedAt,
		&i.ProjectionState,
		&i.ErrorCount,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ResetProjection = `-- name: ResetProjection :one
UPDATE event_projections
SET last_processed_event_id = NULL,
    last_processed_at = NULL,
    projection_state = '{}'::jsonb,
    error_count = 0,
    last_error = NULL,
    updated_at = NOW()
WHERE projection_name = $1
RETURNING id, projection_name, last_processed_event_id, last_processed_at, projection_state, error_count, last_error, created_at, updated_at
`

func (q *Queries) ResetProjection(ctx context.Context, projectionName string) (*EventProjection, error) {
	row := q.db.QueryRow(ctx, ResetProjection, projectionName)
	var i EventProjection
	err := row.Scan(
		&i.ID,
		&i.ProjectionName,
		&i.LastProcessedEventID,
		&i.LastProcessedAt,
		&i.ProjectionState,
		&i.ErrorCount,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateProjectionProgress = `-- name: UpdateProjectionProgress :one
UPDATE event_projections
SET last_processed_event_id = $2::uuid,
    last_processed_at = NOW(),
    error_count = 0,
    last_error = NULL,
    updated_at = NOW()
WHERE projection_name = $1
RETURNING id, projection_name, last_processed_event_id, last_processed_at, projection_state, error_count, last_error, created_at, updated_at
`

type UpdateProjectionProgressParams struct {
	ProjectionName string      `json:"projection_name"`
	Column2        pgtype.UUID `json:"column_2"`
}

func (q *Queries) UpdateProjectionProgress(ctx context.Context, arg UpdateProjectionProgressParams) (*EventProjection, error) {
	row := q.db.QueryRow(ctx, UpdateProjectionProgress, arg.ProjectionName, arg.Column2)
	var i EventProjection
	err := row.Scan(
		&i.ID,
		&i.ProjectionName,
		&i.LastProcessedEventID,
		&i.LastProcessedAt,
		&i.ProjectionState,
		&i.ErrorCount,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
