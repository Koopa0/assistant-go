// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: development_workflow.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const CleanupUnusedPatterns = `-- name: CleanupUnusedPatterns :exec
DELETE FROM code_patterns
WHERE user_id = $1::uuid
  AND frequency <= $2
  AND last_used < $3
`

type CleanupUnusedPatternsParams struct {
	Column1   pgtype.UUID        `json:"column_1"`
	Frequency pgtype.Int4        `json:"frequency"`
	LastUsed  pgtype.Timestamptz `json:"last_used"`
}

func (q *Queries) CleanupUnusedPatterns(ctx context.Context, arg CleanupUnusedPatternsParams) error {
	_, err := q.db.Exec(ctx, CleanupUnusedPatterns, arg.Column1, arg.Frequency, arg.LastUsed)
	return err
}

const CreateCodePattern = `-- name: CreateCodePattern :one

INSERT INTO code_patterns (
    user_id,
    pattern_category,
    pattern_name,
    pattern_ast,
    usage_contexts
) VALUES (
    $1::uuid, $2, $3, $4, $5
) ON CONFLICT (user_id, pattern_category, pattern_name)
DO UPDATE SET
    pattern_ast = $4,
    usage_contexts = $5,
    frequency = code_patterns.frequency + 1,
    last_used = NOW(),
    updated_at = NOW()
RETURNING id, user_id, pattern_category, pattern_name, pattern_ast, usage_contexts, frequency, last_used, evolution_history, quality_score, created_at, updated_at
`

type CreateCodePatternParams struct {
	Column1         pgtype.UUID `json:"column_1"`
	PatternCategory string      `json:"pattern_category"`
	PatternName     string      `json:"pattern_name"`
	PatternAst      []byte      `json:"pattern_ast"`
	UsageContexts   []string    `json:"usage_contexts"`
}

// =====================================================
// CODE PATTERNS QUERIES
// =====================================================
func (q *Queries) CreateCodePattern(ctx context.Context, arg CreateCodePatternParams) (*CodePattern, error) {
	row := q.db.QueryRow(ctx, CreateCodePattern,
		arg.Column1,
		arg.PatternCategory,
		arg.PatternName,
		arg.PatternAst,
		arg.UsageContexts,
	)
	var i CodePattern
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PatternCategory,
		&i.PatternName,
		&i.PatternAst,
		&i.UsageContexts,
		&i.Frequency,
		&i.LastUsed,
		&i.EvolutionHistory,
		&i.QualityScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateDevelopmentSession = `-- name: CreateDevelopmentSession :one


INSERT INTO development_sessions (
    user_id,
    session_type,
    project_context,
    goals,
    started_at
) VALUES (
    $1::uuid, $2, $3, $4, COALESCE($5, NOW())
) RETURNING id, user_id, session_type, project_context, goals, actual_outcomes, interruption_count, focus_score, productivity_metrics, mood_indicators, started_at, ended_at, total_duration_minutes
`

type CreateDevelopmentSessionParams struct {
	Column1        pgtype.UUID `json:"column_1"`
	SessionType    string      `json:"session_type"`
	ProjectContext []byte      `json:"project_context"`
	Goals          []string    `json:"goals"`
	Column5        interface{} `json:"column_5"`
}

// Development workflow queries
// =====================================================
// DEVELOPMENT SESSIONS QUERIES
// =====================================================
func (q *Queries) CreateDevelopmentSession(ctx context.Context, arg CreateDevelopmentSessionParams) (*DevelopmentSession, error) {
	row := q.db.QueryRow(ctx, CreateDevelopmentSession,
		arg.Column1,
		arg.SessionType,
		arg.ProjectContext,
		arg.Goals,
		arg.Column5,
	)
	var i DevelopmentSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionType,
		&i.ProjectContext,
		&i.Goals,
		&i.ActualOutcomes,
		&i.InterruptionCount,
		&i.FocusScore,
		&i.ProductivityMetrics,
		&i.MoodIndicators,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalDurationMinutes,
	)
	return &i, err
}

const DeleteOldSessions = `-- name: DeleteOldSessions :exec
DELETE FROM development_sessions
WHERE user_id = $1::uuid
  AND started_at < $2
`

type DeleteOldSessionsParams struct {
	Column1   pgtype.UUID        `json:"column_1"`
	StartedAt pgtype.Timestamptz `json:"started_at"`
}

func (q *Queries) DeleteOldSessions(ctx context.Context, arg DeleteOldSessionsParams) error {
	_, err := q.db.Exec(ctx, DeleteOldSessions, arg.Column1, arg.StartedAt)
	return err
}

const EndDevelopmentSession = `-- name: EndDevelopmentSession :one
UPDATE development_sessions
SET ended_at = COALESCE($2, NOW()),
    total_duration_minutes = EXTRACT(EPOCH FROM (COALESCE($2, NOW()) - started_at)) / 60,
    focus_score = CASE 
        WHEN $3 > 0 THEN GREATEST(0.1, 1.0 - ($3::float / 10.0))
        ELSE 1.0
    END
WHERE id = $1
RETURNING id, user_id, session_type, project_context, goals, actual_outcomes, interruption_count, focus_score, productivity_metrics, mood_indicators, started_at, ended_at, total_duration_minutes
`

type EndDevelopmentSessionParams struct {
	ID      pgtype.UUID        `json:"id"`
	EndedAt pgtype.Timestamptz `json:"ended_at"`
	Column3 interface{}        `json:"column_3"`
}

func (q *Queries) EndDevelopmentSession(ctx context.Context, arg EndDevelopmentSessionParams) (*DevelopmentSession, error) {
	row := q.db.QueryRow(ctx, EndDevelopmentSession, arg.ID, arg.EndedAt, arg.Column3)
	var i DevelopmentSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionType,
		&i.ProjectContext,
		&i.Goals,
		&i.ActualOutcomes,
		&i.InterruptionCount,
		&i.FocusScore,
		&i.ProductivityMetrics,
		&i.MoodIndicators,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalDurationMinutes,
	)
	return &i, err
}

const EvolvePattern = `-- name: EvolvePattern :one
UPDATE code_patterns
SET pattern_ast = $2,
    evolution_history = evolution_history || jsonb_build_object(
        'timestamp', EXTRACT(EPOCH FROM NOW()),
        'old_ast', pattern_ast,
        'change_reason', $3,
        'quality_improvement', $4
    ),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, pattern_category, pattern_name, pattern_ast, usage_contexts, frequency, last_used, evolution_history, quality_score, created_at, updated_at
`

type EvolvePatternParams struct {
	ID                 pgtype.UUID `json:"id"`
	PatternAst         []byte      `json:"pattern_ast"`
	JsonbBuildObject   interface{} `json:"jsonb_build_object"`
	JsonbBuildObject_2 interface{} `json:"jsonb_build_object_2"`
}

func (q *Queries) EvolvePattern(ctx context.Context, arg EvolvePatternParams) (*CodePattern, error) {
	row := q.db.QueryRow(ctx, EvolvePattern,
		arg.ID,
		arg.PatternAst,
		arg.JsonbBuildObject,
		arg.JsonbBuildObject_2,
	)
	var i CodePattern
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PatternCategory,
		&i.PatternName,
		&i.PatternAst,
		&i.UsageContexts,
		&i.Frequency,
		&i.LastUsed,
		&i.EvolutionHistory,
		&i.QualityScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetActiveSessions = `-- name: GetActiveSessions :many
SELECT id, user_id, session_type, project_context, goals, actual_outcomes, interruption_count, focus_score, productivity_metrics, mood_indicators, started_at, ended_at, total_duration_minutes
FROM development_sessions
WHERE user_id = $1::uuid
  AND ended_at IS NULL
ORDER BY started_at DESC
`

func (q *Queries) GetActiveSessions(ctx context.Context, dollar_1 pgtype.UUID) ([]*DevelopmentSession, error) {
	rows, err := q.db.Query(ctx, GetActiveSessions, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DevelopmentSession{}
	for rows.Next() {
		var i DevelopmentSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionType,
			&i.ProjectContext,
			&i.Goals,
			&i.ActualOutcomes,
			&i.InterruptionCount,
			&i.FocusScore,
			&i.ProductivityMetrics,
			&i.MoodIndicators,
			&i.StartedAt,
			&i.EndedAt,
			&i.TotalDurationMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCodePattern = `-- name: GetCodePattern :one
SELECT id, user_id, pattern_category, pattern_name, pattern_ast, usage_contexts, frequency, last_used, evolution_history, quality_score, created_at, updated_at
FROM code_patterns
WHERE id = $1
`

func (q *Queries) GetCodePattern(ctx context.Context, id pgtype.UUID) (*CodePattern, error) {
	row := q.db.QueryRow(ctx, GetCodePattern, id)
	var i CodePattern
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PatternCategory,
		&i.PatternName,
		&i.PatternAst,
		&i.UsageContexts,
		&i.Frequency,
		&i.LastUsed,
		&i.EvolutionHistory,
		&i.QualityScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetCodePatterns = `-- name: GetCodePatterns :many
SELECT id, user_id, pattern_category, pattern_name, pattern_ast, usage_contexts, frequency, last_used, evolution_history, quality_score, created_at, updated_at
FROM code_patterns
WHERE user_id = $1::uuid
  AND (pattern_category = $2 OR $2 IS NULL)
ORDER BY frequency DESC, last_used DESC
LIMIT $3 OFFSET $4
`

type GetCodePatternsParams struct {
	Column1         pgtype.UUID `json:"column_1"`
	PatternCategory string      `json:"pattern_category"`
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
}

func (q *Queries) GetCodePatterns(ctx context.Context, arg GetCodePatternsParams) ([]*CodePattern, error) {
	rows, err := q.db.Query(ctx, GetCodePatterns,
		arg.Column1,
		arg.PatternCategory,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CodePattern{}
	for rows.Next() {
		var i CodePattern
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PatternCategory,
			&i.PatternName,
			&i.PatternAst,
			&i.UsageContexts,
			&i.Frequency,
			&i.LastUsed,
			&i.EvolutionHistory,
			&i.QualityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDevelopmentSession = `-- name: GetDevelopmentSession :one
SELECT id, user_id, session_type, project_context, goals, actual_outcomes, interruption_count, focus_score, productivity_metrics, mood_indicators, started_at, ended_at, total_duration_minutes
FROM development_sessions
WHERE id = $1
`

func (q *Queries) GetDevelopmentSession(ctx context.Context, id pgtype.UUID) (*DevelopmentSession, error) {
	row := q.db.QueryRow(ctx, GetDevelopmentSession, id)
	var i DevelopmentSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionType,
		&i.ProjectContext,
		&i.Goals,
		&i.ActualOutcomes,
		&i.InterruptionCount,
		&i.FocusScore,
		&i.ProductivityMetrics,
		&i.MoodIndicators,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalDurationMinutes,
	)
	return &i, err
}

const GetDevelopmentSessions = `-- name: GetDevelopmentSessions :many
SELECT id, user_id, session_type, project_context, goals, actual_outcomes, interruption_count, focus_score, productivity_metrics, mood_indicators, started_at, ended_at, total_duration_minutes
FROM development_sessions
WHERE user_id = $1::uuid
  AND (session_type = $2 OR $2 IS NULL)
  AND started_at >= COALESCE($3, NOW() - INTERVAL '30 days')
ORDER BY started_at DESC
LIMIT $4 OFFSET $5
`

type GetDevelopmentSessionsParams struct {
	Column1     pgtype.UUID        `json:"column_1"`
	SessionType string             `json:"session_type"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

func (q *Queries) GetDevelopmentSessions(ctx context.Context, arg GetDevelopmentSessionsParams) ([]*DevelopmentSession, error) {
	rows, err := q.db.Query(ctx, GetDevelopmentSessions,
		arg.Column1,
		arg.SessionType,
		arg.StartedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*DevelopmentSession{}
	for rows.Next() {
		var i DevelopmentSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionType,
			&i.ProjectContext,
			&i.Goals,
			&i.ActualOutcomes,
			&i.InterruptionCount,
			&i.FocusScore,
			&i.ProductivityMetrics,
			&i.MoodIndicators,
			&i.StartedAt,
			&i.EndedAt,
			&i.TotalDurationMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPatternEvolution = `-- name: GetPatternEvolution :many
SELECT 
    pattern_name,
    pattern_category,
    frequency,
    quality_score,
    jsonb_array_length(evolution_history) as evolution_count,
    created_at,
    updated_at
FROM code_patterns
WHERE user_id = $1::uuid
  AND jsonb_array_length(evolution_history) > 0
ORDER BY jsonb_array_length(evolution_history) DESC, updated_at DESC
`

type GetPatternEvolutionRow struct {
	PatternName     string        `json:"pattern_name"`
	PatternCategory string        `json:"pattern_category"`
	Frequency       pgtype.Int4   `json:"frequency"`
	QualityScore    pgtype.Float8 `json:"quality_score"`
	EvolutionCount  int32         `json:"evolution_count"`
	CreatedAt       time.Time     `json:"created_at"`
	UpdatedAt       time.Time     `json:"updated_at"`
}

func (q *Queries) GetPatternEvolution(ctx context.Context, dollar_1 pgtype.UUID) ([]*GetPatternEvolutionRow, error) {
	rows, err := q.db.Query(ctx, GetPatternEvolution, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPatternEvolutionRow{}
	for rows.Next() {
		var i GetPatternEvolutionRow
		if err := rows.Scan(
			&i.PatternName,
			&i.PatternCategory,
			&i.Frequency,
			&i.QualityScore,
			&i.EvolutionCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetPatternStatistics = `-- name: GetPatternStatistics :one
SELECT 
    pattern_category,
    COUNT(*) as pattern_count,
    SUM(frequency) as total_usage,
    AVG(frequency) as avg_frequency,
    AVG(quality_score) as avg_quality,
    COUNT(*) FILTER (WHERE quality_score >= 0.8) as high_quality_patterns
FROM code_patterns
WHERE user_id = $1::uuid
GROUP BY pattern_category
ORDER BY total_usage DESC
`

type GetPatternStatisticsRow struct {
	PatternCategory     string  `json:"pattern_category"`
	PatternCount        int64   `json:"pattern_count"`
	TotalUsage          int64   `json:"total_usage"`
	AvgFrequency        float64 `json:"avg_frequency"`
	AvgQuality          float64 `json:"avg_quality"`
	HighQualityPatterns int64   `json:"high_quality_patterns"`
}

func (q *Queries) GetPatternStatistics(ctx context.Context, dollar_1 pgtype.UUID) (*GetPatternStatisticsRow, error) {
	row := q.db.QueryRow(ctx, GetPatternStatistics, dollar_1)
	var i GetPatternStatisticsRow
	err := row.Scan(
		&i.PatternCategory,
		&i.PatternCount,
		&i.TotalUsage,
		&i.AvgFrequency,
		&i.AvgQuality,
		&i.HighQualityPatterns,
	)
	return &i, err
}

const GetPopularPatterns = `-- name: GetPopularPatterns :many
SELECT 
    pattern_category,
    pattern_name,
    frequency,
    last_used,
    quality_score,
    usage_contexts
FROM code_patterns
WHERE user_id = $1::uuid
  AND frequency >= $2
ORDER BY frequency DESC, quality_score DESC NULLS LAST
LIMIT $3
`

type GetPopularPatternsParams struct {
	Column1   pgtype.UUID `json:"column_1"`
	Frequency pgtype.Int4 `json:"frequency"`
	Limit     int32       `json:"limit"`
}

type GetPopularPatternsRow struct {
	PatternCategory string             `json:"pattern_category"`
	PatternName     string             `json:"pattern_name"`
	Frequency       pgtype.Int4        `json:"frequency"`
	LastUsed        pgtype.Timestamptz `json:"last_used"`
	QualityScore    pgtype.Float8      `json:"quality_score"`
	UsageContexts   []string           `json:"usage_contexts"`
}

func (q *Queries) GetPopularPatterns(ctx context.Context, arg GetPopularPatternsParams) ([]*GetPopularPatternsRow, error) {
	rows, err := q.db.Query(ctx, GetPopularPatterns, arg.Column1, arg.Frequency, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPopularPatternsRow{}
	for rows.Next() {
		var i GetPopularPatternsRow
		if err := rows.Scan(
			&i.PatternCategory,
			&i.PatternName,
			&i.Frequency,
			&i.LastUsed,
			&i.QualityScore,
			&i.UsageContexts,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProductivityTrends = `-- name: GetProductivityTrends :many
SELECT 
    DATE_TRUNC($2::text, started_at) as time_period,
    COUNT(*) as session_count,
    AVG(total_duration_minutes) as avg_duration,
    AVG(focus_score) as avg_focus,
    SUM(total_duration_minutes) as total_time_minutes
FROM development_sessions
WHERE user_id = $1::uuid
  AND started_at >= COALESCE($3, NOW() - INTERVAL '90 days')
  AND ended_at IS NOT NULL
GROUP BY DATE_TRUNC($2::text, started_at)
ORDER BY time_period
`

type GetProductivityTrendsParams struct {
	Column1   pgtype.UUID        `json:"column_1"`
	Column2   string             `json:"column_2"`
	StartedAt pgtype.Timestamptz `json:"started_at"`
}

type GetProductivityTrendsRow struct {
	TimePeriod       pgtype.Interval `json:"time_period"`
	SessionCount     int64           `json:"session_count"`
	AvgDuration      float64         `json:"avg_duration"`
	AvgFocus         float64         `json:"avg_focus"`
	TotalTimeMinutes int64           `json:"total_time_minutes"`
}

func (q *Queries) GetProductivityTrends(ctx context.Context, arg GetProductivityTrendsParams) ([]*GetProductivityTrendsRow, error) {
	rows, err := q.db.Query(ctx, GetProductivityTrends, arg.Column1, arg.Column2, arg.StartedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProductivityTrendsRow{}
	for rows.Next() {
		var i GetProductivityTrendsRow
		if err := rows.Scan(
			&i.TimePeriod,
			&i.SessionCount,
			&i.AvgDuration,
			&i.AvgFocus,
			&i.TotalTimeMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSessionStatistics = `-- name: GetSessionStatistics :one
SELECT 
    session_type,
    COUNT(*) as total_sessions,
    AVG(total_duration_minutes) as avg_duration_minutes,
    AVG(focus_score) as avg_focus_score,
    AVG(interruption_count) as avg_interruptions,
    COUNT(*) FILTER (WHERE ended_at IS NOT NULL) as completed_sessions
FROM development_sessions
WHERE user_id = $1::uuid
  AND started_at >= COALESCE($2, NOW() - INTERVAL '30 days')
GROUP BY session_type
ORDER BY total_sessions DESC
`

type GetSessionStatisticsParams struct {
	Column1   pgtype.UUID        `json:"column_1"`
	StartedAt pgtype.Timestamptz `json:"started_at"`
}

type GetSessionStatisticsRow struct {
	SessionType        string  `json:"session_type"`
	TotalSessions      int64   `json:"total_sessions"`
	AvgDurationMinutes float64 `json:"avg_duration_minutes"`
	AvgFocusScore      float64 `json:"avg_focus_score"`
	AvgInterruptions   float64 `json:"avg_interruptions"`
	CompletedSessions  int64   `json:"completed_sessions"`
}

func (q *Queries) GetSessionStatistics(ctx context.Context, arg GetSessionStatisticsParams) (*GetSessionStatisticsRow, error) {
	row := q.db.QueryRow(ctx, GetSessionStatistics, arg.Column1, arg.StartedAt)
	var i GetSessionStatisticsRow
	err := row.Scan(
		&i.SessionType,
		&i.TotalSessions,
		&i.AvgDurationMinutes,
		&i.AvgFocusScore,
		&i.AvgInterruptions,
		&i.CompletedSessions,
	)
	return &i, err
}

const SearchCodePatterns = `-- name: SearchCodePatterns :many
SELECT id, user_id, pattern_category, pattern_name, pattern_ast, usage_contexts, frequency, last_used, evolution_history, quality_score, created_at, updated_at
FROM code_patterns
WHERE user_id = $1::uuid
  AND (pattern_name ILIKE '%' || $2 || '%' OR $2 = ANY(usage_contexts))
ORDER BY frequency DESC, last_used DESC
LIMIT $3
`

type SearchCodePatternsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) SearchCodePatterns(ctx context.Context, arg SearchCodePatternsParams) ([]*CodePattern, error) {
	rows, err := q.db.Query(ctx, SearchCodePatterns, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CodePattern{}
	for rows.Next() {
		var i CodePattern
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PatternCategory,
			&i.PatternName,
			&i.PatternAst,
			&i.UsageContexts,
			&i.Frequency,
			&i.LastUsed,
			&i.EvolutionHistory,
			&i.QualityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdatePatternQuality = `-- name: UpdatePatternQuality :one
UPDATE code_patterns
SET quality_score = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, pattern_category, pattern_name, pattern_ast, usage_contexts, frequency, last_used, evolution_history, quality_score, created_at, updated_at
`

type UpdatePatternQualityParams struct {
	ID           pgtype.UUID   `json:"id"`
	QualityScore pgtype.Float8 `json:"quality_score"`
}

func (q *Queries) UpdatePatternQuality(ctx context.Context, arg UpdatePatternQualityParams) (*CodePattern, error) {
	row := q.db.QueryRow(ctx, UpdatePatternQuality, arg.ID, arg.QualityScore)
	var i CodePattern
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PatternCategory,
		&i.PatternName,
		&i.PatternAst,
		&i.UsageContexts,
		&i.Frequency,
		&i.LastUsed,
		&i.EvolutionHistory,
		&i.QualityScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdatePatternUsage = `-- name: UpdatePatternUsage :one
UPDATE code_patterns
SET frequency = frequency + 1,
    last_used = NOW(),
    usage_contexts = CASE 
        WHEN $2 = ANY(usage_contexts) THEN usage_contexts
        ELSE array_append(usage_contexts, $2)
    END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, pattern_category, pattern_name, pattern_ast, usage_contexts, frequency, last_used, evolution_history, quality_score, created_at, updated_at
`

type UpdatePatternUsageParams struct {
	ID            pgtype.UUID `json:"id"`
	UsageContexts []string    `json:"usage_contexts"`
}

func (q *Queries) UpdatePatternUsage(ctx context.Context, arg UpdatePatternUsageParams) (*CodePattern, error) {
	row := q.db.QueryRow(ctx, UpdatePatternUsage, arg.ID, arg.UsageContexts)
	var i CodePattern
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PatternCategory,
		&i.PatternName,
		&i.PatternAst,
		&i.UsageContexts,
		&i.Frequency,
		&i.LastUsed,
		&i.EvolutionHistory,
		&i.QualityScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSessionProgress = `-- name: UpdateSessionProgress :one
UPDATE development_sessions
SET actual_outcomes = $2,
    interruption_count = $3,
    productivity_metrics = $4,
    mood_indicators = $5
WHERE id = $1
RETURNING id, user_id, session_type, project_context, goals, actual_outcomes, interruption_count, focus_score, productivity_metrics, mood_indicators, started_at, ended_at, total_duration_minutes
`

type UpdateSessionProgressParams struct {
	ID                  pgtype.UUID `json:"id"`
	ActualOutcomes      []string    `json:"actual_outcomes"`
	InterruptionCount   pgtype.Int4 `json:"interruption_count"`
	ProductivityMetrics []byte      `json:"productivity_metrics"`
	MoodIndicators      []byte      `json:"mood_indicators"`
}

func (q *Queries) UpdateSessionProgress(ctx context.Context, arg UpdateSessionProgressParams) (*DevelopmentSession, error) {
	row := q.db.QueryRow(ctx, UpdateSessionProgress,
		arg.ID,
		arg.ActualOutcomes,
		arg.InterruptionCount,
		arg.ProductivityMetrics,
		arg.MoodIndicators,
	)
	var i DevelopmentSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionType,
		&i.ProjectContext,
		&i.Goals,
		&i.ActualOutcomes,
		&i.InterruptionCount,
		&i.FocusScore,
		&i.ProductivityMetrics,
		&i.MoodIndicators,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalDurationMinutes,
	)
	return &i, err
}
