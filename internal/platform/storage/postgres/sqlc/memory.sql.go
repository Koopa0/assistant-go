// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: memory.sql

package sqlc

import (
	"context"
	"encoding/json"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const ArchiveOldMemoryEntries = `-- name: ArchiveOldMemoryEntries :execrows

UPDATE memory_entries
SET 
    importance = importance * $1::float,
    updated_at = NOW()
WHERE user_id = $2::uuid
  AND last_access < $3::timestamptz
  AND importance > $4::float
  AND memory_type != 'semantic'
`

type ArchiveOldMemoryEntriesParams struct {
	DecayFactor   float64            `json:"decay_factor"`
	UserID        pgtype.UUID        `json:"user_id"`
	ThresholdDate pgtype.Timestamptz `json:"threshold_date"`
	MinImportance float64            `json:"min_importance"`
}

// =====================================================
// MEMORY LIFECYCLE OPERATIONS
// =====================================================
// Archives old memory entries by reducing their importance
func (q *Queries) ArchiveOldMemoryEntries(ctx context.Context, arg ArchiveOldMemoryEntriesParams) (int64, error) {
	result, err := q.db.Exec(ctx, ArchiveOldMemoryEntries,
		arg.DecayFactor,
		arg.UserID,
		arg.ThresholdDate,
		arg.MinImportance,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

type BatchCreateMemoryEntriesParams struct {
	MemoryType  string             `json:"memory_type"`
	UserID      pgtype.UUID        `json:"user_id"`
	SessionID   pgtype.Text        `json:"session_id"`
	Content     string             `json:"content"`
	Importance  pgtype.Numeric     `json:"importance"`
	AccessCount pgtype.Int4        `json:"access_count"`
	LastAccess  pgtype.Timestamptz `json:"last_access"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Metadata    json.RawMessage    `json:"metadata"`
}

const BatchIncrementMemoryAccess = `-- name: BatchIncrementMemoryAccess :exec
UPDATE memory_entries
SET 
    access_count = access_count + 1,
    last_access = NOW(),
    updated_at = NOW()
WHERE id = ANY($1::uuid[])
`

// Batch update access counts for multiple entries
func (q *Queries) BatchIncrementMemoryAccess(ctx context.Context, ids []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, BatchIncrementMemoryAccess, ids)
	return err
}

const ConsolidateMemoryEntries = `-- name: ConsolidateMemoryEntries :many

WITH ranked_memories AS (
    SELECT 
        m1.id as id1,
        m2.id as id2,
        m1.content as content1,
        m2.content as content2,
        m1.importance + m2.importance as combined_importance,
        similarity(m1.content, m2.content) as content_similarity
    FROM memory_entries m1
    JOIN memory_entries m2 ON m1.user_id = m2.user_id 
        AND m1.memory_type = m2.memory_type
        AND m1.id < m2.id
    WHERE m1.user_id = $2::uuid
      AND m1.memory_type = $3::text
      AND similarity(m1.content, m2.content) > $4::float
)
SELECT 
    id1,
    id2,
    content1,
    content2,
    combined_importance,
    content_similarity
FROM ranked_memories
ORDER BY content_similarity DESC
LIMIT $1::int
`

type ConsolidateMemoryEntriesParams struct {
	LimitVal            int32       `json:"limit_val"`
	UserID              pgtype.UUID `json:"user_id"`
	MemoryType          string      `json:"memory_type"`
	SimilarityThreshold float64     `json:"similarity_threshold"`
}

type ConsolidateMemoryEntriesRow struct {
	Id1                pgtype.UUID `json:"id1"`
	Id2                pgtype.UUID `json:"id2"`
	Content1           string      `json:"content1"`
	Content2           string      `json:"content2"`
	CombinedImportance int32       `json:"combined_importance"`
	ContentSimilarity  float32     `json:"content_similarity"`
}

// Semantic memories don't decay
// Finds similar memory entries for consolidation
func (q *Queries) ConsolidateMemoryEntries(ctx context.Context, arg ConsolidateMemoryEntriesParams) ([]*ConsolidateMemoryEntriesRow, error) {
	rows, err := q.db.Query(ctx, ConsolidateMemoryEntries,
		arg.LimitVal,
		arg.UserID,
		arg.MemoryType,
		arg.SimilarityThreshold,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ConsolidateMemoryEntriesRow{}
	for rows.Next() {
		var i ConsolidateMemoryEntriesRow
		if err := rows.Scan(
			&i.Id1,
			&i.Id2,
			&i.Content1,
			&i.Content2,
			&i.CombinedImportance,
			&i.ContentSimilarity,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CreateMemoryEntry = `-- name: CreateMemoryEntry :one
INSERT INTO memory_entries (
    memory_type,
    user_id,
    session_id,
    content,
    importance,
    access_count,
    last_access,
    expires_at,
    metadata
) VALUES (
    $1::text,
    $2::uuid,
    $3::text,
    $4::text,
    $5::float,
    COALESCE($6::int, 0),
    COALESCE($7::timestamptz, NOW()),
    $8::timestamptz,
    COALESCE($9::jsonb, '{}'::jsonb)
) RETURNING 
    id,
    memory_type,
    user_id,
    session_id,
    content,
    importance,
    access_count,
    last_access,
    expires_at,
    metadata,
    created_at,
    updated_at
`

type CreateMemoryEntryParams struct {
	MemoryType  string             `json:"memory_type"`
	UserID      pgtype.UUID        `json:"user_id"`
	SessionID   string             `json:"session_id"`
	Content     string             `json:"content"`
	Importance  float64            `json:"importance"`
	AccessCount int32              `json:"access_count"`
	LastAccess  pgtype.Timestamptz `json:"last_access"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Metadata    []byte             `json:"metadata"`
}

type CreateMemoryEntryRow struct {
	ID          pgtype.UUID        `json:"id"`
	MemoryType  string             `json:"memory_type"`
	UserID      pgtype.UUID        `json:"user_id"`
	SessionID   pgtype.Text        `json:"session_id"`
	Content     string             `json:"content"`
	Importance  pgtype.Numeric     `json:"importance"`
	AccessCount pgtype.Int4        `json:"access_count"`
	LastAccess  pgtype.Timestamptz `json:"last_access"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Metadata    json.RawMessage    `json:"metadata"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

// Creates a new memory entry with explicit column selection
func (q *Queries) CreateMemoryEntry(ctx context.Context, arg CreateMemoryEntryParams) (*CreateMemoryEntryRow, error) {
	row := q.db.QueryRow(ctx, CreateMemoryEntry,
		arg.MemoryType,
		arg.UserID,
		arg.SessionID,
		arg.Content,
		arg.Importance,
		arg.AccessCount,
		arg.LastAccess,
		arg.ExpiresAt,
		arg.Metadata,
	)
	var i CreateMemoryEntryRow
	err := row.Scan(
		&i.ID,
		&i.MemoryType,
		&i.UserID,
		&i.SessionID,
		&i.Content,
		&i.Importance,
		&i.AccessCount,
		&i.LastAccess,
		&i.ExpiresAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateMemoryRelation = `-- name: CreateMemoryRelation :one

INSERT INTO memory_relations (
    from_memory_id,
    to_memory_id,
    relation_type,
    weight,
    metadata
) VALUES (
    $1::uuid,
    $2::uuid,
    $3::text,
    COALESCE($4::float, 0.5),
    COALESCE($5::jsonb, '{}'::jsonb)
) ON CONFLICT (from_memory_id, to_memory_id, relation_type) 
DO UPDATE SET 
    weight = GREATEST(memory_relations.weight, EXCLUDED.weight),
    metadata = memory_relations.metadata || EXCLUDED.metadata,
    updated_at = NOW()
RETURNING 
    id,
    from_memory_id,
    to_memory_id,
    relation_type,
    weight,
    metadata,
    created_at,
    updated_at
`

type CreateMemoryRelationParams struct {
	FromID       pgtype.UUID `json:"from_id"`
	ToID         pgtype.UUID `json:"to_id"`
	RelationType string      `json:"relation_type"`
	Weight       float64     `json:"weight"`
	Metadata     []byte      `json:"metadata"`
}

// =====================================================
// MEMORY RELATIONSHIPS AND GRAPH OPERATIONS
// =====================================================
// Creates a relationship between two memory entries
func (q *Queries) CreateMemoryRelation(ctx context.Context, arg CreateMemoryRelationParams) (*MemoryRelation, error) {
	row := q.db.QueryRow(ctx, CreateMemoryRelation,
		arg.FromID,
		arg.ToID,
		arg.RelationType,
		arg.Weight,
		arg.Metadata,
	)
	var i MemoryRelation
	err := row.Scan(
		&i.ID,
		&i.FromMemoryID,
		&i.ToMemoryID,
		&i.RelationType,
		&i.Weight,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteExpiredMemoryEntries = `-- name: DeleteExpiredMemoryEntries :execrows
DELETE FROM memory_entries
WHERE expires_at IS NOT NULL 
  AND expires_at <= NOW()
`

// Deletes expired memory entries and returns count
func (q *Queries) DeleteExpiredMemoryEntries(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, DeleteExpiredMemoryEntries)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const DeleteMemoryEntriesByUser = `-- name: DeleteMemoryEntriesByUser :execrows
DELETE FROM memory_entries
WHERE user_id = $1::uuid
  AND ($2::text[] IS NULL OR memory_type = ANY($2::text[]))
  AND ($3::timestamptz IS NULL OR created_at < $3::timestamptz)
`

type DeleteMemoryEntriesByUserParams struct {
	UserID        pgtype.UUID        `json:"user_id"`
	MemoryTypes   []string           `json:"memory_types"`
	CreatedBefore pgtype.Timestamptz `json:"created_before"`
}

// Deletes memory entries by user with optional filters
func (q *Queries) DeleteMemoryEntriesByUser(ctx context.Context, arg DeleteMemoryEntriesByUserParams) (int64, error) {
	result, err := q.db.Exec(ctx, DeleteMemoryEntriesByUser, arg.UserID, arg.MemoryTypes, arg.CreatedBefore)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const DeleteMemoryEntry = `-- name: DeleteMemoryEntry :exec
DELETE FROM memory_entries
WHERE id = $1::uuid
`

// Deletes a memory entry by ID
func (q *Queries) DeleteMemoryEntry(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteMemoryEntry, id)
	return err
}

const GetMemoryAccessPatterns = `-- name: GetMemoryAccessPatterns :many
SELECT 
    DATE_TRUNC('hour', last_access) as access_hour,
    memory_type,
    COUNT(*)::bigint as access_count,
    AVG(importance)::float as avg_importance
FROM memory_entries
WHERE user_id = $1::uuid
  AND last_access >= NOW() - INTERVAL '7 days'
GROUP BY DATE_TRUNC('hour', last_access), memory_type
ORDER BY access_hour DESC, access_count DESC
`

type GetMemoryAccessPatternsRow struct {
	AccessHour    pgtype.Interval `json:"access_hour"`
	MemoryType    string          `json:"memory_type"`
	AccessCount   int64           `json:"access_count"`
	AvgImportance float64         `json:"avg_importance"`
}

// Analyzes memory access patterns for optimization
func (q *Queries) GetMemoryAccessPatterns(ctx context.Context, userID pgtype.UUID) ([]*GetMemoryAccessPatternsRow, error) {
	rows, err := q.db.Query(ctx, GetMemoryAccessPatterns, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMemoryAccessPatternsRow{}
	for rows.Next() {
		var i GetMemoryAccessPatternsRow
		if err := rows.Scan(
			&i.AccessHour,
			&i.MemoryType,
			&i.AccessCount,
			&i.AvgImportance,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMemoryEntriesBySession = `-- name: GetMemoryEntriesBySession :many
SELECT 
    id,
    memory_type,
    user_id,
    session_id,
    content,
    importance,
    access_count,
    last_access,
    expires_at,
    metadata,
    created_at,
    updated_at
FROM memory_entries
WHERE user_id = $1::uuid
  AND session_id = $2::text
  AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY last_access DESC
LIMIT $4::int OFFSET $3::int
`

type GetMemoryEntriesBySessionParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	SessionID string      `json:"session_id"`
	OffsetVal int32       `json:"offset_val"`
	LimitVal  int32       `json:"limit_val"`
}

type GetMemoryEntriesBySessionRow struct {
	ID          pgtype.UUID        `json:"id"`
	MemoryType  string             `json:"memory_type"`
	UserID      pgtype.UUID        `json:"user_id"`
	SessionID   pgtype.Text        `json:"session_id"`
	Content     string             `json:"content"`
	Importance  pgtype.Numeric     `json:"importance"`
	AccessCount pgtype.Int4        `json:"access_count"`
	LastAccess  pgtype.Timestamptz `json:"last_access"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Metadata    json.RawMessage    `json:"metadata"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

// Gets memory entries for a specific session with pagination
func (q *Queries) GetMemoryEntriesBySession(ctx context.Context, arg GetMemoryEntriesBySessionParams) ([]*GetMemoryEntriesBySessionRow, error) {
	rows, err := q.db.Query(ctx, GetMemoryEntriesBySession,
		arg.UserID,
		arg.SessionID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMemoryEntriesBySessionRow{}
	for rows.Next() {
		var i GetMemoryEntriesBySessionRow
		if err := rows.Scan(
			&i.ID,
			&i.MemoryType,
			&i.UserID,
			&i.SessionID,
			&i.Content,
			&i.Importance,
			&i.AccessCount,
			&i.LastAccess,
			&i.ExpiresAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMemoryEntriesByUser = `-- name: GetMemoryEntriesByUser :many
SELECT 
    id,
    memory_type,
    user_id,
    session_id,
    content,
    importance,
    access_count,
    last_access,
    expires_at,
    metadata,
    created_at,
    updated_at
FROM memory_entries
WHERE user_id = $1::uuid
  AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY importance DESC, last_access DESC
`

type GetMemoryEntriesByUserRow struct {
	ID          pgtype.UUID        `json:"id"`
	MemoryType  string             `json:"memory_type"`
	UserID      pgtype.UUID        `json:"user_id"`
	SessionID   pgtype.Text        `json:"session_id"`
	Content     string             `json:"content"`
	Importance  pgtype.Numeric     `json:"importance"`
	AccessCount pgtype.Int4        `json:"access_count"`
	LastAccess  pgtype.Timestamptz `json:"last_access"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Metadata    json.RawMessage    `json:"metadata"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

// Gets all non-expired memory entries for a user
func (q *Queries) GetMemoryEntriesByUser(ctx context.Context, userID pgtype.UUID) ([]*GetMemoryEntriesByUserRow, error) {
	rows, err := q.db.Query(ctx, GetMemoryEntriesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMemoryEntriesByUserRow{}
	for rows.Next() {
		var i GetMemoryEntriesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.MemoryType,
			&i.UserID,
			&i.SessionID,
			&i.Content,
			&i.Importance,
			&i.AccessCount,
			&i.LastAccess,
			&i.ExpiresAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMemoryEntry = `-- name: GetMemoryEntry :one
SELECT 
    id,
    memory_type,
    user_id,
    session_id,
    content,
    importance,
    access_count,
    last_access,
    expires_at,
    metadata,
    created_at,
    updated_at
FROM memory_entries
WHERE id = $1::uuid
`

type GetMemoryEntryRow struct {
	ID          pgtype.UUID        `json:"id"`
	MemoryType  string             `json:"memory_type"`
	UserID      pgtype.UUID        `json:"user_id"`
	SessionID   pgtype.Text        `json:"session_id"`
	Content     string             `json:"content"`
	Importance  pgtype.Numeric     `json:"importance"`
	AccessCount pgtype.Int4        `json:"access_count"`
	LastAccess  pgtype.Timestamptz `json:"last_access"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Metadata    json.RawMessage    `json:"metadata"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

// Retrieves a memory entry by ID with explicit columns
func (q *Queries) GetMemoryEntry(ctx context.Context, id pgtype.UUID) (*GetMemoryEntryRow, error) {
	row := q.db.QueryRow(ctx, GetMemoryEntry, id)
	var i GetMemoryEntryRow
	err := row.Scan(
		&i.ID,
		&i.MemoryType,
		&i.UserID,
		&i.SessionID,
		&i.Content,
		&i.Importance,
		&i.AccessCount,
		&i.LastAccess,
		&i.ExpiresAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetMemoryRelations = `-- name: GetMemoryRelations :many
SELECT 
    mr.id,
    mr.from_memory_id,
    mr.to_memory_id,
    mr.relation_type,
    mr.weight,
    mr.metadata,
    mr.created_at,
    mr.updated_at,
    me_from.content as from_content,
    me_to.content as to_content
FROM memory_relations mr
JOIN memory_entries me_from ON mr.from_memory_id = me_from.id
JOIN memory_entries me_to ON mr.to_memory_id = me_to.id
WHERE (mr.from_memory_id = $1::uuid OR mr.to_memory_id = $1::uuid)
ORDER BY mr.weight DESC, mr.created_at DESC
`

type GetMemoryRelationsRow struct {
	ID           pgtype.UUID     `json:"id"`
	FromMemoryID pgtype.UUID     `json:"from_memory_id"`
	ToMemoryID   pgtype.UUID     `json:"to_memory_id"`
	RelationType string          `json:"relation_type"`
	Weight       pgtype.Float8   `json:"weight"`
	Metadata     json.RawMessage `json:"metadata"`
	CreatedAt    time.Time       `json:"created_at"`
	UpdatedAt    time.Time       `json:"updated_at"`
	FromContent  string          `json:"from_content"`
	ToContent    string          `json:"to_content"`
}

// Gets all relationships for a memory entry
func (q *Queries) GetMemoryRelations(ctx context.Context, memoryID pgtype.UUID) ([]*GetMemoryRelationsRow, error) {
	rows, err := q.db.Query(ctx, GetMemoryRelations, memoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMemoryRelationsRow{}
	for rows.Next() {
		var i GetMemoryRelationsRow
		if err := rows.Scan(
			&i.ID,
			&i.FromMemoryID,
			&i.ToMemoryID,
			&i.RelationType,
			&i.Weight,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FromContent,
			&i.ToContent,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMemoryStats = `-- name: GetMemoryStats :many
SELECT
    memory_type,
    COUNT(*)::bigint as entry_count,
    AVG(importance)::float as avg_importance,
    MIN(created_at) as oldest_entry,
    MAX(created_at) as newest_entry,
    SUM(access_count)::bigint as total_accesses
FROM memory_entries
WHERE user_id = $1::uuid
  AND (expires_at IS NULL OR expires_at > NOW())
GROUP BY memory_type
ORDER BY entry_count DESC
`

type GetMemoryStatsRow struct {
	MemoryType    string      `json:"memory_type"`
	EntryCount    int64       `json:"entry_count"`
	AvgImportance float64     `json:"avg_importance"`
	OldestEntry   interface{} `json:"oldest_entry"`
	NewestEntry   interface{} `json:"newest_entry"`
	TotalAccesses int64       `json:"total_accesses"`
}

// Gets memory statistics grouped by type
func (q *Queries) GetMemoryStats(ctx context.Context, userID pgtype.UUID) ([]*GetMemoryStatsRow, error) {
	rows, err := q.db.Query(ctx, GetMemoryStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMemoryStatsRow{}
	for rows.Next() {
		var i GetMemoryStatsRow
		if err := rows.Scan(
			&i.MemoryType,
			&i.EntryCount,
			&i.AvgImportance,
			&i.OldestEntry,
			&i.NewestEntry,
			&i.TotalAccesses,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMemoryUsageByUser = `-- name: GetMemoryUsageByUser :one

SELECT 
    COUNT(*)::bigint as total_entries,
    COUNT(DISTINCT memory_type) as type_count,
    SUM(LENGTH(content))::bigint as total_content_size,
    AVG(LENGTH(content))::float as avg_content_size,
    MAX(access_count)::int as max_access_count,
    AVG(access_count)::float as avg_access_count,
    COUNT(CASE WHEN expires_at IS NOT NULL THEN 1 END)::bigint as expiring_entries,
    COUNT(CASE WHEN importance > 0.7 THEN 1 END)::bigint as high_importance_entries
FROM memory_entries
WHERE user_id = $1::uuid
`

type GetMemoryUsageByUserRow struct {
	TotalEntries          int64   `json:"total_entries"`
	TypeCount             int64   `json:"type_count"`
	TotalContentSize      int64   `json:"total_content_size"`
	AvgContentSize        float64 `json:"avg_content_size"`
	MaxAccessCount        int32   `json:"max_access_count"`
	AvgAccessCount        float64 `json:"avg_access_count"`
	ExpiringEntries       int64   `json:"expiring_entries"`
	HighImportanceEntries int64   `json:"high_importance_entries"`
}

// =====================================================
// PERFORMANCE AND MAINTENANCE QUERIES
// =====================================================
// Gets memory usage statistics for capacity planning
func (q *Queries) GetMemoryUsageByUser(ctx context.Context, userID pgtype.UUID) (*GetMemoryUsageByUserRow, error) {
	row := q.db.QueryRow(ctx, GetMemoryUsageByUser, userID)
	var i GetMemoryUsageByUserRow
	err := row.Scan(
		&i.TotalEntries,
		&i.TypeCount,
		&i.TotalContentSize,
		&i.AvgContentSize,
		&i.MaxAccessCount,
		&i.AvgAccessCount,
		&i.ExpiringEntries,
		&i.HighImportanceEntries,
	)
	return &i, err
}

const GetRelatedMemories = `-- name: GetRelatedMemories :many
WITH RECURSIVE related AS (
    -- Base case: direct relationships
    SELECT 
        CASE 
            WHEN mr.from_memory_id = $1::uuid THEN mr.to_memory_id
            ELSE mr.from_memory_id
        END as related_id,
        mr.weight,
        1 as depth
    FROM memory_relations mr
    WHERE (mr.from_memory_id = $1::uuid OR mr.to_memory_id = $1::uuid)
      AND ($3::text[] IS NULL OR mr.relation_type = ANY($3::text[]))
    
    UNION
    
    -- Recursive case: indirect relationships (up to max depth)
    SELECT 
        CASE 
            WHEN mr.from_memory_id = r.related_id THEN mr.to_memory_id
            ELSE mr.from_memory_id
        END as related_id,
        r.weight * mr.weight as weight,
        r.depth + 1
    FROM related r
    JOIN memory_relations mr ON (mr.from_memory_id = r.related_id OR mr.to_memory_id = r.related_id)
    WHERE r.depth < $4::int
      AND ($3::text[] IS NULL OR mr.relation_type = ANY($3::text[]))
)
SELECT DISTINCT
    me.id,
    me.memory_type,
    me.user_id,
    me.session_id,
    me.content,
    me.importance,
    me.access_count,
    me.last_access,
    me.expires_at,
    me.metadata,
    me.created_at,
    me.updated_at,
    MAX(r.weight) as relationship_weight,
    MIN(r.depth) as relationship_depth
FROM related r
JOIN memory_entries me ON me.id = r.related_id
WHERE me.id != $1::uuid
GROUP BY me.id
ORDER BY relationship_weight DESC, relationship_depth ASC
LIMIT $2::int
`

type GetRelatedMemoriesParams struct {
	MemoryID      pgtype.UUID `json:"memory_id"`
	LimitVal      int32       `json:"limit_val"`
	RelationTypes []string    `json:"relation_types"`
	MaxDepth      int32       `json:"max_depth"`
}

type GetRelatedMemoriesRow struct {
	ID                 pgtype.UUID        `json:"id"`
	MemoryType         string             `json:"memory_type"`
	UserID             pgtype.UUID        `json:"user_id"`
	SessionID          pgtype.Text        `json:"session_id"`
	Content            string             `json:"content"`
	Importance         pgtype.Numeric     `json:"importance"`
	AccessCount        pgtype.Int4        `json:"access_count"`
	LastAccess         pgtype.Timestamptz `json:"last_access"`
	ExpiresAt          pgtype.Timestamptz `json:"expires_at"`
	Metadata           json.RawMessage    `json:"metadata"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
	RelationshipWeight interface{}        `json:"relationship_weight"`
	RelationshipDepth  interface{}        `json:"relationship_depth"`
}

// Gets memory entries related to a given entry through relationships
func (q *Queries) GetRelatedMemories(ctx context.Context, arg GetRelatedMemoriesParams) ([]*GetRelatedMemoriesRow, error) {
	rows, err := q.db.Query(ctx, GetRelatedMemories,
		arg.MemoryID,
		arg.LimitVal,
		arg.RelationTypes,
		arg.MaxDepth,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRelatedMemoriesRow{}
	for rows.Next() {
		var i GetRelatedMemoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.MemoryType,
			&i.UserID,
			&i.SessionID,
			&i.Content,
			&i.Importance,
			&i.AccessCount,
			&i.LastAccess,
			&i.ExpiresAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RelationshipWeight,
			&i.RelationshipDepth,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const IncrementMemoryAccess = `-- name: IncrementMemoryAccess :exec
UPDATE memory_entries
SET 
    access_count = access_count + 1,
    last_access = NOW(),
    updated_at = NOW()
WHERE id = $1::uuid
`

// Atomically increments access count and updates last access time
func (q *Queries) IncrementMemoryAccess(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, IncrementMemoryAccess, id)
	return err
}

const OptimizeMemoryIndices = `-- name: OptimizeMemoryIndices :exec
ANALYZE memory_entries
`

// Maintenance query to update memory statistics
func (q *Queries) OptimizeMemoryIndices(ctx context.Context) error {
	_, err := q.db.Exec(ctx, OptimizeMemoryIndices)
	return err
}

const SearchMemoryEntries = `-- name: SearchMemoryEntries :many
SELECT 
    id,
    memory_type,
    user_id,
    session_id,
    content,
    importance,
    access_count,
    last_access,
    expires_at,
    metadata,
    created_at,
    updated_at,
    ts_rank(to_tsvector('english', content), plainto_tsquery('english', $1::text)) as relevance
FROM memory_entries
WHERE user_id = $2::uuid
  AND ($3::text[] IS NULL OR memory_type = ANY($3::text[]))
  AND (
    $1::text IS NULL 
    OR to_tsvector('english', content) @@ plainto_tsquery('english', $1::text)
    OR content ILIKE '%' || $1::text || '%'
  )
  AND (expires_at IS NULL OR expires_at > NOW())
  AND importance >= COALESCE($4::float, 0.0)
ORDER BY 
    CASE WHEN $1::text IS NOT NULL THEN relevance ELSE 0 END DESC,
    importance DESC, 
    last_access DESC
LIMIT $6::int OFFSET $5::int
`

type SearchMemoryEntriesParams struct {
	SearchQuery   string      `json:"search_query"`
	UserID        pgtype.UUID `json:"user_id"`
	MemoryTypes   []string    `json:"memory_types"`
	MinImportance float64     `json:"min_importance"`
	OffsetVal     int32       `json:"offset_val"`
	LimitVal      int32       `json:"limit_val"`
}

type SearchMemoryEntriesRow struct {
	ID          pgtype.UUID        `json:"id"`
	MemoryType  string             `json:"memory_type"`
	UserID      pgtype.UUID        `json:"user_id"`
	SessionID   pgtype.Text        `json:"session_id"`
	Content     string             `json:"content"`
	Importance  pgtype.Numeric     `json:"importance"`
	AccessCount pgtype.Int4        `json:"access_count"`
	LastAccess  pgtype.Timestamptz `json:"last_access"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Metadata    json.RawMessage    `json:"metadata"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
	Relevance   float32            `json:"relevance"`
}

// Searches memory entries with full-text search and filters
func (q *Queries) SearchMemoryEntries(ctx context.Context, arg SearchMemoryEntriesParams) ([]*SearchMemoryEntriesRow, error) {
	rows, err := q.db.Query(ctx, SearchMemoryEntries,
		arg.SearchQuery,
		arg.UserID,
		arg.MemoryTypes,
		arg.MinImportance,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchMemoryEntriesRow{}
	for rows.Next() {
		var i SearchMemoryEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.MemoryType,
			&i.UserID,
			&i.SessionID,
			&i.Content,
			&i.Importance,
			&i.AccessCount,
			&i.LastAccess,
			&i.ExpiresAt,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Relevance,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateMemoryEntry = `-- name: UpdateMemoryEntry :one
UPDATE memory_entries
SET 
    content = $1::text,
    importance = $2::float,
    access_count = $3::int,
    last_access = $4::timestamptz,
    expires_at = $5::timestamptz,
    metadata = COALESCE($6::jsonb, metadata),
    updated_at = NOW()
WHERE id = $7::uuid
  AND ($8::int IS NULL OR updated_at = $9::timestamptz)
RETURNING 
    id,
    memory_type,
    user_id,
    session_id,
    content,
    importance,
    access_count,
    last_access,
    expires_at,
    metadata,
    created_at,
    updated_at
`

type UpdateMemoryEntryParams struct {
	Content           string             `json:"content"`
	Importance        float64            `json:"importance"`
	AccessCount       int32              `json:"access_count"`
	LastAccess        pgtype.Timestamptz `json:"last_access"`
	ExpiresAt         pgtype.Timestamptz `json:"expires_at"`
	Metadata          []byte             `json:"metadata"`
	ID                pgtype.UUID        `json:"id"`
	ExpectedVersion   int32              `json:"expected_version"`
	ExpectedUpdatedAt pgtype.Timestamptz `json:"expected_updated_at"`
}

type UpdateMemoryEntryRow struct {
	ID          pgtype.UUID        `json:"id"`
	MemoryType  string             `json:"memory_type"`
	UserID      pgtype.UUID        `json:"user_id"`
	SessionID   pgtype.Text        `json:"session_id"`
	Content     string             `json:"content"`
	Importance  pgtype.Numeric     `json:"importance"`
	AccessCount pgtype.Int4        `json:"access_count"`
	LastAccess  pgtype.Timestamptz `json:"last_access"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Metadata    json.RawMessage    `json:"metadata"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

// Updates a memory entry with optimistic locking
func (q *Queries) UpdateMemoryEntry(ctx context.Context, arg UpdateMemoryEntryParams) (*UpdateMemoryEntryRow, error) {
	row := q.db.QueryRow(ctx, UpdateMemoryEntry,
		arg.Content,
		arg.Importance,
		arg.AccessCount,
		arg.LastAccess,
		arg.ExpiresAt,
		arg.Metadata,
		arg.ID,
		arg.ExpectedVersion,
		arg.ExpectedUpdatedAt,
	)
	var i UpdateMemoryEntryRow
	err := row.Scan(
		&i.ID,
		&i.MemoryType,
		&i.UserID,
		&i.SessionID,
		&i.Content,
		&i.Importance,
		&i.AccessCount,
		&i.LastAccess,
		&i.ExpiresAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
