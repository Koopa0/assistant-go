package cli

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/koopa0/assistant-go/internal/assistant"
	"github.com/koopa0/assistant-go/internal/cli/ui"
	"github.com/koopa0/assistant-go/internal/config"
	"github.com/koopa0/assistant-go/internal/observability"
	"github.com/koopa0/assistant-go/internal/server"
)

// CLI represents the command line interface
type CLI struct {
	assistant *assistant.Assistant
	config    *config.Config
	logger    *slog.Logger
	colorizer *ui.Colorizer
}

// NewCLI creates a new CLI instance
func NewCLI(assistant *assistant.Assistant, config *config.Config, logger *slog.Logger) *CLI {
	return &CLI{
		assistant: assistant,
		config:    config,
		logger:    logger,
		colorizer: ui.NewColorizer("auto"),
	}
}

// Run executes the CLI based on command line arguments
func (c *CLI) Run(ctx context.Context, args []string) error {
	if len(args) < 2 {
		return c.showHelp()
	}

	command := args[1]

	switch command {
	case "ask":
		return c.handleAskCommand(ctx, args[2:])
	case "interactive", "i":
		return c.handleInteractiveCommand(ctx)
	case "chat":
		return c.handleChatCommand(ctx, args[2:])
	case "search":
		return c.handleSearchCommand(ctx, args[2:])
	case "memory":
		return c.handleMemoryCommand(ctx, args[2:])
	case "tools":
		return c.handleToolsCommand(ctx, args[2:])
	case "config":
		return c.handleConfigCommand(ctx, args[2:])
	case "status":
		return c.handleStatusCommand(ctx)
	case "serve":
		return c.handleServeCommand(ctx, args[2:])
	case "sql":
		if len(args) < 3 {
			return fmt.Errorf("éœ€è¦æä¾› SQL æŸ¥è©¢")
		}
		c.handleSQLCommand(ctx, strings.Join(args[2:], " "))
		return nil
	case "k8s", "kubernetes":
		c.handleK8sCommand(ctx, args[2:])
		return nil
	case "docker":
		c.handleDockerCommand(ctx, args[2:])
		return nil
	case "help", "-h", "--help":
		return c.showHelp()
	case "version", "-v", "--version":
		return c.showVersion()
	default:
		return fmt.Errorf("æœªçŸ¥å‘½ä»¤: %s\nè¼¸å…¥ 'assistant help' æŸ¥çœ‹å¯ç”¨å‘½ä»¤", command)
	}
}

// handleAskCommand handles the ask command
func (c *CLI) handleAskCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("éœ€è¦æä¾›æŸ¥è©¢å…§å®¹")
	}

	query := strings.Join(args, " ")
	
	// é¡¯ç¤ºè™•ç†æŒ‡ç¤ºå™¨
	spinner := ui.NewDotsSpinner("æ­£åœ¨è™•ç†æ‚¨çš„å•é¡Œ...")
	spinner.Start()
	defer spinner.Stop()
	
	response, err := c.assistant.ProcessQuery(ctx, query, map[string]interface{}{
		"cli_mode": true,
		"command":  "ask",
	})
	
	spinner.Stop()
	
	if err != nil {
		return fmt.Errorf("è™•ç†æŸ¥è©¢å¤±æ•—: %w", err)
	}

	// æ ¼å¼åŒ–è¼¸å‡º
	fmt.Printf("\n%s %s\n\n", c.colorizer.Assistant("ğŸ¤– åŠ©æ‰‹å›æ‡‰:"), c.colorizer.Dim(""))
	
	formatter := ui.NewFormatter()
	formattedResponse := formatter.FormatContent(response.Response, true)
	fmt.Println(formattedResponse)
	
	// é¡¯ç¤ºä½¿ç”¨çµ±è¨ˆ
	if response.Usage != nil {
		fmt.Printf("\n%s ä½¿ç”¨çµ±è¨ˆ: è¼¸å…¥ %d tokens, è¼¸å‡º %d tokens, ç¸½è¨ˆ %d tokens\n",
			c.colorizer.Dim("ğŸ“Š"),
			response.Usage.InputTokens,
			response.Usage.OutputTokens,
			response.Usage.TotalTokens,
		)
	}
	
	return nil
}

// handleInteractiveCommand handles the interactive command
func (c *CLI) handleInteractiveCommand(ctx context.Context) error {
	enhancedCLI, err := NewEnhancedCLI(c.assistant, c.config, c.logger)
	if err != nil {
		return fmt.Errorf("å•Ÿå‹•äº’å‹•æ¨¡å¼å¤±æ•—: %w", err)
	}
	
	return enhancedCLI.Run(ctx)
}

// handleChatCommand handles the chat command
func (c *CLI) handleChatCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		// å•Ÿå‹•èŠå¤©æ¨¡å¼
		return c.handleInteractiveCommand(ctx)
	}
	
	// è™•ç†ç‰¹å®šèŠå¤©å‘½ä»¤
	subcommand := args[0]
	switch subcommand {
	case "list":
		return c.listConversations(ctx)
	case "load":
		if len(args) < 2 {
			return fmt.Errorf("éœ€è¦æä¾›å°è©± ID")
		}
		return c.loadConversation(ctx, args[1])
	case "delete":
		if len(args) < 2 {
			return fmt.Errorf("éœ€è¦æä¾›å°è©± ID")
		}
		return c.deleteConversation(ctx, args[1])
	default:
		return fmt.Errorf("æœªçŸ¥çš„èŠå¤©å‘½ä»¤: %s", subcommand)
	}
}

// handleSearchCommand handles the search command
func (c *CLI) handleSearchCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("éœ€è¦æä¾›æœå°‹é—œéµå­—")
	}
	
	query := strings.Join(args, " ")
	
	fmt.Printf("%s æœå°‹é—œéµå­—: %s\n\n", c.colorizer.Info("ğŸ”"), c.colorizer.Value(query))
	
	// TODO: å¯¦ä½œæœå°‹åŠŸèƒ½
	fmt.Println(c.colorizer.Warning("æœå°‹åŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­..."))
	
	return nil
}

// handleMemoryCommand handles the memory command
func (c *CLI) handleMemoryCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return c.showMemoryStatus(ctx)
	}
	
	subcommand := args[0]
	switch subcommand {
	case "status":
		return c.showMemoryStatus(ctx)
	case "working":
		return c.showWorkingMemory(ctx)
	case "semantic":
		return c.showSemanticMemory(ctx)
	case "procedural":
		return c.showProceduralMemory(ctx)
	case "clear":
		return c.clearMemory(ctx, args[1:])
	default:
		return fmt.Errorf("æœªçŸ¥çš„è¨˜æ†¶é«”å‘½ä»¤: %s", subcommand)
	}
}

// handleToolsCommand handles the tools command
func (c *CLI) handleToolsCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return c.listTools(ctx)
	}
	
	subcommand := args[0]
	switch subcommand {
	case "list":
		return c.listTools(ctx)
	case "info":
		if len(args) < 2 {
			return fmt.Errorf("éœ€è¦æä¾›å·¥å…·åç¨±")
		}
		return c.showToolInfo(ctx, args[1])
	case "run":
		if len(args) < 2 {
			return fmt.Errorf("éœ€è¦æä¾›å·¥å…·åç¨±")
		}
		return c.runTool(ctx, args[1], args[2:])
	default:
		return fmt.Errorf("æœªçŸ¥çš„å·¥å…·å‘½ä»¤: %s", subcommand)
	}
}

// handleConfigCommand handles the config command
func (c *CLI) handleConfigCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return c.showConfig()
	}
	
	subcommand := args[0]
	switch subcommand {
	case "show":
		return c.showConfig()
	case "set":
		if len(args) < 3 {
			return fmt.Errorf("éœ€è¦æä¾›é…ç½®éµå’Œå€¼")
		}
		return c.setConfig(args[1], args[2])
	case "get":
		if len(args) < 2 {
			return fmt.Errorf("éœ€è¦æä¾›é…ç½®éµ")
		}
		return c.getConfig(args[1])
	default:
		return fmt.Errorf("æœªçŸ¥çš„é…ç½®å‘½ä»¤: %s", subcommand)
	}
}

// handleStatusCommand handles the status command
func (c *CLI) handleStatusCommand(ctx context.Context) error {
	fmt.Println(c.colorizer.Title("ğŸ”§ Assistant ç³»çµ±ç‹€æ…‹"))
	fmt.Println(c.colorizer.Divider())
	
	// åŸºæœ¬è³‡è¨Š
	fmt.Printf("ç‰ˆæœ¬: %s\n", c.colorizer.Value("1.0.0"))
	fmt.Printf("æ¨¡å¼: %s\n", c.colorizer.Value(c.config.Mode))
	fmt.Printf("AI æä¾›è€…: %s\n", c.colorizer.Value(c.config.AI.DefaultProvider))
	
	// è³‡æ–™åº«ç‹€æ…‹
	fmt.Printf("è³‡æ–™åº«: %s\n", c.colorizer.Success("å·²é€£æ¥"))
	
	// è¨˜æ†¶é«”ç³»çµ±ç‹€æ…‹
	fmt.Printf("å·¥ä½œè¨˜æ†¶é«”: %s\n", c.colorizer.Success("æ­£å¸¸"))
	fmt.Printf("èªç¾©è¨˜æ†¶é«”: %s\n", c.colorizer.Success("æ­£å¸¸"))
	fmt.Printf("ç¨‹åºè¨˜æ†¶é«”: %s\n", c.colorizer.Success("æ­£å¸¸"))
	
	// å·¥å…·ç‹€æ…‹
	fmt.Printf("å¯ç”¨å·¥å…·: %s\n", c.colorizer.Value("5"))
	
	return nil
}

// handleServeCommand handles the serve command
func (c *CLI) handleServeCommand(ctx context.Context, args []string) error {
	fmt.Printf("%s å•Ÿå‹• API ä¼ºæœå™¨...\n", c.colorizer.Info("ğŸš€"))
	fmt.Printf("åœ°å€: %s\n", c.colorizer.Value(c.config.Server.Address))
	fmt.Printf("æ¨¡å¼: %s\n", c.colorizer.Value(c.config.Mode))
	
	// å‰µå»ºè§€æ¸¬æ€§çµ„ä»¶
	metrics, err := observability.NewMetrics("assistant")
	if err != nil {
		return fmt.Errorf("ç„¡æ³•å‰µå»ºæŒ‡æ¨™ç³»çµ±: %w", err)
	}
	
	// å‰µå»º HTTP ä¼ºæœå™¨
	httpServer, err := server.New(c.config.Server, c.assistant, c.logger, metrics)
	if err != nil {
		return fmt.Errorf("ç„¡æ³•å‰µå»º HTTP ä¼ºæœå™¨: %w", err)
	}
	
	// è¨­ç½®å„ªé›…é—œé–‰
	go func() {
		<-ctx.Done()
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()
		
		if err := httpServer.Shutdown(shutdownCtx); err != nil {
			c.logger.Error("ä¼ºæœå™¨é—œé–‰å¤±æ•—", slog.Any("error", err))
		}
	}()
	
	fmt.Printf("%s ä¼ºæœå™¨å·²å•Ÿå‹•: %s\n", 
		c.colorizer.Success("âœ…"), 
		c.colorizer.Link("http://"+c.config.Server.Address))
	fmt.Printf("%s API æ–‡ä»¶: %s\n", 
		c.colorizer.Info("ğŸ“–"), 
		c.colorizer.Link("http://"+c.config.Server.Address+"/api/v1"))
	fmt.Println(c.colorizer.Dim("æŒ‰ Ctrl+C åœæ­¢ä¼ºæœå™¨"))
	
	// å•Ÿå‹•ä¼ºæœå™¨
	if err := httpServer.Start(ctx); err != nil && err != http.ErrServerClosed {
		return fmt.Errorf("ä¼ºæœå™¨å•Ÿå‹•å¤±æ•—: %w", err)
	}
	
	fmt.Println(c.colorizer.Success("ä¼ºæœå™¨å·²å„ªé›…é—œé–‰"))
	return nil
}

// showHelp displays help information
func (c *CLI) showHelp() error {
	logo := ui.GetLogo()
	fmt.Print(logo)
	
	help := c.colorizer.Help(`
Assistant - æ™ºæ…§é–‹ç™¼åŠ©æ‰‹

ç”¨æ³•:
    assistant <å‘½ä»¤> [é¸é …]

ä¸»è¦å‘½ä»¤:
    ask <å•é¡Œ>           è©¢å•åŠ©æ‰‹å•é¡Œ
    interactive, i       å•Ÿå‹•äº’å‹•æ¨¡å¼
    chat                 ç®¡ç†å°è©±
      list               åˆ—å‡ºå°è©±è¨˜éŒ„
      load <ID>          è¼‰å…¥å°è©±
      delete <ID>        åˆªé™¤å°è©±
    
    search <é—œéµå­—>      æœå°‹çŸ¥è­˜åº«
    memory               è¨˜æ†¶é«”ç®¡ç†
      status             é¡¯ç¤ºè¨˜æ†¶é«”ç‹€æ…‹
      working            é¡¯ç¤ºå·¥ä½œè¨˜æ†¶é«”
      semantic           é¡¯ç¤ºèªç¾©è¨˜æ†¶é«”
      procedural         é¡¯ç¤ºç¨‹åºè¨˜æ†¶é«”
      clear [é¡å‹]       æ¸…é™¤è¨˜æ†¶é«”
    
    tools                å·¥å…·ç®¡ç†
      list               åˆ—å‡ºå¯ç”¨å·¥å…·
      info <åç¨±>        é¡¯ç¤ºå·¥å…·è³‡è¨Š
      run <åç¨±> [åƒæ•¸]  åŸ·è¡Œå·¥å…·
    
    é–‹ç™¼å·¥å…·:
    sql <æŸ¥è©¢>           åŸ·è¡Œ SQL æŸ¥è©¢
    k8s <å‘½ä»¤>           Kubernetes ç®¡ç†
      get <è³‡æº>         ç²å–è³‡æº
      describe <è³‡æº> <åç¨±>  æè¿°è³‡æº
      logs <Podåç¨±>     æŸ¥çœ‹æ—¥èªŒ
    docker <å‘½ä»¤>        Docker ç®¡ç†
      ps [-a]            åˆ—å‡ºå®¹å™¨
      images             åˆ—å‡ºæ˜ åƒ
      logs <å®¹å™¨>        æŸ¥çœ‹å®¹å™¨æ—¥èªŒ
    
    config               é…ç½®ç®¡ç†
      show               é¡¯ç¤ºç•¶å‰é…ç½®
      set <éµ> <å€¼>      è¨­å®šé…ç½®
      get <éµ>           ç²å–é…ç½®å€¼
    
    status               é¡¯ç¤ºç³»çµ±ç‹€æ…‹
    serve                å•Ÿå‹• API ä¼ºæœå™¨
    
    help, -h, --help     é¡¯ç¤ºå¹«åŠ©è³‡è¨Š
    version, -v, --version  é¡¯ç¤ºç‰ˆæœ¬è³‡è¨Š

ç¯„ä¾‹:
    assistant ask "å¦‚ä½•åœ¨ Go ä¸­å¯¦ä½œ REST APIï¼Ÿ"
    assistant interactive
    assistant chat list
    assistant tools run code_analyzer main.go
    assistant memory status
    assistant sql "SELECT * FROM users LIMIT 10"
    assistant k8s get pods
    assistant docker ps
    assistant serve

æ›´å¤šè³‡è¨Šè«‹è¨ªå•: https://github.com/koopa0/assistant-go
`)
	fmt.Print(help)
	return nil
}

// showVersion displays version information
func (c *CLI) showVersion() error {
	fmt.Printf("%s %s\n", 
		c.colorizer.Title("Assistant"),
		c.colorizer.Value("v1.0.0"),
	)
	fmt.Printf("æ§‹å»ºæ™‚é–“: %s\n", c.colorizer.Dim("2024-01-15"))
	fmt.Printf("Go ç‰ˆæœ¬: %s\n", c.colorizer.Dim("1.24.2"))
	fmt.Printf("æäº¤: %s\n", c.colorizer.Dim("abc123def"))
	return nil
}

// è¼”åŠ©æ–¹æ³•å¯¦ä½œ

// showMemoryStatus é¡¯ç¤ºè¨˜æ†¶é«”ç‹€æ…‹
func (c *CLI) showMemoryStatus(ctx context.Context) error {
	fmt.Println(c.colorizer.Title("ğŸ§  è¨˜æ†¶é«”ç³»çµ±ç‹€æ…‹"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: å¾å¯¦éš›è¨˜æ†¶é«”ç³»çµ±ç²å–ç‹€æ…‹
	fmt.Printf("å·¥ä½œè¨˜æ†¶é«”ä½¿ç”¨ç‡: %s\n", c.colorizer.Value("45%"))
	fmt.Printf("èªç¾©æ¦‚å¿µæ•¸é‡: %s\n", c.colorizer.Value("1,234"))
	fmt.Printf("ç¨‹åºæ•¸é‡: %s\n", c.colorizer.Value("89"))
	fmt.Printf("æœ€å¾Œå­¸ç¿’æ™‚é–“: %s\n", c.colorizer.Value("2024-01-15 14:30"))
	
	return nil
}

// listTools åˆ—å‡ºå¯ç”¨å·¥å…·
func (c *CLI) listTools(ctx context.Context) error {
	fmt.Println(c.colorizer.Title("ğŸ› ï¸  å¯ç”¨å·¥å…·"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: å¾å·¥å…·è¨»å†Šè¡¨ç²å–å¯¦éš›å·¥å…·åˆ—è¡¨
	tools := []struct {
		Name        string
		Description string
		Status      string
	}{
		{"code_analyzer", "åˆ†æç¨‹å¼ç¢¼çµæ§‹å’Œå“è³ª", "å¯ç”¨"},
		{"file_processor", "è™•ç†å’Œåˆ†ææª”æ¡ˆå…§å®¹", "å¯ç”¨"},
		{"web_searcher", "æœå°‹ç¶²è·¯è³‡è¨Š", "å¯ç”¨"},
		{"database_tool", "è³‡æ–™åº«æŸ¥è©¢å’Œç®¡ç†", "å¯ç”¨"},
		{"sql_tool", "SQL æŸ¥è©¢åŸ·è¡Œå™¨", "å¯ç”¨"},
		{"k8s_tool", "Kubernetes ç®¡ç†å·¥å…·", "å¯ç”¨"},
		{"docker_tool", "Docker å®¹å™¨ç®¡ç†", "å¯ç”¨"},
	}
	
	for _, tool := range tools {
		status := c.colorizer.Success("â—")
		fmt.Printf("%s %s - %s\n", 
			status,
			c.colorizer.Bold(tool.Name),
			tool.Description,
		)
	}
	
	return nil
}

// showConfig é¡¯ç¤ºç•¶å‰é…ç½®
func (c *CLI) showConfig() error {
	fmt.Println(c.colorizer.Title("âš™ï¸  é…ç½®è³‡è¨Š"))
	fmt.Println(c.colorizer.Divider())
	
	fmt.Printf("æ¨¡å¼: %s\n", c.colorizer.Value(c.config.Mode))
	fmt.Printf("ä¼ºæœå™¨åœ°å€: %s\n", c.colorizer.Value(c.config.Server.Address))
	fmt.Printf("AI æä¾›è€…: %s\n", c.colorizer.Value(c.config.AI.DefaultProvider))
	fmt.Printf("è³‡æ–™åº« URL: %s\n", c.colorizer.Dim("[å·²éš±è—]"))
	
	return nil
}

// å…¶ä»–è¼”åŠ©æ–¹æ³•çš„ä½”ä½å¯¦ä½œ
func (c *CLI) listConversations(ctx context.Context) error {
	fmt.Println(c.colorizer.Title("ğŸ’¬ å°è©±è¨˜éŒ„"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: å¾è³‡æ–™åº«ç²å–å¯¦éš›å°è©±åˆ—è¡¨
	conversations := []struct {
		ID    string
		Title string
		Date  string
		Count int
	}{
		{"conv-001", "Go API è¨­è¨ˆè¨è«–", "2024-01-15", 12},
		{"conv-002", "è³‡æ–™åº«æœ€ä½³åŒ–å»ºè­°", "2024-01-14", 8},
		{"conv-003", "CLI å·¥å…·é–‹ç™¼", "2024-01-13", 15},
	}
	
	for _, conv := range conversations {
		fmt.Printf("%s %s\n", c.colorizer.Value(conv.ID), c.colorizer.Bold(conv.Title))
		fmt.Printf("    %s â€¢ %s\n", c.colorizer.Dim(conv.Date), c.colorizer.Dim(fmt.Sprintf("%d å‰‡è¨Šæ¯", conv.Count)))
	}
	
	return nil
}

func (c *CLI) loadConversation(ctx context.Context, id string) error {
	fmt.Printf("%s è¼‰å…¥å°è©±: %s\n", c.colorizer.Info("ğŸ“‚"), c.colorizer.Value(id))
	fmt.Println(c.colorizer.Warning("è¼‰å…¥å°è©±åŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­..."))
	return nil
}

func (c *CLI) deleteConversation(ctx context.Context, id string) error {
	fmt.Printf("%s åˆªé™¤å°è©±: %s\n", c.colorizer.Warning("ğŸ—‘ï¸"), c.colorizer.Value(id))
	fmt.Println(c.colorizer.Success("å°è©±å·²åˆªé™¤"))
	return nil
}

func (c *CLI) showWorkingMemory(ctx context.Context) error {
	fmt.Println(c.colorizer.Subtitle("ğŸ¯ å·¥ä½œè¨˜æ†¶é«”è©³æƒ…"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: å¾å¯¦éš›å·¥ä½œè¨˜æ†¶é«”ç²å–è³‡æ–™
	items := []struct {
		Type     string
		Content  string
		Priority float64
	}{
		{"ç›®æ¨™", "å®Œæˆ API è¨­è¨ˆ", 0.9},
		{"ä¸Šä¸‹æ–‡", "Go èªè¨€é–‹ç™¼", 0.7},
		{"ä»»å‹™", "å¯¦ä½œ CLI ä»‹é¢", 0.8},
	}
	
	for _, item := range items {
		priority := c.colorizer.Progress(int(item.Priority*100), 100)
		fmt.Printf("%s %s %s\n", 
			c.colorizer.Info(item.Type),
			item.Content,
			priority,
		)
	}
	
	return nil
}

func (c *CLI) showSemanticMemory(ctx context.Context) error {
	fmt.Println(c.colorizer.Subtitle("ğŸ§  èªç¾©è¨˜æ†¶é«”è©³æƒ…"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: å¾å¯¦éš›èªç¾©è¨˜æ†¶é«”ç²å–è³‡æ–™
	concepts := []struct {
		Name       string
		Type       string
		Confidence float64
	}{
		{"API è¨­è¨ˆ", "æŠ€è¡“æ¦‚å¿µ", 0.95},
		{"RESTful", "æ¶æ§‹æ¨¡å¼", 0.88},
		{"å¾®æœå‹™", "ç³»çµ±æ¶æ§‹", 0.82},
	}
	
	for _, concept := range concepts {
		confidence := c.colorizer.Progress(int(concept.Confidence*100), 100)
		fmt.Printf("%s (%s) %s\n",
			c.colorizer.Bold(concept.Name),
			c.colorizer.Dim(concept.Type),
			confidence,
		)
	}
	
	return nil
}

func (c *CLI) showProceduralMemory(ctx context.Context) error {
	fmt.Println(c.colorizer.Subtitle("âš™ï¸ ç¨‹åºè¨˜æ†¶é«”è©³æƒ…"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: å¾å¯¦éš›ç¨‹åºè¨˜æ†¶é«”ç²å–è³‡æ–™
	procedures := []struct {
		Name        string
		Category    string
		SuccessRate float64
	}{
		{"ç¨‹å¼ç¢¼éƒ¨ç½²", "æŠ€è¡“æ“ä½œ", 0.92},
		{"API æ¸¬è©¦", "å“è³ªä¿è­‰", 0.96},
		{"è³‡æ–™åº«å‚™ä»½", "ç¶­é‹æ“ä½œ", 0.98},
	}
	
	for _, proc := range procedures {
		successRate := c.colorizer.Progress(int(proc.SuccessRate*100), 100)
		fmt.Printf("%s (%s) %s\n",
			c.colorizer.Bold(proc.Name),
			c.colorizer.Dim(proc.Category),
			successRate,
		)
	}
	
	return nil
}

func (c *CLI) clearMemory(ctx context.Context, args []string) error {
	memoryType := "all"
	if len(args) > 0 {
		memoryType = args[0]
	}
	fmt.Printf("%s æ¸…é™¤è¨˜æ†¶é«”é¡å‹: %s\n", c.colorizer.Warning("ğŸ§¹"), c.colorizer.Value(memoryType))
	fmt.Println(c.colorizer.Success("è¨˜æ†¶é«”å·²æ¸…é™¤"))
	return nil
}

func (c *CLI) showToolInfo(ctx context.Context, toolName string) error {
	fmt.Printf("%s å·¥å…·è³‡è¨Š: %s\n", c.colorizer.Info("â„¹ï¸"), c.colorizer.Value(toolName))
	
	// TODO: å¾å·¥å…·è¨»å†Šè¡¨ç²å–å¯¦éš›å·¥å…·è³‡è¨Š
	switch toolName {
	case "code_analyzer":
		fmt.Println(c.colorizer.Divider())
		fmt.Printf("æè¿°: %s\n", "åˆ†æç¨‹å¼ç¢¼çµæ§‹ã€è¤‡é›œåº¦å’Œå“è³ªæŒ‡æ¨™")
		fmt.Printf("åƒæ•¸: %s\n", "file_path (å¿…éœ€), language (å¯é¸)")
		fmt.Printf("ç¯„ä¾‹: %s\n", c.colorizer.Code("assistant tools run code_analyzer main.go"))
	default:
		fmt.Println(c.colorizer.Warning("å·¥å…·è³‡è¨Šæ­£åœ¨é–‹ç™¼ä¸­..."))
	}
	
	return nil
}

func (c *CLI) runTool(ctx context.Context, toolName string, args []string) error {
	fmt.Printf("%s åŸ·è¡Œå·¥å…·: %s\n", c.colorizer.Info("ğŸƒ"), c.colorizer.Value(toolName))
	
	spinner := ui.NewDotsSpinner(fmt.Sprintf("åŸ·è¡Œ %s...", toolName))
	spinner.Start()
	
	// æ¨¡æ“¬å·¥å…·åŸ·è¡Œ
	time.Sleep(2 * time.Second)
	
	spinner.Stop()
	
	fmt.Println(c.colorizer.Success("å·¥å…·åŸ·è¡Œå®Œæˆ"))
	
	return nil
}

func (c *CLI) setConfig(key, value string) error {
	fmt.Printf("%s è¨­å®š %s = %s\n", c.colorizer.Success("âœ…"), c.colorizer.Bold(key), c.colorizer.Value(value))
	return nil
}

func (c *CLI) getConfig(key string) error {
	fmt.Printf("%s: %s\n", c.colorizer.Bold(key), c.colorizer.Value("[å€¼]"))
	return nil
}