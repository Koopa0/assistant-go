package cli

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/koopa0/assistant-go/internal/assistant"
	"github.com/koopa0/assistant-go/internal/cli/ui"
	"github.com/koopa0/assistant-go/internal/config"
	"github.com/koopa0/assistant-go/internal/observability"
	"github.com/koopa0/assistant-go/internal/server"
)

// CLI represents the command line interface
type CLI struct {
	assistant *assistant.Assistant
	config    *config.Config
	logger    *slog.Logger
	colorizer *ui.Colorizer
}

// NewCLI creates a new CLI instance
func NewCLI(assistant *assistant.Assistant, config *config.Config, logger *slog.Logger) *CLI {
	return &CLI{
		assistant: assistant,
		config:    config,
		logger:    logger,
		colorizer: ui.NewColorizer("auto"),
	}
}

// Run executes the CLI based on command line arguments
func (c *CLI) Run(ctx context.Context, args []string) error {
	if len(args) < 2 {
		return c.showHelp()
	}

	command := args[1]

	switch command {
	case "ask":
		return c.handleAskCommand(ctx, args[2:])
	case "interactive", "i":
		return c.handleInteractiveCommand(ctx)
	case "chat":
		return c.handleChatCommand(ctx, args[2:])
	case "search":
		return c.handleSearchCommand(ctx, args[2:])
	case "memory":
		return c.handleMemoryCommand(ctx, args[2:])
	case "tools":
		return c.handleToolsCommand(ctx, args[2:])
	case "config":
		return c.handleConfigCommand(ctx, args[2:])
	case "status":
		return c.handleStatusCommand(ctx)
	case "serve":
		return c.handleServeCommand(ctx, args[2:])
	case "sql":
		if len(args) < 3 {
			return fmt.Errorf("需要提供 SQL 查詢")
		}
		c.handleSQLCommand(ctx, strings.Join(args[2:], " "))
		return nil
	case "k8s", "kubernetes":
		c.handleK8sCommand(ctx, args[2:])
		return nil
	case "docker":
		c.handleDockerCommand(ctx, args[2:])
		return nil
	case "help", "-h", "--help":
		return c.showHelp()
	case "version", "-v", "--version":
		return c.showVersion()
	default:
		return fmt.Errorf("未知命令: %s\n輸入 'assistant help' 查看可用命令", command)
	}
}

// handleAskCommand handles the ask command
func (c *CLI) handleAskCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("需要提供查詢內容")
	}

	query := strings.Join(args, " ")
	
	// 顯示處理指示器
	spinner := ui.NewDotsSpinner("正在處理您的問題...")
	spinner.Start()
	defer spinner.Stop()
	
	response, err := c.assistant.ProcessQuery(ctx, query, map[string]interface{}{
		"cli_mode": true,
		"command":  "ask",
	})
	
	spinner.Stop()
	
	if err != nil {
		return fmt.Errorf("處理查詢失敗: %w", err)
	}

	// 格式化輸出
	fmt.Printf("\n%s %s\n\n", c.colorizer.Assistant("🤖 助手回應:"), c.colorizer.Dim(""))
	
	formatter := ui.NewFormatter()
	formattedResponse := formatter.FormatContent(response.Response, true)
	fmt.Println(formattedResponse)
	
	// 顯示使用統計
	if response.Usage != nil {
		fmt.Printf("\n%s 使用統計: 輸入 %d tokens, 輸出 %d tokens, 總計 %d tokens\n",
			c.colorizer.Dim("📊"),
			response.Usage.InputTokens,
			response.Usage.OutputTokens,
			response.Usage.TotalTokens,
		)
	}
	
	return nil
}

// handleInteractiveCommand handles the interactive command
func (c *CLI) handleInteractiveCommand(ctx context.Context) error {
	enhancedCLI, err := NewEnhancedCLI(c.assistant, c.config, c.logger)
	if err != nil {
		return fmt.Errorf("啟動互動模式失敗: %w", err)
	}
	
	return enhancedCLI.Run(ctx)
}

// handleChatCommand handles the chat command
func (c *CLI) handleChatCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		// 啟動聊天模式
		return c.handleInteractiveCommand(ctx)
	}
	
	// 處理特定聊天命令
	subcommand := args[0]
	switch subcommand {
	case "list":
		return c.listConversations(ctx)
	case "load":
		if len(args) < 2 {
			return fmt.Errorf("需要提供對話 ID")
		}
		return c.loadConversation(ctx, args[1])
	case "delete":
		if len(args) < 2 {
			return fmt.Errorf("需要提供對話 ID")
		}
		return c.deleteConversation(ctx, args[1])
	default:
		return fmt.Errorf("未知的聊天命令: %s", subcommand)
	}
}

// handleSearchCommand handles the search command
func (c *CLI) handleSearchCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("需要提供搜尋關鍵字")
	}
	
	query := strings.Join(args, " ")
	
	fmt.Printf("%s 搜尋關鍵字: %s\n\n", c.colorizer.Info("🔍"), c.colorizer.Value(query))
	
	// TODO: 實作搜尋功能
	fmt.Println(c.colorizer.Warning("搜尋功能正在開發中..."))
	
	return nil
}

// handleMemoryCommand handles the memory command
func (c *CLI) handleMemoryCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return c.showMemoryStatus(ctx)
	}
	
	subcommand := args[0]
	switch subcommand {
	case "status":
		return c.showMemoryStatus(ctx)
	case "working":
		return c.showWorkingMemory(ctx)
	case "semantic":
		return c.showSemanticMemory(ctx)
	case "procedural":
		return c.showProceduralMemory(ctx)
	case "clear":
		return c.clearMemory(ctx, args[1:])
	default:
		return fmt.Errorf("未知的記憶體命令: %s", subcommand)
	}
}

// handleToolsCommand handles the tools command
func (c *CLI) handleToolsCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return c.listTools(ctx)
	}
	
	subcommand := args[0]
	switch subcommand {
	case "list":
		return c.listTools(ctx)
	case "info":
		if len(args) < 2 {
			return fmt.Errorf("需要提供工具名稱")
		}
		return c.showToolInfo(ctx, args[1])
	case "run":
		if len(args) < 2 {
			return fmt.Errorf("需要提供工具名稱")
		}
		return c.runTool(ctx, args[1], args[2:])
	default:
		return fmt.Errorf("未知的工具命令: %s", subcommand)
	}
}

// handleConfigCommand handles the config command
func (c *CLI) handleConfigCommand(ctx context.Context, args []string) error {
	if len(args) == 0 {
		return c.showConfig()
	}
	
	subcommand := args[0]
	switch subcommand {
	case "show":
		return c.showConfig()
	case "set":
		if len(args) < 3 {
			return fmt.Errorf("需要提供配置鍵和值")
		}
		return c.setConfig(args[1], args[2])
	case "get":
		if len(args) < 2 {
			return fmt.Errorf("需要提供配置鍵")
		}
		return c.getConfig(args[1])
	default:
		return fmt.Errorf("未知的配置命令: %s", subcommand)
	}
}

// handleStatusCommand handles the status command
func (c *CLI) handleStatusCommand(ctx context.Context) error {
	fmt.Println(c.colorizer.Title("🔧 Assistant 系統狀態"))
	fmt.Println(c.colorizer.Divider())
	
	// 基本資訊
	fmt.Printf("版本: %s\n", c.colorizer.Value("1.0.0"))
	fmt.Printf("模式: %s\n", c.colorizer.Value(c.config.Mode))
	fmt.Printf("AI 提供者: %s\n", c.colorizer.Value(c.config.AI.DefaultProvider))
	
	// 資料庫狀態
	fmt.Printf("資料庫: %s\n", c.colorizer.Success("已連接"))
	
	// 記憶體系統狀態
	fmt.Printf("工作記憶體: %s\n", c.colorizer.Success("正常"))
	fmt.Printf("語義記憶體: %s\n", c.colorizer.Success("正常"))
	fmt.Printf("程序記憶體: %s\n", c.colorizer.Success("正常"))
	
	// 工具狀態
	fmt.Printf("可用工具: %s\n", c.colorizer.Value("5"))
	
	return nil
}

// handleServeCommand handles the serve command
func (c *CLI) handleServeCommand(ctx context.Context, args []string) error {
	fmt.Printf("%s 啟動 API 伺服器...\n", c.colorizer.Info("🚀"))
	fmt.Printf("地址: %s\n", c.colorizer.Value(c.config.Server.Address))
	fmt.Printf("模式: %s\n", c.colorizer.Value(c.config.Mode))
	
	// 創建觀測性組件
	metrics, err := observability.NewMetrics("assistant")
	if err != nil {
		return fmt.Errorf("無法創建指標系統: %w", err)
	}
	
	// 創建 HTTP 伺服器
	httpServer, err := server.New(c.config.Server, c.assistant, c.logger, metrics)
	if err != nil {
		return fmt.Errorf("無法創建 HTTP 伺服器: %w", err)
	}
	
	// 設置優雅關閉
	go func() {
		<-ctx.Done()
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()
		
		if err := httpServer.Shutdown(shutdownCtx); err != nil {
			c.logger.Error("伺服器關閉失敗", slog.Any("error", err))
		}
	}()
	
	fmt.Printf("%s 伺服器已啟動: %s\n", 
		c.colorizer.Success("✅"), 
		c.colorizer.Link("http://"+c.config.Server.Address))
	fmt.Printf("%s API 文件: %s\n", 
		c.colorizer.Info("📖"), 
		c.colorizer.Link("http://"+c.config.Server.Address+"/api/v1"))
	fmt.Println(c.colorizer.Dim("按 Ctrl+C 停止伺服器"))
	
	// 啟動伺服器
	if err := httpServer.Start(ctx); err != nil && err != http.ErrServerClosed {
		return fmt.Errorf("伺服器啟動失敗: %w", err)
	}
	
	fmt.Println(c.colorizer.Success("伺服器已優雅關閉"))
	return nil
}

// showHelp displays help information
func (c *CLI) showHelp() error {
	logo := ui.GetLogo()
	fmt.Print(logo)
	
	help := c.colorizer.Help(`
Assistant - 智慧開發助手

用法:
    assistant <命令> [選項]

主要命令:
    ask <問題>           詢問助手問題
    interactive, i       啟動互動模式
    chat                 管理對話
      list               列出對話記錄
      load <ID>          載入對話
      delete <ID>        刪除對話
    
    search <關鍵字>      搜尋知識庫
    memory               記憶體管理
      status             顯示記憶體狀態
      working            顯示工作記憶體
      semantic           顯示語義記憶體
      procedural         顯示程序記憶體
      clear [類型]       清除記憶體
    
    tools                工具管理
      list               列出可用工具
      info <名稱>        顯示工具資訊
      run <名稱> [參數]  執行工具
    
    開發工具:
    sql <查詢>           執行 SQL 查詢
    k8s <命令>           Kubernetes 管理
      get <資源>         獲取資源
      describe <資源> <名稱>  描述資源
      logs <Pod名稱>     查看日誌
    docker <命令>        Docker 管理
      ps [-a]            列出容器
      images             列出映像
      logs <容器>        查看容器日誌
    
    config               配置管理
      show               顯示當前配置
      set <鍵> <值>      設定配置
      get <鍵>           獲取配置值
    
    status               顯示系統狀態
    serve                啟動 API 伺服器
    
    help, -h, --help     顯示幫助資訊
    version, -v, --version  顯示版本資訊

範例:
    assistant ask "如何在 Go 中實作 REST API？"
    assistant interactive
    assistant chat list
    assistant tools run code_analyzer main.go
    assistant memory status
    assistant sql "SELECT * FROM users LIMIT 10"
    assistant k8s get pods
    assistant docker ps
    assistant serve

更多資訊請訪問: https://github.com/koopa0/assistant-go
`)
	fmt.Print(help)
	return nil
}

// showVersion displays version information
func (c *CLI) showVersion() error {
	fmt.Printf("%s %s\n", 
		c.colorizer.Title("Assistant"),
		c.colorizer.Value("v1.0.0"),
	)
	fmt.Printf("構建時間: %s\n", c.colorizer.Dim("2024-01-15"))
	fmt.Printf("Go 版本: %s\n", c.colorizer.Dim("1.24.2"))
	fmt.Printf("提交: %s\n", c.colorizer.Dim("abc123def"))
	return nil
}

// 輔助方法實作

// showMemoryStatus 顯示記憶體狀態
func (c *CLI) showMemoryStatus(ctx context.Context) error {
	fmt.Println(c.colorizer.Title("🧠 記憶體系統狀態"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: 從實際記憶體系統獲取狀態
	fmt.Printf("工作記憶體使用率: %s\n", c.colorizer.Value("45%"))
	fmt.Printf("語義概念數量: %s\n", c.colorizer.Value("1,234"))
	fmt.Printf("程序數量: %s\n", c.colorizer.Value("89"))
	fmt.Printf("最後學習時間: %s\n", c.colorizer.Value("2024-01-15 14:30"))
	
	return nil
}

// listTools 列出可用工具
func (c *CLI) listTools(ctx context.Context) error {
	fmt.Println(c.colorizer.Title("🛠️  可用工具"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: 從工具註冊表獲取實際工具列表
	tools := []struct {
		Name        string
		Description string
		Status      string
	}{
		{"code_analyzer", "分析程式碼結構和品質", "可用"},
		{"file_processor", "處理和分析檔案內容", "可用"},
		{"web_searcher", "搜尋網路資訊", "可用"},
		{"database_tool", "資料庫查詢和管理", "可用"},
		{"sql_tool", "SQL 查詢執行器", "可用"},
		{"k8s_tool", "Kubernetes 管理工具", "可用"},
		{"docker_tool", "Docker 容器管理", "可用"},
	}
	
	for _, tool := range tools {
		status := c.colorizer.Success("●")
		fmt.Printf("%s %s - %s\n", 
			status,
			c.colorizer.Bold(tool.Name),
			tool.Description,
		)
	}
	
	return nil
}

// showConfig 顯示當前配置
func (c *CLI) showConfig() error {
	fmt.Println(c.colorizer.Title("⚙️  配置資訊"))
	fmt.Println(c.colorizer.Divider())
	
	fmt.Printf("模式: %s\n", c.colorizer.Value(c.config.Mode))
	fmt.Printf("伺服器地址: %s\n", c.colorizer.Value(c.config.Server.Address))
	fmt.Printf("AI 提供者: %s\n", c.colorizer.Value(c.config.AI.DefaultProvider))
	fmt.Printf("資料庫 URL: %s\n", c.colorizer.Dim("[已隱藏]"))
	
	return nil
}

// 其他輔助方法的佔位實作
func (c *CLI) listConversations(ctx context.Context) error {
	fmt.Println(c.colorizer.Title("💬 對話記錄"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: 從資料庫獲取實際對話列表
	conversations := []struct {
		ID    string
		Title string
		Date  string
		Count int
	}{
		{"conv-001", "Go API 設計討論", "2024-01-15", 12},
		{"conv-002", "資料庫最佳化建議", "2024-01-14", 8},
		{"conv-003", "CLI 工具開發", "2024-01-13", 15},
	}
	
	for _, conv := range conversations {
		fmt.Printf("%s %s\n", c.colorizer.Value(conv.ID), c.colorizer.Bold(conv.Title))
		fmt.Printf("    %s • %s\n", c.colorizer.Dim(conv.Date), c.colorizer.Dim(fmt.Sprintf("%d 則訊息", conv.Count)))
	}
	
	return nil
}

func (c *CLI) loadConversation(ctx context.Context, id string) error {
	fmt.Printf("%s 載入對話: %s\n", c.colorizer.Info("📂"), c.colorizer.Value(id))
	fmt.Println(c.colorizer.Warning("載入對話功能正在開發中..."))
	return nil
}

func (c *CLI) deleteConversation(ctx context.Context, id string) error {
	fmt.Printf("%s 刪除對話: %s\n", c.colorizer.Warning("🗑️"), c.colorizer.Value(id))
	fmt.Println(c.colorizer.Success("對話已刪除"))
	return nil
}

func (c *CLI) showWorkingMemory(ctx context.Context) error {
	fmt.Println(c.colorizer.Subtitle("🎯 工作記憶體詳情"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: 從實際工作記憶體獲取資料
	items := []struct {
		Type     string
		Content  string
		Priority float64
	}{
		{"目標", "完成 API 設計", 0.9},
		{"上下文", "Go 語言開發", 0.7},
		{"任務", "實作 CLI 介面", 0.8},
	}
	
	for _, item := range items {
		priority := c.colorizer.Progress(int(item.Priority*100), 100)
		fmt.Printf("%s %s %s\n", 
			c.colorizer.Info(item.Type),
			item.Content,
			priority,
		)
	}
	
	return nil
}

func (c *CLI) showSemanticMemory(ctx context.Context) error {
	fmt.Println(c.colorizer.Subtitle("🧠 語義記憶體詳情"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: 從實際語義記憶體獲取資料
	concepts := []struct {
		Name       string
		Type       string
		Confidence float64
	}{
		{"API 設計", "技術概念", 0.95},
		{"RESTful", "架構模式", 0.88},
		{"微服務", "系統架構", 0.82},
	}
	
	for _, concept := range concepts {
		confidence := c.colorizer.Progress(int(concept.Confidence*100), 100)
		fmt.Printf("%s (%s) %s\n",
			c.colorizer.Bold(concept.Name),
			c.colorizer.Dim(concept.Type),
			confidence,
		)
	}
	
	return nil
}

func (c *CLI) showProceduralMemory(ctx context.Context) error {
	fmt.Println(c.colorizer.Subtitle("⚙️ 程序記憶體詳情"))
	fmt.Println(c.colorizer.Divider())
	
	// TODO: 從實際程序記憶體獲取資料
	procedures := []struct {
		Name        string
		Category    string
		SuccessRate float64
	}{
		{"程式碼部署", "技術操作", 0.92},
		{"API 測試", "品質保證", 0.96},
		{"資料庫備份", "維運操作", 0.98},
	}
	
	for _, proc := range procedures {
		successRate := c.colorizer.Progress(int(proc.SuccessRate*100), 100)
		fmt.Printf("%s (%s) %s\n",
			c.colorizer.Bold(proc.Name),
			c.colorizer.Dim(proc.Category),
			successRate,
		)
	}
	
	return nil
}

func (c *CLI) clearMemory(ctx context.Context, args []string) error {
	memoryType := "all"
	if len(args) > 0 {
		memoryType = args[0]
	}
	fmt.Printf("%s 清除記憶體類型: %s\n", c.colorizer.Warning("🧹"), c.colorizer.Value(memoryType))
	fmt.Println(c.colorizer.Success("記憶體已清除"))
	return nil
}

func (c *CLI) showToolInfo(ctx context.Context, toolName string) error {
	fmt.Printf("%s 工具資訊: %s\n", c.colorizer.Info("ℹ️"), c.colorizer.Value(toolName))
	
	// TODO: 從工具註冊表獲取實際工具資訊
	switch toolName {
	case "code_analyzer":
		fmt.Println(c.colorizer.Divider())
		fmt.Printf("描述: %s\n", "分析程式碼結構、複雜度和品質指標")
		fmt.Printf("參數: %s\n", "file_path (必需), language (可選)")
		fmt.Printf("範例: %s\n", c.colorizer.Code("assistant tools run code_analyzer main.go"))
	default:
		fmt.Println(c.colorizer.Warning("工具資訊正在開發中..."))
	}
	
	return nil
}

func (c *CLI) runTool(ctx context.Context, toolName string, args []string) error {
	fmt.Printf("%s 執行工具: %s\n", c.colorizer.Info("🏃"), c.colorizer.Value(toolName))
	
	spinner := ui.NewDotsSpinner(fmt.Sprintf("執行 %s...", toolName))
	spinner.Start()
	
	// 模擬工具執行
	time.Sleep(2 * time.Second)
	
	spinner.Stop()
	
	fmt.Println(c.colorizer.Success("工具執行完成"))
	
	return nil
}

func (c *CLI) setConfig(key, value string) error {
	fmt.Printf("%s 設定 %s = %s\n", c.colorizer.Success("✅"), c.colorizer.Bold(key), c.colorizer.Value(value))
	return nil
}

func (c *CLI) getConfig(key string) error {
	fmt.Printf("%s: %s\n", c.colorizer.Bold(key), c.colorizer.Value("[值]"))
	return nil
}