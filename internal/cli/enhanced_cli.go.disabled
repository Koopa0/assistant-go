package cli

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"
	"time"

	"github.com/chzyer/readline"
	"github.com/fatih/color"

	"github.com/koopa0/assistant-go/internal/assistant"
	"github.com/koopa0/assistant-go/internal/cli/ui"
	"github.com/koopa0/assistant-go/internal/config"
)

// EnhancedCLI 提供增強的命令列介面體驗
type EnhancedCLI struct {
	assistant     *assistant.Assistant
	config        *config.Config
	logger        *slog.Logger
	readline      *readline.Instance
	sessionID     string
	conversationID string
	history       []CLIMessage
	preferences   *CLIPreferences
	
	// UI 組件
	colorizer     *ui.Colorizer
	formatter     *ui.Formatter
	promptManager *ui.PromptManager
}

// CLIMessage 表示 CLI 訊息
type CLIMessage struct {
	ID        string                 `json:"id"`
	Role      string                 `json:"role"`      // user, assistant, system
	Content   string                 `json:"content"`
	Timestamp time.Time              `json:"timestamp"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// CLIPreferences 使用者偏好設定
type CLIPreferences struct {
	Language           string            `json:"language"`            // zh-TW, en
	Theme              string            `json:"theme"`               // dark, light, auto
	ShowTimestamps     bool              `json:"show_timestamps"`
	ShowTokenUsage     bool              `json:"show_token_usage"`
	AutoSave           bool              `json:"auto_save"`
	SaveDirectory      string            `json:"save_directory"`
	MaxHistorySize     int               `json:"max_history_size"`
	CompletionEnabled  bool              `json:"completion_enabled"`
	SyntaxHighlighting bool              `json:"syntax_highlighting"`
	CustomPrompts      map[string]string `json:"custom_prompts"`
}

// NewEnhancedCLI 建立增強的 CLI 實例
func NewEnhancedCLI(assistant *assistant.Assistant, config *config.Config, logger *slog.Logger) (*EnhancedCLI, error) {
	sessionID := fmt.Sprintf("cli-%d", time.Now().Unix())
	
	// 建立 readline 實例
	rl, err := readline.NewEx(&readline.Config{
		Prompt:          ui.GetColoredPrompt("助手", "normal"),
		HistoryFile:     filepath.Join(os.TempDir(), "assistant-cli-history"),
		AutoComplete:    newAutoCompleter(),
		InterruptPrompt: "^C",
		EOFPrompt:       "exit",
		HistorySearchFold: true,
	})
	if err != nil {
		return nil, fmt.Errorf("建立 readline 實例失敗: %w", err)
	}

	// 載入使用者偏好
	preferences, err := loadPreferences()
	if err != nil {
		logger.Warn("載入偏好設定失敗，使用預設值", slog.Any("error", err))
		preferences = getDefaultPreferences()
	}

	cli := &EnhancedCLI{
		assistant:      assistant,
		config:         config,
		logger:         logger,
		readline:       rl,
		sessionID:      sessionID,
		conversationID: "",
		history:        make([]CLIMessage, 0),
		preferences:    preferences,
		colorizer:      ui.NewColorizer(preferences.Theme),
		formatter:      ui.NewFormatter(),
		promptManager:  ui.NewPromptManager(),
	}

	return cli, nil
}

// Run 執行 CLI 主迴圈
func (cli *EnhancedCLI) Run(ctx context.Context) error {
	defer cli.readline.Close()

	// 顯示歡迎訊息
	cli.showWelcomeMessage()

	// 設定信號處理
	signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM)

	// 主迴圈
	for {
		select {
		case <-ctx.Done():
			cli.showGoodbyeMessage()
			return ctx.Err()
		case <-signalChan:
			cli.showGoodbyeMessage()
			return nil
		default:
			// 讀取使用者輸入
			input, err := cli.readline.Readline()
			if err != nil {
				if err == readline.ErrInterrupt {
					continue
				}
				if err == io.EOF {
					cli.showGoodbyeMessage()
					return nil
				}
				return fmt.Errorf("讀取輸入失敗: %w", err)
			}

			input = strings.TrimSpace(input)
			if input == "" {
				continue
			}

			// 處理命令
			if strings.HasPrefix(input, "/") {
				cli.handleCommand(ctx, input)
			} else {
				cli.handleQuery(ctx, input)
			}
		}
	}
}

// handleCommand 處理 CLI 命令
func (cli *EnhancedCLI) handleCommand(ctx context.Context, command string) {
	parts := strings.Fields(command)
	if len(parts) == 0 {
		return
	}

	cmd := parts[0]
	args := parts[1:]

	switch cmd {
	case "/help", "/h":
		cli.showHelp()
	case "/clear", "/c":
		cli.clearScreen()
	case "/history", "/hist":
		cli.showHistory(args)
	case "/save":
		cli.saveConversation(args)
	case "/load":
		cli.loadConversation(args)
	case "/new", "/n":
		cli.newConversation()
	case "/preferences", "/prefs":
		cli.handlePreferences(args)
	case "/status":
		cli.showStatus(ctx)
	case "/memory":
		cli.showMemoryStatus(ctx)
	case "/tools":
		cli.showAvailableTools(ctx)
	case "/search":
		cli.handleSearch(ctx, args)
	case "/export":
		cli.exportConversation(args)
	case "/theme":
		cli.changeTheme(args)
	case "/language", "/lang":
		cli.changeLanguage(args)
	case "/prompt":
		cli.customPrompt(args)
	case "/exit", "/quit", "/q":
		os.Exit(0)
	default:
		cli.printError(fmt.Sprintf("未知命令: %s\n輸入 /help 查看可用命令", cmd))
	}
}

// handleQuery 處理使用者查詢
func (cli *EnhancedCLI) handleQuery(ctx context.Context, query string) {
	// 記錄使用者訊息
	userMessage := CLIMessage{
		ID:        fmt.Sprintf("msg-%d", time.Now().UnixNano()),
		Role:      "user",
		Content:   query,
		Timestamp: time.Now(),
	}
	cli.addToHistory(userMessage)

	// 顯示正在處理的指示器
	spinner := cli.showSpinner("正在思考中...")
	defer spinner.Stop()

	// 準備系統上下文
	systemContext := map[string]interface{}{
		"session_id":      cli.sessionID,
		"conversation_id": cli.conversationID,
		"cli_mode":        true,
		"preferences":     cli.preferences,
	}

	// 處理查詢
	start := time.Now()
	response, err := cli.assistant.ProcessQuery(ctx, query, systemContext)
	processingTime := time.Since(start)

	spinner.Stop()

	if err != nil {
		cli.printError(fmt.Sprintf("處理查詢時發生錯誤: %v", err))
		return
	}

	// 記錄助手回應
	assistantMessage := CLIMessage{
		ID:        response.ID,
		Role:      "assistant",
		Content:   response.Response,
		Timestamp: time.Now(),
		Metadata: map[string]interface{}{
			"processing_time": processingTime,
			"usage":          response.Usage,
			"context":        response.Context,
		},
	}
	cli.addToHistory(assistantMessage)

	// 設定對話 ID
	if cli.conversationID == "" && response.ConversationID != "" {
		cli.conversationID = response.ConversationID
	}

	// 顯示回應
	cli.displayAssistantResponse(assistantMessage)

	// 自動儲存
	if cli.preferences.AutoSave {
		cli.autoSave()
	}
}

// showWelcomeMessage 顯示歡迎訊息
func (cli *EnhancedCLI) showWelcomeMessage() {
	logo := ui.GetLogo()
	welcome := cli.getLocalizedText("welcome_message")
	
	fmt.Print(logo)
	fmt.Println(cli.colorizer.Title(welcome))
	fmt.Println(cli.colorizer.Subtitle("輸入 /help 查看可用命令"))
	fmt.Println(cli.colorizer.Divider())
	fmt.Println()
}

// showGoodbyeMessage 顯示再見訊息
func (cli *EnhancedCLI) showGoodbyeMessage() {
	goodbye := cli.getLocalizedText("goodbye_message")
	fmt.Println()
	fmt.Println(cli.colorizer.Info(goodbye))
}

// showHelp 顯示幫助訊息
func (cli *EnhancedCLI) showHelp() {
	help := `
╭──────────────────────────────────────────────────────────────────╮
│                           助手命令說明                             │
├──────────────────────────────────────────────────────────────────┤
│ 基本命令：                                                        │
│   /help, /h           顯示此幫助訊息                              │
│   /clear, /c          清除螢幕                                    │
│   /new, /n            開始新對話                                  │
│   /exit, /quit, /q    結束程式                                    │
│                                                                  │
│ 對話管理：                                                        │
│   /history [數量]     顯示對話歷史                                │
│   /save [檔名]        儲存當前對話                                │
│   /load [檔名]        載入對話                                    │
│   /export [格式]      匯出對話 (json, markdown, txt)             │
│                                                                  │
│ 系統功能：                                                        │
│   /status             顯示系統狀態                                │
│   /memory             顯示記憶體狀態                              │
│   /tools              顯示可用工具                                │
│   /search [關鍵字]    搜尋知識庫                                  │
│                                                                  │
│ 個人化設定：                                                      │
│   /preferences        管理偏好設定                                │
│   /theme [主題]       更改主題 (dark, light, auto)               │
│   /language [語言]    更改語言 (zh-TW, en)                       │
│   /prompt [名稱]      使用自訂提示                                │
│                                                                  │
│ 提示：直接輸入問題即可開始對話！                                   │
╰──────────────────────────────────────────────────────────────────╯
`
	fmt.Print(cli.colorizer.Help(help))
}

// showStatus 顯示系統狀態
func (cli *EnhancedCLI) showStatus(ctx context.Context) {
	fmt.Println(cli.colorizer.Title("🔧 系統狀態"))
	fmt.Println(cli.colorizer.Divider())
	
	// 基本資訊
	fmt.Printf("會話 ID: %s\n", cli.colorizer.Value(cli.sessionID))
	fmt.Printf("對話 ID: %s\n", cli.colorizer.Value(cli.conversationID))
	fmt.Printf("訊息數量: %s\n", cli.colorizer.Value(fmt.Sprintf("%d", len(cli.history))))
	
	// 偏好設定
	fmt.Printf("語言: %s\n", cli.colorizer.Value(cli.preferences.Language))
	fmt.Printf("主題: %s\n", cli.colorizer.Value(cli.preferences.Theme))
	fmt.Printf("自動儲存: %s\n", cli.colorizer.Value(fmt.Sprintf("%t", cli.preferences.AutoSave)))
	
	// 記憶體資訊
	fmt.Println(cli.colorizer.Divider())
	fmt.Println(cli.colorizer.Subtitle("記憶體狀態"))
	
	// TODO: 從助手獲取真實的記憶體狀態
	fmt.Printf("工作記憶體: %s\n", cli.colorizer.Success("正常"))
	fmt.Printf("語義記憶體: %s\n", cli.colorizer.Success("正常"))
	fmt.Printf("程序記憶體: %s\n", cli.colorizer.Success("正常"))
	
	fmt.Println()
}

// showMemoryStatus 顯示詳細記憶體狀態
func (cli *EnhancedCLI) showMemoryStatus(ctx context.Context) {
	fmt.Println(cli.colorizer.Title("🧠 記憶體詳細狀態"))
	fmt.Println(cli.colorizer.Divider())
	
	// TODO: 從助手的記憶體系統獲取真實狀態
	fmt.Println(cli.colorizer.Subtitle("工作記憶體"))
	fmt.Printf("  容量使用率: %s\n", cli.colorizer.Value("45%"))
	fmt.Printf("  活躍項目: %s\n", cli.colorizer.Value("12"))
	fmt.Printf("  注意焦點: %s\n", cli.colorizer.Value("API 設計"))
	
	fmt.Println(cli.colorizer.Subtitle("語義記憶體"))
	fmt.Printf("  概念數量: %s\n", cli.colorizer.Value("1,234"))
	fmt.Printf("  關係數量: %s\n", cli.colorizer.Value("3,456"))
	fmt.Printf("  最新學習: %s\n", cli.colorizer.Value("CLI 設計模式"))
	
	fmt.Println(cli.colorizer.Subtitle("程序記憶體"))
	fmt.Printf("  程序數量: %s\n", cli.colorizer.Value("89"))
	fmt.Printf("  技能數量: %s\n", cli.colorizer.Value("45"))
	fmt.Printf("  成功率: %s\n", cli.colorizer.Value("92%"))
	
	fmt.Println()
}

// showAvailableTools 顯示可用工具
func (cli *EnhancedCLI) showAvailableTools(ctx context.Context) {
	fmt.Println(cli.colorizer.Title("🛠️  可用工具"))
	fmt.Println(cli.colorizer.Divider())
	
	// TODO: 從工具註冊表獲取真實工具列表
	tools := []struct {
		Name        string
		Description string
		Category    string
		Status      string
	}{
		{"code_analyzer", "分析程式碼結構和品質", "開發工具", "可用"},
		{"file_processor", "處理和分析檔案內容", "檔案工具", "可用"},
		{"web_searcher", "搜尋網路資訊", "資訊工具", "可用"},
		{"database_tool", "資料庫查詢和管理", "資料工具", "可用"},
	}
	
	for _, tool := range tools {
		status := cli.colorizer.Success("●")
		if tool.Status != "可用" {
			status = cli.colorizer.Error("●")
		}
		
		fmt.Printf("%s %s - %s (%s)\n", 
			status,
			cli.colorizer.Bold(tool.Name),
			tool.Description,
			cli.colorizer.Dim(tool.Category),
		)
	}
	
	fmt.Println()
}

// displayAssistantResponse 顯示助手回應
func (cli *EnhancedCLI) displayAssistantResponse(message CLIMessage) {
	fmt.Println()
	
	// 顯示時間戳（如果啟用）
	if cli.preferences.ShowTimestamps {
		timestamp := message.Timestamp.Format("15:04:05")
		fmt.Printf("%s ", cli.colorizer.Dim(timestamp))
	}
	
	// 顯示角色標識
	fmt.Printf("%s ", cli.colorizer.Assistant("🤖 助手"))
	
	// 顯示回應內容
	content := cli.formatter.FormatContent(message.Content, cli.preferences.SyntaxHighlighting)
	fmt.Println(content)
	
	// 顯示元數據（如果有）
	if metadata := message.Metadata; metadata != nil {
		if cli.preferences.ShowTokenUsage {
			if usage, ok := metadata["usage"]; ok {
				cli.displayTokenUsage(usage)
			}
		}
		
		if processingTime, ok := metadata["processing_time"]; ok {
			if duration, ok := processingTime.(time.Duration); ok {
				fmt.Printf("%s 處理時間: %v\n", 
					cli.colorizer.Dim("⏱️"),
					cli.colorizer.Dim(duration.String()),
				)
			}
		}
	}
	
	fmt.Println()
}

// displayTokenUsage 顯示 token 使用情況
func (cli *EnhancedCLI) displayTokenUsage(usage interface{}) {
	if usageMap, ok := usage.(map[string]interface{}); ok {
		fmt.Printf("%s Token 使用: ", cli.colorizer.Dim("📊"))
		
		if input, ok := usageMap["input_tokens"]; ok {
			fmt.Printf("輸入 %v, ", cli.colorizer.Dim(fmt.Sprintf("%v", input)))
		}
		if output, ok := usageMap["output_tokens"]; ok {
			fmt.Printf("輸出 %v, ", cli.colorizer.Dim(fmt.Sprintf("%v", output)))
		}
		if total, ok := usageMap["total_tokens"]; ok {
			fmt.Printf("總計 %v", cli.colorizer.Dim(fmt.Sprintf("%v", total)))
		}
		
		fmt.Println()
	}
}

// 輔助方法

// addToHistory 添加訊息到歷史記錄
func (cli *EnhancedCLI) addToHistory(message CLIMessage) {
	cli.history = append(cli.history, message)
	
	// 限制歷史記錄大小
	if len(cli.history) > cli.preferences.MaxHistorySize {
		cli.history = cli.history[1:]
	}
}

// showSpinner 顯示處理指示器
func (cli *EnhancedCLI) showSpinner(message string) *ui.Spinner {
	spinner := ui.NewSpinner(message)
	spinner.Start()
	return spinner
}

// printError 顯示錯誤訊息
func (cli *EnhancedCLI) printError(message string) {
	fmt.Printf("%s %s\n", cli.colorizer.Error("❌"), cli.colorizer.Error(message))
}

// printSuccess 顯示成功訊息
func (cli *EnhancedCLI) printSuccess(message string) {
	fmt.Printf("%s %s\n", cli.colorizer.Success("✅"), cli.colorizer.Success(message))
}

// clearScreen 清除螢幕
func (cli *EnhancedCLI) clearScreen() {
	fmt.Print("\033[2J\033[H")
}

// getLocalizedText 獲取本地化文字
func (cli *EnhancedCLI) getLocalizedText(key string) string {
	texts := map[string]map[string]string{
		"zh-TW": {
			"welcome_message": "歡迎使用智慧助手！我是您的個人 AI 夥伴，隨時為您提供協助。",
			"goodbye_message": "感謝使用智慧助手！期待下次為您服務。",
		},
		"en": {
			"welcome_message": "Welcome to the Intelligent Assistant! I'm your personal AI companion, ready to help you anytime.",
			"goodbye_message": "Thank you for using the Intelligent Assistant! Looking forward to serving you again.",
		},
	}
	
	if langTexts, ok := texts[cli.preferences.Language]; ok {
		if text, ok := langTexts[key]; ok {
			return text
		}
	}
	
	// 預設返回繁體中文
	if zhTexts, ok := texts["zh-TW"]; ok {
		if text, ok := zhTexts[key]; ok {
			return text
		}
	}
	
	return key
}

// 更多實作方法...

// newConversation 開始新對話
func (cli *EnhancedCLI) newConversation() {
	cli.conversationID = ""
	cli.history = make([]CLIMessage, 0)
	cli.printSuccess("已開始新對話")
}

// autoSave 自動儲存對話
func (cli *EnhancedCLI) autoSave() {
	if len(cli.history) == 0 {
		return
	}
	
	filename := fmt.Sprintf("conversation-%s.json", time.Now().Format("20060102-150405"))
	filepath := filepath.Join(cli.preferences.SaveDirectory, filename)
	
	if err := cli.saveToFile(filepath); err != nil {
		cli.logger.Error("自動儲存失敗", slog.Any("error", err))
	}
}

// saveToFile 儲存對話到檔案
func (cli *EnhancedCLI) saveToFile(filepath string) error {
	data := map[string]interface{}{
		"session_id":      cli.sessionID,
		"conversation_id": cli.conversationID,
		"created_at":      time.Now(),
		"messages":        cli.history,
		"preferences":     cli.preferences,
	}
	
	file, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("建立檔案失敗: %w", err)
	}
	defer file.Close()
	
	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	
	return encoder.Encode(data)
}

// loadPreferences 載入使用者偏好
func loadPreferences() (*CLIPreferences, error) {
	configDir, err := os.UserConfigDir()
	if err != nil {
		return nil, err
	}
	
	prefsPath := filepath.Join(configDir, "assistant", "cli-preferences.json")
	
	file, err := os.Open(prefsPath)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	
	var prefs CLIPreferences
	if err := json.NewDecoder(file).Decode(&prefs); err != nil {
		return nil, err
	}
	
	return &prefs, nil
}

// getDefaultPreferences 獲取預設偏好設定
func getDefaultPreferences() *CLIPreferences {
	homeDir, _ := os.UserHomeDir()
	saveDir := filepath.Join(homeDir, "Documents", "Assistant")
	
	return &CLIPreferences{
		Language:           "zh-TW",
		Theme:              "auto",
		ShowTimestamps:     true,
		ShowTokenUsage:     true,
		AutoSave:           true,
		SaveDirectory:      saveDir,
		MaxHistorySize:     1000,
		CompletionEnabled:  true,
		SyntaxHighlighting: true,
		CustomPrompts:      make(map[string]string),
	}
}

// newAutoCompleter 建立自動完成器
func newAutoCompleter() *readline.PrefixCompleter {
	return readline.NewPrefixCompleter(
		readline.PcItem("/help"),
		readline.PcItem("/clear"),
		readline.PcItem("/history"),
		readline.PcItem("/save"),
		readline.PcItem("/load"),
		readline.PcItem("/new"),
		readline.PcItem("/preferences"),
		readline.PcItem("/status"),
		readline.PcItem("/memory"),
		readline.PcItem("/tools"),
		readline.PcItem("/search"),
		readline.PcItem("/export"),
		readline.PcItem("/theme",
			readline.PcItem("dark"),
			readline.PcItem("light"),
			readline.PcItem("auto"),
		),
		readline.PcItem("/language",
			readline.PcItem("zh-TW"),
			readline.PcItem("en"),
		),
		readline.PcItem("/exit"),
		readline.PcItem("/quit"),
	)
}